[
  {
    "objectID": "30_metal.html",
    "href": "30_metal.html",
    "title": "Bare Metal",
    "section": "",
    "text": "Action Items:\n\nmalloc stands eternal\n\nPossibly the coolest assignment ever\nI‚Äôm glad you all love it\n\nHomework this week is more complicated but also more supported.\n\nPrioritize malloc I think.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#announcements",
    "href": "30_metal.html#announcements",
    "title": "Bare Metal",
    "section": "",
    "text": "Action Items:\n\nmalloc stands eternal\n\nPossibly the coolest assignment ever\nI‚Äôm glad you all love it\n\nHomework this week is more complicated but also more supported.\n\nPrioritize malloc I think.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#today",
    "href": "30_metal.html#today",
    "title": "Bare Metal",
    "section": "Today",
    "text": "Today\n\nBare metal\n\nBare metal\nRanting about how cool this is\nSimulation\nEmulation\n\nA bare metal binary\n\nRuntimes\nstd",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#citations",
    "href": "30_metal.html#citations",
    "title": "Bare Metal",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nWelcome to Bare Metal Rust\nA Freestanding Rust Binary",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#throwback-thmonday",
    "href": "30_metal.html#throwback-thmonday",
    "title": "Bare Metal",
    "section": "Throwback ThMonday",
    "text": "Throwback ThMonday\n\nI did this in grad school.\n\nRTL Simulation of C-Program on Bare-metal OR1200\n\nMy researcher (Juni) did this in ‚Äô22\n\nBare-Metal Programs on RISC-V\n\nI did this‚Ä¶ last week.\n\nSlides including bare-metal execution in Verilog",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#bare-metal",
    "href": "30_metal.html#bare-metal",
    "title": "Bare Metal",
    "section": "Bare Metal",
    "text": "Bare Metal\n\nA computer which has no operating system. The software executed by a bare machine, commonly called a ‚Äúbare metal program‚Äù or ‚Äúbare metal application‚Äù, is designed to interact directly with hardware. Bare machines are widely used in embedded systems, particularly in cases where resources are limited or high performance is required.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#some-terms",
    "href": "30_metal.html#some-terms",
    "title": "Bare Metal",
    "section": "Some Terms",
    "text": "Some Terms\n\nShould introduce a few terms.\n\nNot required for OS but useful to know.\n\nTerms\n\nSimulation\nEmulation\nCross-compilation\nQEMU",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#simulation",
    "href": "30_metal.html#simulation",
    "title": "Bare Metal",
    "section": "Simulation",
    "text": "Simulation\n\nModels a system‚Äôs behavior\nFocuses on high-level results, not internal logic\n‚ÄúClose enough‚Äù for performance or logic testing\nSimulating hardware components in software\nFaster but less precise",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#emulation",
    "href": "30_metal.html#emulation",
    "title": "Bare Metal",
    "section": "Emulation",
    "text": "Emulation\n\nReplicating exact internal behavior of hardware\nSoftware acting as hardware (CPU, registers, memory)\nAccuracy vs.¬†Speed:\n\nMuch slower than simulation‚Ä¶ unless?\nGoal: Guest software doesn‚Äôt know it‚Äôs not on actual silicon",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#example",
    "href": "30_metal.html#example",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nx86-64 - the Intel/AMD architecture common for Linux and Windows - supports a ‚Äúlong double‚Äù float with 80 bits of precision.\nARM64 - a competing formulation most popularized as ‚ÄúApple silicon‚Äù with the M1 - lacks long doubles.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#context",
    "href": "30_metal.html#context",
    "title": "Bare Metal",
    "section": "Context",
    "text": "Context\n\nIt is trivial to implement a float in software‚Ä¶\n\nf16\n\nIt is relatively not-trivial to implement an architecture in software, though possible.\n\nHere‚Äôs the smallest example I know:\nPicoRV32",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#cross-compiling",
    "href": "30_metal.html#cross-compiling",
    "title": "Bare Metal",
    "section": "Cross-Compiling",
    "text": "Cross-Compiling\n\nExample:‚Äù compiling code on an x86 laptop for an ARM chip\n\nCommon in embedded applications (e.g.¬†program a thermostat)\n\nCompiler runs on Host A, produces binary for Target B\n\nEssential for ‚Äúbare metal‚Äù development\nTransmit the binary over wires (the bus!) to another device‚Äôs memory.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#considerations",
    "href": "30_metal.html#considerations",
    "title": "Bare Metal",
    "section": "Considerations",
    "text": "Considerations\n\nWe must:\n\nTarget a specific architecture\nLink against specific hardware memory maps\n\nSomehow you also need the actual hardware, unless‚Ä¶",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#qemu",
    "href": "30_metal.html#qemu",
    "title": "Bare Metal",
    "section": "QEMU",
    "text": "QEMU\n\nI used this a lot in grad school; less now.\n\nSupports both emulation and virtualization\n\nVirtualization emulates a device rather than a binary.\nUsed in cloud; can be fast; huge research area.\n\n\nLet‚Äôs us run bare metal binaries without physical chips (which would cost $)\nWrite locally \\(\\rightarrow\\) Cross-compile \\(\\rightarrow\\) Run in QEMU",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#first-steps",
    "href": "30_metal.html#first-steps",
    "title": "Bare Metal",
    "section": "First Steps",
    "text": "First Steps\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library.\nThis makes it possible to run Rust code on the ‚Äúbare metal‚Äù without an underlying operating system.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#introduction",
    "href": "30_metal.html#introduction",
    "title": "Bare Metal",
    "section": "Introduction",
    "text": "Introduction\n\nTo write an operating system kernel, we need code that does not depend on any operating system features.\nThis means that we can‚Äôt use files, the heap, networks, random numbers, standard output, etc.\nWe‚Äôre trying to write our own OS!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#on-std",
    "href": "30_metal.html#on-std",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWe can‚Äôt use most of the Rust standard library, but‚Ä¶\n‚Ä¶there are a lot of Rust features that we can use.\nFor example, we can use iterators, closures, pattern matching, option and result\n\nRecall the official Calvin Deutschbein position on option and result:\n‚ÄúIt‚Äôs why Rust is good.‚Äù - me",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#on-std-1",
    "href": "30_metal.html#on-std-1",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWhile not initially helpful, we can use string formatting, and‚Ä¶\n‚Ä¶ the ownership system.\n\nBeats malloc!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#quoth-the-blog",
    "href": "30_metal.html#quoth-the-blog",
    "title": "Bare Metal",
    "section": "Quoth The Blog",
    "text": "Quoth The Blog\n\nThese features make it possible to write a kernel in a very expressive, high level way without worrying about undefined behavior or memory safety.\n\n\nWell, we‚Äôll see.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#we-keep",
    "href": "30_metal.html#we-keep",
    "title": "Bare Metal",
    "section": "We keep",
    "text": "We keep\n\noption\nresult\nRust standard library\niterators\nclosures\npattern matching\nstring formatting\nownership system\nundefined behavior\nmemory safety",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#onward",
    "href": "30_metal.html#onward",
    "title": "Bare Metal",
    "section": "Onward!",
    "text": "Onward!\n\nWe now enumerate the necessary steps to create a freestanding Rust binary‚Ä¶\n‚Ä¶and explains why the steps are needed.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#no_std",
    "href": "30_metal.html#no_std",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nBy default, all Rust crates link the standard library.\n\nIt depends on the operating system for features such as threads, files, or networking.\nIt also depends on the C standard library libc, which closely interacts with OS services.\n\nThat is, part of GNU but not part of Linux.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#no_std-1",
    "href": "30_metal.html#no_std-1",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nSince our plan is to write an operating system, we can‚Äôt use any OS-dependent libraries.\n\nThat would be recursive, which is only good sometimes!\n\nSo we have to disable the automatic inclusion of the standard library through the no_std attribute.\n\nstandard library\nno_std attribute",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#to-begin",
    "href": "30_metal.html#to-begin",
    "title": "Bare Metal",
    "section": "To begin",
    "text": "To begin\n\nWe can start creation the same way we make anything else in Rust‚Ä¶\nCargo (sighs heavily)\n\ncargo new ????",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#example-1",
    "href": "30_metal.html#example-1",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nPersonally, I would expect you to maintain different OS versions with same crate name but within distinctly named directories (32,42 etc.)\n\ncargo new 32 --name osirs --vcs none",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#branches",
    "href": "30_metal.html#branches",
    "title": "Bare Metal",
    "section": "Branches",
    "text": "Branches\n\nA competing formulation would be to use git branch to create different developmental branches.\nThis is the industry standard and I wanted to introduce it but felt a time crunch.\nIf you are looking for something to do, figure it out.\n\nDon‚Äôt worry about me finding things; its worth it to me for you to learn.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#name",
    "href": "30_metal.html#name",
    "title": "Bare Metal",
    "section": "Name",
    "text": "Name\n\n\n\nYou don‚Äôt have to name your OS anything in particular, I just thought osirs (OS in Rust) sounded heckin‚Äô rad.\n ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\nAlso a cringe AI real estate firm!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#refresh",
    "href": "30_metal.html#refresh",
    "title": "Bare Metal",
    "section": "Refresh",
    "text": "Refresh\n\nWhen we run the command, cargo creates the following directory structure for us:\n\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n1 directory, 2 files",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#recall",
    "href": "30_metal.html#recall",
    "title": "Bare Metal",
    "section": "Recall",
    "text": "Recall\n\nCargo.toml contains the crate configuration\n\nCrate name\nCrate author\nCrate version\n\nsrc/main.rs file contains our main function.\nAfter cargo build, find the compiled osirs binary in the target/debug subfolder.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#blah-blah-blah",
    "href": "30_metal.html#blah-blah-blah",
    "title": "Bare Metal",
    "section": "Blah blah blah",
    "text": "Blah blah blah\n\u0016$ cargo build ; tree\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ target\n    ‚îú‚îÄ‚îÄ CACHEDIR.TAG\n    ‚îî‚îÄ‚îÄ debug\n        ‚îú‚îÄ‚îÄ build\n        ‚îú‚îÄ‚îÄ deps\n        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ osirs-43412975b38d059d\n        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ osirs-43412975b38d059d.d\n        ‚îú‚îÄ‚îÄ examples\n        ‚îú‚îÄ‚îÄ incremental\n        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ osirs-3gae52yq1943v\n        ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ s-hfeunnoewq-0c8luu5-5dmhke08rl6h5l09ku3va3gkx\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 1tq3ts5gahvv7j1hzrmfdrzi6.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 6zk3flo890c0qhh6fykb6746g.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 8z45o15v3gxm5hydv3o63x07l.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 9itjtn00r7d8c6mknmav20oex.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bh9pj42wzikjd1ilqutnjbrx7.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dep-graph.bin\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ eymyqxruzdb24suchgzd8ygxb.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ query-cache.bin\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ work-products.bin\n        ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ s-hfeunnoewq-0c8luu5.lock\n        ‚îú‚îÄ‚îÄ osirs\n        ‚îî‚îÄ‚îÄ osirs.d\n\n9 directories, 18 files",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#running",
    "href": "30_metal.html#running",
    "title": "Bare Metal",
    "section": "Running",
    "text": "Running\n\nTechnically no one can stop you from using cargo run or even cargo run --release\nBut you can also just build and then directly run the executable.\n\n\u0016\u0016$ ./target/debug/osirs\nHello, world!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#the-no_std-attribute",
    "href": "30_metal.html#the-no_std-attribute",
    "title": "Bare Metal",
    "section": "The no_std Attribute",
    "text": "The no_std Attribute\n\nInitially, the crate implicitly links the standard library.\nWe can prepend the no_std attribute to src/main.rs to get the version of Rust that builds character!\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n}",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#we-can-rebuild",
    "href": "30_metal.html#we-can-rebuild",
    "title": "Bare Metal",
    "section": "We Can Rebuild",
    "text": "We Can Rebuild\n\nActually we can‚Äôt.\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n  |     ^^^^^^^\n\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 3 previous errors    ^^^^^^^",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#enhance",
    "href": "30_metal.html#enhance",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n  |     ^^^^^^^\n\nOh right, we can‚Äôt print without an OS.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#background",
    "href": "30_metal.html#background",
    "title": "Bare Metal",
    "section": "Background",
    "text": "Background\n\nThe println macro is part of the standard library std.\nWe said no_std.\nSo we can no longer print things.\nI hope it is clear how this is character-building!\nRead more:\n\nprintln macro\nstandard output",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#rip-it",
    "href": "30_metal.html#rip-it",
    "title": "Bare Metal",
    "section": "Rip it",
    "text": "Rip it\n\nRemove the printing and try again:\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    // println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n}",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#problems-remain",
    "href": "30_metal.html#problems-remain",
    "title": "Bare Metal",
    "section": "Problems remain",
    "text": "Problems remain\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 2 previous errors",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#enhance-1",
    "href": "30_metal.html#enhance-1",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n  |     ^^^^^^^\n\nSometimes, Rust explodes and calls the OS (written in C!) for help.\nIt can‚Äôt do that without std and is sad üò≠",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panic",
    "href": "30_metal.html#panic",
    "title": "Bare Metal",
    "section": "Panic",
    "text": "Panic\n\nThe panic_handler attribute defines the function that the compiler should invoke when a panic occurs.\nstd provides its own panic handler function, but in a no_std environment we need to define it ourselves:\npanic",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#our-approach",
    "href": "30_metal.html#our-approach",
    "title": "Bare Metal",
    "section": "Our Approach",
    "text": "Our Approach\n\n\nsrc/main.rs\n\n// main.rs\n\n/// This function is called on panic.\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panics",
    "href": "30_metal.html#panics",
    "title": "Bare Metal",
    "section": "Panics",
    "text": "Panics\n\nThe PanicInfo parameter contains:\n\nfile and line where the panic happened\npanic message (e.g.¬†panic!(\"YOLO\")\n\nThe function should never return.\n\nSo it is marked as a ‚Äúdiverging function‚Äù\nIt returns the ‚Äúnever‚Äù type !.\n\nNot much we can do in this function for now, so just recurse to prevent a return.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#read-more",
    "href": "30_metal.html#read-more",
    "title": "Bare Metal",
    "section": "Read more‚Ä¶",
    "text": "Read more‚Ä¶\n\nI had never heard of or used these but to me it was clear why they would have to exist in a type safe language.\n\nPanicInfo\ndiverging function\n‚Äúnever‚Äù type",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#retry",
    "href": "30_metal.html#retry",
    "title": "Bare Metal",
    "section": "Retry",
    "text": "Retry\n\nI bet it works now!\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nThey should make a version of the OS class that is easy.\n\n(They did - this class)",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panic-abort",
    "href": "30_metal.html#panic-abort",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\n\n\nFun fact - back when I was an OS engineer slash rocket scientist my first launch was ‚ÄúPA-1‚Äù for ‚ÄúPad Abort 1‚Äù\n\nBlew up a rocket on the launch pad to make sure it was safe for humans.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panic-abort-1",
    "href": "30_metal.html#panic-abort-1",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\nThe use of the term ‚Äúabort‚Äù which in some nation-states is a hot-button political issue has come up from time-to-time in the discourse.\nRead more from 2018\n\n\n25.7.4 Aborting a Program\n\n...\n\nFuture Change Warning: Proposed Federal censorship regulations may prohibit us from giving you information about the possibility of calling this function. We would be required to say that this is not an acceptable way of terminating a program.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#quoth-stallman",
    "href": "30_metal.html#quoth-stallman",
    "title": "Bare Metal",
    "section": "Quoth Stallman",
    "text": "Quoth Stallman\n\n‚ÄúThe point of this joke is even more important now than it was when I first wrote it,‚Äù [Free Software Foundation president] Stallman wrote in a note posted to project mailing list, in reference to today‚Äôs political climate. ‚ÄúPlease do not remove it. GNU is not a purely technical project, so the fact that this is not strictly and grimly technical is not a reason to remove this.‚Äù",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#now-in-rust",
    "href": "30_metal.html#now-in-rust",
    "title": "Bare Metal",
    "section": "Now in Rust",
    "text": "Now in Rust\n\nWe can oppose fascism and\n\n(looks into the history of NASA and Lockheed Martin)\n(clears throat)\nMoving on!\n\n\nWe can abort programs‚Ä¶ in Rust",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#how",
    "href": "30_metal.html#how",
    "title": "Bare Metal",
    "section": "How?",
    "text": "How?\n\nRead carefully:\n\n= help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n= note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nGeniuses will recognize panic=\"abort\" syntax",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#toml",
    "href": "30_metal.html#toml",
    "title": "Bare Metal",
    "section": "TOML",
    "text": "TOML\n\nIt‚Äôs .toml\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#crate-options",
    "href": "30_metal.html#crate-options",
    "title": "Bare Metal",
    "section": "Crate options",
    "text": "Crate options\n\nNominally there are use cases for which unwinding is undesirable\n\nMy take: All cases.\n\nSo Rust provides an option to ‚Äúabort on panic‚Äù instead.\nOur reference materials claims this disables the generation of unwinding symbol information and thus considerably reduces binary size.\n\nI could not verify this independently.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#update-cargo.toml",
    "href": "30_metal.html#update-cargo.toml",
    "title": "Bare Metal",
    "section": "Update Cargo.toml",
    "text": "Update Cargo.toml\n\nAdd the following:\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#now",
    "href": "30_metal.html#now",
    "title": "Bare Metal",
    "section": "Now‚Ä¶",
    "text": "Now‚Ä¶\n\nThis sets the panic strategy to abort for both the dev profile (used for cargo build) and the release profile (used for cargo build --release).\nabort on panic\nI bet it will work now.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#whoops",
    "href": "30_metal.html#whoops",
    "title": "Bare Metal",
    "section": "Whoops!",
    "text": "Whoops!\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nWe don‚Äôt have and can‚Äôt use a main!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#to-be-continued",
    "href": "30_metal.html#to-be-continued",
    "title": "Bare Metal",
    "section": "To be continued",
    "text": "To be continued\n\nI am 99% sure we run out of time here‚Ä¶\nAnd will continue with the lab on linker errors!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.rjs.html#announcements",
    "href": "30_metal.rjs.html#announcements",
    "title": "Bare Metal",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nmalloc stands eternal\n\nPossibly the coolest assignment ever\nI‚Äôm glad you all love it\n\nHomework this week is more complicated but also more supported.\n\nPrioritize malloc I think."
  },
  {
    "objectID": "30_metal.rjs.html#today",
    "href": "30_metal.rjs.html#today",
    "title": "Bare Metal",
    "section": "Today",
    "text": "Today\n\nBare metal\n\nBare metal\nRanting about how cool this is\nSimulation\nEmulation\n\nA bare metal binary\n\nRuntimes\nstd"
  },
  {
    "objectID": "30_metal.rjs.html#citations",
    "href": "30_metal.rjs.html#citations",
    "title": "Bare Metal",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nWelcome to Bare Metal Rust\nA Freestanding Rust Binary"
  },
  {
    "objectID": "30_metal.rjs.html#throwback-thmonday",
    "href": "30_metal.rjs.html#throwback-thmonday",
    "title": "Bare Metal",
    "section": "Throwback ThMonday",
    "text": "Throwback ThMonday\n\nI did this in grad school.\n\nRTL Simulation of C-Program on Bare-metal OR1200\n\nMy researcher (Juni) did this in ‚Äô22\n\nBare-Metal Programs on RISC-V\n\nI did this‚Ä¶ last week.\n\nSlides including bare-metal execution in Verilog"
  },
  {
    "objectID": "30_metal.rjs.html#bare-metal",
    "href": "30_metal.rjs.html#bare-metal",
    "title": "Bare Metal",
    "section": "Bare Metal",
    "text": "Bare Metal\n\nA computer which has no operating system. The software executed by a bare machine, commonly called a ‚Äúbare metal program‚Äù or ‚Äúbare metal application‚Äù, is designed to interact directly with hardware. Bare machines are widely used in embedded systems, particularly in cases where resources are limited or high performance is required."
  },
  {
    "objectID": "30_metal.rjs.html#some-terms",
    "href": "30_metal.rjs.html#some-terms",
    "title": "Bare Metal",
    "section": "Some Terms",
    "text": "Some Terms\n\nShould introduce a few terms.\n\nNot required for OS but useful to know.\n\nTerms\n\nSimulation\nEmulation\nCross-compilation\nQEMU"
  },
  {
    "objectID": "30_metal.rjs.html#simulation",
    "href": "30_metal.rjs.html#simulation",
    "title": "Bare Metal",
    "section": "Simulation",
    "text": "Simulation\n\nModels a system‚Äôs behavior\nFocuses on high-level results, not internal logic\n‚ÄúClose enough‚Äù for performance or logic testing\nSimulating hardware components in software\nFaster but less precise"
  },
  {
    "objectID": "30_metal.rjs.html#emulation",
    "href": "30_metal.rjs.html#emulation",
    "title": "Bare Metal",
    "section": "Emulation",
    "text": "Emulation\n\nReplicating exact internal behavior of hardware\nSoftware acting as hardware (CPU, registers, memory)\nAccuracy vs.¬†Speed:\n\nMuch slower than simulation‚Ä¶ unless?\nGoal: Guest software doesn‚Äôt know it‚Äôs not on actual silicon"
  },
  {
    "objectID": "30_metal.rjs.html#example",
    "href": "30_metal.rjs.html#example",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nx86-64 - the Intel/AMD architecture common for Linux and Windows - supports a ‚Äúlong double‚Äù float with 80 bits of precision.\nARM64 - a competing formulation most popularized as ‚ÄúApple silicon‚Äù with the M1 - lacks long doubles."
  },
  {
    "objectID": "30_metal.rjs.html#context",
    "href": "30_metal.rjs.html#context",
    "title": "Bare Metal",
    "section": "Context",
    "text": "Context\n\nIt is trivial to implement a float in software‚Ä¶\n\nf16\n\nIt is relatively not-trivial to implement an architecture in software, though possible.\n\nHere‚Äôs the smallest example I know:\nPicoRV32"
  },
  {
    "objectID": "30_metal.rjs.html#cross-compiling",
    "href": "30_metal.rjs.html#cross-compiling",
    "title": "Bare Metal",
    "section": "Cross-Compiling",
    "text": "Cross-Compiling\n\nExample:‚Äù compiling code on an x86 laptop for an ARM chip\n\nCommon in embedded applications (e.g.¬†program a thermostat)\n\nCompiler runs on Host A, produces binary for Target B\n\nEssential for ‚Äúbare metal‚Äù development\nTransmit the binary over wires (the bus!) to another device‚Äôs memory."
  },
  {
    "objectID": "30_metal.rjs.html#considerations",
    "href": "30_metal.rjs.html#considerations",
    "title": "Bare Metal",
    "section": "Considerations",
    "text": "Considerations\n\nWe must:\n\nTarget a specific architecture\nLink against specific hardware memory maps\n\nSomehow you also need the actual hardware, unless‚Ä¶"
  },
  {
    "objectID": "30_metal.rjs.html#qemu",
    "href": "30_metal.rjs.html#qemu",
    "title": "Bare Metal",
    "section": "QEMU",
    "text": "QEMU\n\nI used this a lot in grad school; less now.\n\nSupports both emulation and virtualization\n\nVirtualization emulates a device rather than a binary.\nUsed in cloud; can be fast; huge research area.\n\n\nLet‚Äôs us run bare metal binaries without physical chips (which would cost $)\nWrite locally \\(\\rightarrow\\) Cross-compile \\(\\rightarrow\\) Run in QEMU"
  },
  {
    "objectID": "30_metal.rjs.html#first-steps",
    "href": "30_metal.rjs.html#first-steps",
    "title": "Bare Metal",
    "section": "First Steps",
    "text": "First Steps\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library.\nThis makes it possible to run Rust code on the ‚Äúbare metal‚Äù without an underlying operating system."
  },
  {
    "objectID": "30_metal.rjs.html#introduction",
    "href": "30_metal.rjs.html#introduction",
    "title": "Bare Metal",
    "section": "Introduction",
    "text": "Introduction\n\nTo write an operating system kernel, we need code that does not depend on any operating system features.\nThis means that we can‚Äôt use files, the heap, networks, random numbers, standard output, etc.\nWe‚Äôre trying to write our own OS!"
  },
  {
    "objectID": "30_metal.rjs.html#on-std",
    "href": "30_metal.rjs.html#on-std",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWe can‚Äôt use most of the Rust standard library, but‚Ä¶\n‚Ä¶there are a lot of Rust features that we can use.\nFor example, we can use iterators, closures, pattern matching, option and result\n\nRecall the official Calvin Deutschbein position on option and result:\n‚ÄúIt‚Äôs why Rust is good.‚Äù - me"
  },
  {
    "objectID": "30_metal.rjs.html#on-std-1",
    "href": "30_metal.rjs.html#on-std-1",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWhile not initially helpful, we can use string formatting, and‚Ä¶\n‚Ä¶ the ownership system.\n\nBeats malloc!"
  },
  {
    "objectID": "30_metal.rjs.html#quoth-the-blog",
    "href": "30_metal.rjs.html#quoth-the-blog",
    "title": "Bare Metal",
    "section": "Quoth The Blog",
    "text": "Quoth The Blog\n\nThese features make it possible to write a kernel in a very expressive, high level way without worrying about undefined behavior or memory safety.\n\n\nWell, we‚Äôll see."
  },
  {
    "objectID": "30_metal.rjs.html#we-keep",
    "href": "30_metal.rjs.html#we-keep",
    "title": "Bare Metal",
    "section": "We keep",
    "text": "We keep\n\noption\nresult\nRust standard library\niterators\nclosures\npattern matching\nstring formatting\nownership system\nundefined behavior\nmemory safety"
  },
  {
    "objectID": "30_metal.rjs.html#onward",
    "href": "30_metal.rjs.html#onward",
    "title": "Bare Metal",
    "section": "Onward!",
    "text": "Onward!\n\nWe now enumerate the necessary steps to create a freestanding Rust binary‚Ä¶\n‚Ä¶and explains why the steps are needed."
  },
  {
    "objectID": "30_metal.rjs.html#no_std",
    "href": "30_metal.rjs.html#no_std",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nBy default, all Rust crates link the standard library.\n\nIt depends on the operating system for features such as threads, files, or networking.\nIt also depends on the C standard library libc, which closely interacts with OS services.\n\nThat is, part of GNU but not part of Linux."
  },
  {
    "objectID": "30_metal.rjs.html#no_std-1",
    "href": "30_metal.rjs.html#no_std-1",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nSince our plan is to write an operating system, we can‚Äôt use any OS-dependent libraries.\n\nThat would be recursive, which is only good sometimes!\n\nSo we have to disable the automatic inclusion of the standard library through the no_std attribute.\n\nstandard library\nno_std attribute"
  },
  {
    "objectID": "30_metal.rjs.html#to-begin",
    "href": "30_metal.rjs.html#to-begin",
    "title": "Bare Metal",
    "section": "To begin",
    "text": "To begin\n\nWe can start creation the same way we make anything else in Rust‚Ä¶\nCargo (sighs heavily)\n\ncargo new ????"
  },
  {
    "objectID": "30_metal.rjs.html#example-1",
    "href": "30_metal.rjs.html#example-1",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nPersonally, I would expect you to maintain different OS versions with same crate name but within distinctly named directories (32,42 etc.)\n\ncargo new 32 --name osirs --vcs none"
  },
  {
    "objectID": "30_metal.rjs.html#branches",
    "href": "30_metal.rjs.html#branches",
    "title": "Bare Metal",
    "section": "Branches",
    "text": "Branches\n\nA competing formulation would be to use git branch to create different developmental branches.\nThis is the industry standard and I wanted to introduce it but felt a time crunch.\nIf you are looking for something to do, figure it out.\n\nDon‚Äôt worry about me finding things; its worth it to me for you to learn."
  },
  {
    "objectID": "30_metal.rjs.html#name",
    "href": "30_metal.rjs.html#name",
    "title": "Bare Metal",
    "section": "Name",
    "text": "Name\n\n\n\nYou don‚Äôt have to name your OS anything in particular, I just thought osirs (OS in Rust) sounded heckin‚Äô rad.\n ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\nAlso a cringe AI real estate firm!"
  },
  {
    "objectID": "30_metal.rjs.html#refresh",
    "href": "30_metal.rjs.html#refresh",
    "title": "Bare Metal",
    "section": "Refresh",
    "text": "Refresh\n\nWhen we run the command, cargo creates the following directory structure for us:\n\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n1 directory, 2 files"
  },
  {
    "objectID": "30_metal.rjs.html#recall",
    "href": "30_metal.rjs.html#recall",
    "title": "Bare Metal",
    "section": "Recall",
    "text": "Recall\n\nCargo.toml contains the crate configuration\n\nCrate name\nCrate author\nCrate version\n\nsrc/main.rs file contains our main function.\nAfter cargo build, find the compiled osirs binary in the target/debug subfolder."
  },
  {
    "objectID": "30_metal.rjs.html#blah-blah-blah",
    "href": "30_metal.rjs.html#blah-blah-blah",
    "title": "Bare Metal",
    "section": "Blah blah blah",
    "text": "Blah blah blah\n\u0016$ cargo build ; tree\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.rs\n‚îî‚îÄ‚îÄ target\n    ‚îú‚îÄ‚îÄ CACHEDIR.TAG\n    ‚îî‚îÄ‚îÄ debug\n        ‚îú‚îÄ‚îÄ build\n        ‚îú‚îÄ‚îÄ deps\n        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ osirs-43412975b38d059d\n        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ osirs-43412975b38d059d.d\n        ‚îú‚îÄ‚îÄ examples\n        ‚îú‚îÄ‚îÄ incremental\n        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ osirs-3gae52yq1943v\n        ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ s-hfeunnoewq-0c8luu5-5dmhke08rl6h5l09ku3va3gkx\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 1tq3ts5gahvv7j1hzrmfdrzi6.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 6zk3flo890c0qhh6fykb6746g.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 8z45o15v3gxm5hydv3o63x07l.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 9itjtn00r7d8c6mknmav20oex.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bh9pj42wzikjd1ilqutnjbrx7.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dep-graph.bin\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ eymyqxruzdb24suchgzd8ygxb.o\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ query-cache.bin\n        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ work-products.bin\n        ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ s-hfeunnoewq-0c8luu5.lock\n        ‚îú‚îÄ‚îÄ osirs\n        ‚îî‚îÄ‚îÄ osirs.d\n\n9 directories, 18 files"
  },
  {
    "objectID": "30_metal.rjs.html#running",
    "href": "30_metal.rjs.html#running",
    "title": "Bare Metal",
    "section": "Running",
    "text": "Running\n\nTechnically no one can stop you from using cargo run or even cargo run --release\nBut you can also just build and then directly run the executable.\n\n\u0016\u0016$ ./target/debug/osirs\nHello, world!"
  },
  {
    "objectID": "30_metal.rjs.html#the-no_std-attribute",
    "href": "30_metal.rjs.html#the-no_std-attribute",
    "title": "Bare Metal",
    "section": "The no_std Attribute",
    "text": "The no_std Attribute\n\nInitially, the crate implicitly links the standard library.\nWe can prepend the no_std attribute to src/main.rs to get the version of Rust that builds character!\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n}"
  },
  {
    "objectID": "30_metal.rjs.html#we-can-rebuild",
    "href": "30_metal.rjs.html#we-can-rebuild",
    "title": "Bare Metal",
    "section": "We Can Rebuild",
    "text": "We Can Rebuild\n\nActually we can‚Äôt.\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n  |     ^^^^^^^\n\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 3 previous errors    ^^^^^^^"
  },
  {
    "objectID": "30_metal.rjs.html#enhance",
    "href": "30_metal.rjs.html#enhance",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n  |     ^^^^^^^\n\nOh right, we can‚Äôt print without an OS."
  },
  {
    "objectID": "30_metal.rjs.html#background",
    "href": "30_metal.rjs.html#background",
    "title": "Bare Metal",
    "section": "Background",
    "text": "Background\n\nThe println macro is part of the standard library std.\nWe said no_std.\nSo we can no longer print things.\nI hope it is clear how this is character-building!\nRead more:\n\nprintln macro\nstandard output"
  },
  {
    "objectID": "30_metal.rjs.html#rip-it",
    "href": "30_metal.rjs.html#rip-it",
    "title": "Bare Metal",
    "section": "Rip it",
    "text": "Rip it\n\nRemove the printing and try again:\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    // println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n}"
  },
  {
    "objectID": "30_metal.rjs.html#problems-remain",
    "href": "30_metal.rjs.html#problems-remain",
    "title": "Bare Metal",
    "section": "Problems remain",
    "text": "Problems remain\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 2 previous errors"
  },
  {
    "objectID": "30_metal.rjs.html#enhance-1",
    "href": "30_metal.rjs.html#enhance-1",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú\");\n  |     ^^^^^^^\n\nSometimes, Rust explodes and calls the OS (written in C!) for help.\nIt can‚Äôt do that without std and is sad üò≠"
  },
  {
    "objectID": "30_metal.rjs.html#panic",
    "href": "30_metal.rjs.html#panic",
    "title": "Bare Metal",
    "section": "Panic",
    "text": "Panic\n\nThe panic_handler attribute defines the function that the compiler should invoke when a panic occurs.\nstd provides its own panic handler function, but in a no_std environment we need to define it ourselves:\npanic"
  },
  {
    "objectID": "30_metal.rjs.html#our-approach",
    "href": "30_metal.rjs.html#our-approach",
    "title": "Bare Metal",
    "section": "Our Approach",
    "text": "Our Approach\n\n\nsrc/main.rs\n\n// main.rs\n\n/// This function is called on panic.\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}"
  },
  {
    "objectID": "30_metal.rjs.html#panics",
    "href": "30_metal.rjs.html#panics",
    "title": "Bare Metal",
    "section": "Panics",
    "text": "Panics\n\nThe PanicInfo parameter contains:\n\nfile and line where the panic happened\npanic message (e.g.¬†panic!(\"YOLO\")\n\nThe function should never return.\n\nSo it is marked as a ‚Äúdiverging function‚Äù\nIt returns the ‚Äúnever‚Äù type !.\n\nNot much we can do in this function for now, so just recurse to prevent a return."
  },
  {
    "objectID": "30_metal.rjs.html#read-more",
    "href": "30_metal.rjs.html#read-more",
    "title": "Bare Metal",
    "section": "Read more‚Ä¶",
    "text": "Read more‚Ä¶\n\nI had never heard of or used these but to me it was clear why they would have to exist in a type safe language.\n\nPanicInfo\ndiverging function\n‚Äúnever‚Äù type"
  },
  {
    "objectID": "30_metal.rjs.html#retry",
    "href": "30_metal.rjs.html#retry",
    "title": "Bare Metal",
    "section": "Retry",
    "text": "Retry\n\nI bet it works now!\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nThey should make a version of the OS class that is easy.\n\n(They did - this class)"
  },
  {
    "objectID": "30_metal.rjs.html#panic-abort",
    "href": "30_metal.rjs.html#panic-abort",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\n\n\nFun fact - back when I was an OS engineer slash rocket scientist my first launch was ‚ÄúPA-1‚Äù for ‚ÄúPad Abort 1‚Äù\n\nBlew up a rocket on the launch pad to make sure it was safe for humans."
  },
  {
    "objectID": "30_metal.rjs.html#panic-abort-1",
    "href": "30_metal.rjs.html#panic-abort-1",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\nThe use of the term ‚Äúabort‚Äù which in some nation-states is a hot-button political issue has come up from time-to-time in the discourse.\nRead more from 2018\n\n\n25.7.4 Aborting a Program\n\n...\n\nFuture Change Warning: Proposed Federal censorship regulations may prohibit us from giving you information about the possibility of calling this function. We would be required to say that this is not an acceptable way of terminating a program."
  },
  {
    "objectID": "30_metal.rjs.html#quoth-stallman",
    "href": "30_metal.rjs.html#quoth-stallman",
    "title": "Bare Metal",
    "section": "Quoth Stallman",
    "text": "Quoth Stallman\n\n‚ÄúThe point of this joke is even more important now than it was when I first wrote it,‚Äù [Free Software Foundation president] Stallman wrote in a note posted to project mailing list, in reference to today‚Äôs political climate. ‚ÄúPlease do not remove it. GNU is not a purely technical project, so the fact that this is not strictly and grimly technical is not a reason to remove this.‚Äù"
  },
  {
    "objectID": "30_metal.rjs.html#now-in-rust",
    "href": "30_metal.rjs.html#now-in-rust",
    "title": "Bare Metal",
    "section": "Now in Rust",
    "text": "Now in Rust\n\nWe can oppose fascism and\n\n(looks into the history of NASA and Lockheed Martin)\n(clears throat)\nMoving on!\n\n\nWe can abort programs‚Ä¶ in Rust"
  },
  {
    "objectID": "30_metal.rjs.html#how",
    "href": "30_metal.rjs.html#how",
    "title": "Bare Metal",
    "section": "How?",
    "text": "How?\n\nRead carefully:\n\n= help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n= note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nGeniuses will recognize panic=\"abort\" syntax"
  },
  {
    "objectID": "30_metal.rjs.html#toml",
    "href": "30_metal.rjs.html#toml",
    "title": "Bare Metal",
    "section": "TOML",
    "text": "TOML\n\nIt‚Äôs .toml\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]"
  },
  {
    "objectID": "30_metal.rjs.html#crate-options",
    "href": "30_metal.rjs.html#crate-options",
    "title": "Bare Metal",
    "section": "Crate options",
    "text": "Crate options\n\nNominally there are use cases for which unwinding is undesirable\n\nMy take: All cases.\n\nSo Rust provides an option to ‚Äúabort on panic‚Äù instead.\nOur reference materials claims this disables the generation of unwinding symbol information and thus considerably reduces binary size.\n\nI could not verify this independently."
  },
  {
    "objectID": "30_metal.rjs.html#update-cargo.toml",
    "href": "30_metal.rjs.html#update-cargo.toml",
    "title": "Bare Metal",
    "section": "Update Cargo.toml",
    "text": "Update Cargo.toml\n\nAdd the following:\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\""
  },
  {
    "objectID": "30_metal.rjs.html#now",
    "href": "30_metal.rjs.html#now",
    "title": "Bare Metal",
    "section": "Now‚Ä¶",
    "text": "Now‚Ä¶\n\nThis sets the panic strategy to abort for both the dev profile (used for cargo build) and the release profile (used for cargo build --release).\nabort on panic\nI bet it will work now."
  },
  {
    "objectID": "30_metal.rjs.html#whoops",
    "href": "30_metal.rjs.html#whoops",
    "title": "Bare Metal",
    "section": "Whoops!",
    "text": "Whoops!\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nWe don‚Äôt have and can‚Äôt use a main!"
  },
  {
    "objectID": "30_metal.rjs.html#to-be-continued",
    "href": "30_metal.rjs.html#to-be-continued",
    "title": "Bare Metal",
    "section": "To be continued",
    "text": "To be continued\n\nI am 99% sure we run out of time here‚Ä¶\nAnd will continue with the lab on linker errors!"
  },
  {
    "objectID": "42_hello.html",
    "href": "42_hello.html",
    "title": "Hello",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#homework",
    "href": "42_hello.html#homework",
    "title": "Hello",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#requirements",
    "href": "42_hello.html#requirements",
    "title": "Hello",
    "section": "Requirements",
    "text": "Requirements\n\n371rs/42 crate; I named mine ‚Äúosirs‚Äù\nModify src/main.rs from the boot lab.\nDo not modify other files.\nRun on emulated x86-64 in QEMU.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#printing-to-screen",
    "href": "42_hello.html#printing-to-screen",
    "title": "Hello",
    "section": "Printing to Screen",
    "text": "Printing to Screen\n\nThe easiest way to print text to the screen at this stage is the VGA text buffer.\n\nI regard VGA as an aspect ratio like SD (standard definition), 480p, 1080p, 4k, etc.\nIn practice, means ‚ÄúVideo Graphics Array‚Äù\nIBM standard for 1987 that is widely adotped.\n640 \\(\\times\\) 480.\n‚Äúlowest common denominator that virtually all post-1990 PC graphics hardware‚Äù\n\nThe text buffer is a special memory area.\n\nIt maps memory locations to screen locations.\nIt normally consists of 25 lines that each contain 80 character cells.\n\nThis is why I sometimes require line lengths less than 80 for backwards compatability.\nThis is why legacy assignment ‚Äúsnek.c‚Äù assumed a 24-by-80 screen (to allow I/O on the last line).\n\nEach character cell displays an ASCII character with some foreground and background colors.\n\nThe screen output looks like this:\n\n\n\n\nscreen output for common ASCII characters\n\n\n\nWe will discuss the exact layout of the VGA buffer next week.\n\nWe write a first small driver for it.\n\nFor printing ‚ÄúHello World!‚Äù, we just need to know:\n\nThe buffer is located at address 0xb8000, and\nEach character cell consists of an ASCII byte and a color byte.\n\n\n\n\n\n\n\n\nTipEmphasis ‚Äúa byte and a byte‚Äù\n\n\n\nYou must write two bytes per character.\n\nAn ASCII value, like 72.\n\n$ python3 -c \"print(ord('H'))\"\n72\n\nA color value, for which you can review Wordle or just use 0xF or 0xF0.\n\nObviously I used 0x0 and then nothing showed up because that was the existing background color.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#recall",
    "href": "42_hello.html#recall",
    "title": "Hello",
    "section": "Recall",
    "text": "Recall\n\nWe recall the solution to the Transmute lab.\n\n\n\nsrc/main.rs\n\nfn main() {\n    unsafe {\n        println!(\"{}\", std::mem::transmute::&lt;&[u8], &str&gt;(&std::mem::transmute::&lt;[i32; 3], [u8; 12]&gt;([1819043144, 1870078063, 560229490])));\n    }\n}\n\n\nI will urge that you use this [i32; 3] as your payload and regard other solutions as ‚Äúunsporting‚Äù.\n\nWe regard the failure of that solution to fit in 80 horizontal characters as a personal moral failing of the course instructor.\nWe will regard specification of those numerical values in hexadecimal as acceptable.\n\nHere is a bit more information about my source code.\n\n$ python3 -c \"print(ord('H'))\"\n72\n$ wc src/main.rs\n 23  88 565 src/main.rs\n$ grep ello src/main.rs\n$ grep tranmute src/main.rs\n$ grep 1819043144 src/main.rs\n        let ints: [i32; 3] = [1819043144, 1870078063, 560229490];\n\nThere is a solution on the blog (which I will not link) that I find banal and uninteresting, but to be of idiomatic Rust.\n\nIt is the ‚Äúblog‚Äù solution, which an interested student can find and consult.\n\nI found this a much better opportunity to practice working with memory.\n\nI used no Rust functions or methods.\nI exclusively used casts and arithmetic on raw pointers.\n\nI did not use transmute but do not regard its usage as unsporting.\n\nI used the same number of unsafe lines (2) as the blog.\n\nBut in typical fashion, I just enclosed the entire function body in unsafe out of pure spite.\nDo not do that in a job interview.\n\nI also turned my panic back to recursion because that sounded fun.\n\nThis required an addition line of code to quell the compiler.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#bonus",
    "href": "42_hello.html#bonus",
    "title": "Hello",
    "section": "Bonus",
    "text": "Bonus\n\nPrecompute a [u32; 6] with color data and write it in a block.\n\nFor extra fun, color letters uniquely, perhaps by lexicographical order or consonant/vowel classification.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "22_malloc.html",
    "href": "22_malloc.html",
    "title": "malloc",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#homework",
    "href": "22_malloc.html#homework",
    "title": "malloc",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#requirements",
    "href": "22_malloc.html#requirements",
    "title": "malloc",
    "section": "Requirements",
    "text": "Requirements\n\n371rs/22 crate; I named mine ‚Äúmalloc‚Äù\nYou write src/lib.rs that implements functions in the src/main.rs I provide.\nRegard it as ‚Äúunsporting‚Äù to use Vec&lt;T&gt; or any other Rust built-in data structure.\n\nUnless you are storing it (e.g.¬†as an argument to setter).\nUse arrays and raw pointers.\nIf you can‚Äôt solve it without them, use them, but‚Ä¶\n‚Ä¶at least understand why it‚Äôs hard and that there‚Äôs an alternative.\nIf you hand-implement a vector-like on top of static mut within the overhead allowance, you may use your own vectors",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#code",
    "href": "22_malloc.html#code",
    "title": "malloc",
    "section": "Code",
    "text": "Code\n\n\n\n\n\n\nNoteUpdate: Don‚Äôt Assume i32\n\n\n\nAn early submitted solution trivialized the autograder by assuming all provided values to getter and setter would be of type i32.\nThis assumption side-steps the core learning objective of working with memory objects of arbitrary size.\nEnsure your solution does not assume i32, and make some effort to test. You may want to test collection types as well (like Vec&lt;T&gt; and String).\n\n\n\n\nsrc/main.rs\n\nuse malloc::*; // crate name\n\nfn main() {\n    let p0 = malloc(16).unwrap();\n    let p1 = malloc(32).unwrap();\n    let x = 0x44332211;\n    let y = 0x12345678;\n    setter(x, p0);\n    setter(y, p1);\n    let z: i32 = getter(p0);\n    let w: i32 = getter(p1);\n    assert!(x == z);\n    assert!(y == w);\n    println!(\"A+\");\n    // Advanced topics.\n\n    // Big alloc should fail\n\n    assert!(malloc(2048).is_none());\n    println!(\"A++\");\n\n    // Allocs totaling &gt; SIZE should fail\n\n    // We have alloc (16 + 32) * 8 = 384 of 1024\n    // Try annother small malloc\n    malloc(32).unwrap();\n    // And then one too large.\n    assert!(malloc(64).is_none());\n    println!(\"A+++\");\n\n    // Easiest to test these together:\n    //  - Gets to uninitialized memory should fail\n    //  - You should write free()\n    // No graceful way to autotest these. Left as an exercise to the interested student.\n}",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#explanation",
    "href": "22_malloc.html#explanation",
    "title": "malloc",
    "section": "Explanation",
    "text": "Explanation\n\nThis is based on the C language malloc function.\n\nProbably the most important function.\nMy slides on C\n\n\n\nMalloc\n\nWe begin with calls to our own malloc:\n\n\n\nsrc/main.rs\n\n    let p0 = malloc(16).unwrap();\n    let p1 = malloc(32).unwrap();\n\n\nmalloc takes one argument, a usize, the number of bytes to allocate.\n\nIt returns a Option&lt;usize&gt;, the ‚Äúoffset‚Äù of those bytes from general reference point.\nWe can regard this as the address.\nWe can ask malloc for more memory then is available, and then we get None.\n\nHere is my malloc, with code removed.\n\n\n\nsrc/lib.rs\n\n// Return an index in BUS of s reserved bytes\npub fn malloc(s: usize) -&gt; Option&lt;usize&gt; {\n    unsafe {\n        // Ensure BUS is initialized.\n        &lt; 3 lines snipped &gt; \n\n        // Reserve a block of s bytes\n        &lt; 4 lines snipped &gt; \n\n        // Scan for a contigious region of size s\n        // In s &gt; 8, word level allocation\n        // \"Could be more efficient\" it's an exercise!\n        &lt; ~20 lines snipped&gt; \n    }\n    return None;\n}\n\n\nSome interest things here:\n\nThis relies on a new Rust ‚Äúthing‚Äù, a static mut.\n\nThey may hold the record for being the most unsafe.\nThink of it maybe as a Python global.\nI named mine BUS.\n\nThis relies on a helper function to initialize BUS\n\nI am requiring the following implementation for your BUS:\nFor me, declared at the beginning of lib\n\n\n\n\n\nStatic mut\n\n\nsrc/lib.rs\n\n// Treat ourselves to a kb (1024 bits)\n// 1024 &gt;&gt; 3 == 128 == 0x80\npub const SIZE: usize = 0x80;\n\n// Not really a BUS but we gotta call it something.\nstatic mut BUS: [u8; SIZE] = [0u8; SIZE];\n\n\nThe requirements are:\n\nA static mut of a fixed size u8 array.\nMust support any size which is a power of 2.\nMay not use any other static mut\n\nAn astute observer will note that then any tracking information related to BUS must be stored within BUS itself\nThis is non-trivial\n\n\nI am not aware of high quality reference materials on static mut, here is an example use apparently.\n\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_counter(inc: u32) {\n    // SAFETY: There are no other threads which could be accessing `COUNTER`.\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_counter(42);\n\n    // SAFETY: There are no other threads which could be accessing `COUNTER`.\n    unsafe {\n        dbg!(COUNTER);\n    }\n}\n\nThis fixed-size array of bits is meant to be consistent with underlying hardware, at least theoretically.\n\n\n\nInitialization\n\nYou are not required to use a helper for this, but I did.\nI am permitting/encouraging an assert! that enforced power-of-two sizing.\nNaively using BUS didn‚Äôt work well for me.\n\nI had to check to make sure I wasn‚Äôt giving away bits already in use.\nSo I had to persist some state\n\nI had to use memory to provide memory.\n\nI just reserved some bits at the beginning of the array as a validity bitmask\n\nIf a bit is set to 1, the corresponding byte is in use.\nSo a 1-in-8 overhead cost.\nThis is why 64 bit words are popular.\nYou are permitted have overhead costs as high as 1-in-4 if you need them.\n\nHowever, I had to mark within that bitmask that the bitmask was already using memory.\nThis formed my init.\n\n\n\n\nsrc/lib.rs\n\n// Zero the array except the mask.\nfn init() {\n    unsafe {\n        // Initialize mask\n        // The following explodes if SIZE isn't a power of 2\n        assert!(SIZE & (SIZE - 1) == 0);\n        // First SIZE &gt;&gt; 3 bits are reserved as a validty byte/bit mask\n        &lt; snip &gt;\n        // Which has to reserve enough bytes for itself.\n        &lt; snip &gt;\n        // Set to 1\n        &lt; snip &gt;\n\n        // Initialize memory\n        // Set to zero.\n        &lt; snip &gt;\n    }\n    return;\n}\n\n\n\nSetter\n\nAfter the calls to malloc within main, we use a wrapping function setter to set memory at the location reserved by the malloc to have certain values.\n\n\n\nsrc/main.rs\n\n    let x = 0x44332211;\n    let y = 0x12345678;\n    setter(x, p0);\n    setter(y, p1);\n\n\nThis maybe isn‚Äôt the most typical way to access memory.\n\nA more common metaphor is lw and sw more\nI found this metaphor more interesting.\n\nWords are fixed size, and felt quite trivial.\n\n\nGiven some value returned by malloc, store up to that many bytes of information within the BUS.\n\nmalloc and setter together are responsible for ensuring the correctness and consistency of these bytes.\nIn this case, I malloc much more than I needed (16 and 32 bytes, respectively, for 4 byte words).\n\nThis is allowed, but wasteful.\nIt also makes testing easier.\n\n\nWe note that setter does not ask have an argument for the size of memory being set.\n\nIt is your responsibility to infer this size using the type of the arguments.\nThis is to learn Rust, not to learn about memory, so a secondary objective but one I found worthwhile.\n\n\n\n\nsrc/lib.rs\n\n// Place val at loc\n// No safety checks so good luck out there.\npub fn setter&lt;T&gt;(val: T, loc: usize) {\n    unsafe {\n        &lt; 4 lines &gt;\n    }\n    return;\n}\n\n\nThe instructional staff is diligently working to infer the most graceful way to handle this operation, and many current solutions potentially introduce undefined behavior.\nI summarize my approach as follows:\n\nI cast a reference to the value as a raw pointer.\nI cast that raw pointer to usize.\nI use a for loop to performing an assignment operation.\n\nI use size_of_val to determine how many times to loop.\nI assign a location in the BUS to be equal to something.\n\nThat something is the relevant byte, which I reach through a combination of casts and arithmetic.\n\n\n\n\n\n\nGetter\n\nAfter the calls to ‚Äúset‚Äù values, there are calls to retrieve the values (for latter inspection).\n\n\n\nsrc/main.rs\n\n// Should check the validity bitmask here...\npub fn getter&lt;T&gt;(loc: usize) -&gt; T {\n    unsafe {\n        &lt; 5 lines &gt;\n    }\n}\n\n\nMy code was quite similar to setting, but with the updates in the opposite direction.",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "11_unsafe.html",
    "href": "11_unsafe.html",
    "title": "Unsafe",
    "section": "",
    "text": "Welcome to OS in Rust\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept.¬†at 1440 PT.\nJust a quick demo for HW this week, check it out whenever.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#announcements",
    "href": "11_unsafe.html#announcements",
    "title": "Unsafe",
    "section": "",
    "text": "Welcome to OS in Rust\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept.¬†at 1440 PT.\nJust a quick demo for HW this week, check it out whenever.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#today",
    "href": "11_unsafe.html#today",
    "title": "Unsafe",
    "section": "Today",
    "text": "Today\n\nUnsafe\nUB\nDereferencing",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#the-dark-arts-of-unsafe-rust",
    "href": "11_unsafe.html#the-dark-arts-of-unsafe-rust",
    "title": "Unsafe",
    "section": "The Dark Arts of Unsafe Rust",
    "text": "The Dark Arts of Unsafe Rust\n\nTHE KNOWLEDGE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF UNLEASHING INDESCRIBABLE HORRORS THAT SHATTER YOUR PSYCHE AND SET YOUR MIND ADRIFT IN THE UNKNOWABLY INFINITE COSMOS.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#motivation",
    "href": "11_unsafe.html#motivation",
    "title": "Unsafe",
    "section": "Motivation",
    "text": "Motivation\n\nOften we don‚Äôt worry about low-level implementation details.\n\nHow many bits is an integer in Python?\nHow many bits is this array in Rust?\n\n\nlet mut array: [i32; 3] = [0; 3];\n\nWho could possibly care how much space the empty tuple occupies?",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#sometimes-it-matters",
    "href": "11_unsafe.html#sometimes-it-matters",
    "title": "Unsafe",
    "section": "Sometimes it matters‚Ä¶",
    "text": "Sometimes it matters‚Ä¶\n\nThe most common reason is performance, but\nMore importantly, these details can become a matter of correctness when interfacing directly with\n\nhardware,\noperating systems, or\nother languages (by which we mean C)",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#legacy",
    "href": "11_unsafe.html#legacy",
    "title": "Unsafe",
    "section": "Legacy",
    "text": "Legacy\nWhen implementation details start to matter in a safe programming language, programmers usually have three options:\n\nfiddle with the code to ‚Äúencourage‚Äù the compiler/runtime to perform an optimization\nadopt a more unidiomatic or cumbersome design to get the desired implementation\nrewrite the implementation in a language that lets you deal with those details",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#rust-on-c",
    "href": "11_unsafe.html#rust-on-c",
    "title": "Unsafe",
    "section": "Rust on C",
    "text": "Rust on C\n\nUnfortunately, C is incredibly unsafe to use (sometimes for good reason), and this unsafety is magnified when trying to interoperate with another language. Care must be taken to ensure C and the other language agree on what‚Äôs happening, and that they don‚Äôt step on each other‚Äôs toes.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#both-and",
    "href": "11_unsafe.html#both-and",
    "title": "Unsafe",
    "section": "Both, and",
    "text": "Both, and\n\nSo what does this have to do with Rust?\n\nWell, unlike C, Rust is a safe programming language.\nBut, like C, Rust is an unsafe programming language.\n\nMore accurately, Rust contains both a safe and unsafe programming language.\n\n\nRust can be thought of as a combination of two programming languages: Safe Rust and Unsafe Rust.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-rust",
    "href": "11_unsafe.html#safe-rust",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nThe default case\nWhat we‚Äôve used to far, at least officially\n\nYou may have incidentally dabbled in unsafe.\nGood for you.\n\nSafe Rust only really makes one guarantee.\n\n\nRust‚Äôs memory safety guarantees enforced at compile time\n\n\nThat is, you can never try to read something that doesn‚Äôt exist.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#unsafe-rust",
    "href": "11_unsafe.html#unsafe-rust",
    "title": "Unsafe",
    "section": "Unsafe Rust",
    "text": "Unsafe Rust\n\nSometimes, you may want to have two reference to an object that are both mutable.\n\nFor example, if you are implementing a suffix tree, a task I didn‚Äôt assign last term because it was miserable in safe Rust.\n\nSometimes, you want to do so in a way that can‚Äôt possibly break anything.\n\nFor example, you may only be using provably correct algorithms (whatever that means).\nBut of course, rustc isn‚Äôt a theorem prover‚Ä¶",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#warning",
    "href": "11_unsafe.html#warning",
    "title": "Unsafe",
    "section": "Warning",
    "text": "Warning\n\nUnsafe Rust is, well, not (safe). In fact, Unsafe Rust lets us do some really unsafe things. Things the Rust authors will implore you not to do, but we‚Äôll do anyway.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#true-rust",
    "href": "11_unsafe.html#true-rust",
    "title": "Unsafe",
    "section": "True Rust",
    "text": "True Rust\n\nSafe Rust is the true Rust programming language.\nIf all you do is write Safe Rust, you will never have to worry about type-safety or memory-safety.\nYou will never endure\n\na dangling pointer,\na use-after-free, or\nany other kind of Undefined Behavior (a.k.a. UB).",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#std",
    "href": "11_unsafe.html#std",
    "title": "Unsafe",
    "section": "std",
    "text": "std\n\nThe standard library also gives you enough utilities out of the box that you‚Äôll be able to write high-performance applications and libraries in pure idiomatic Safe Rust.\nAssuming, of course, you are working on a system where std is already implemented.\nNot, you know, writing your own OS or own std.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#twinsies",
    "href": "11_unsafe.html#twinsies",
    "title": "Unsafe",
    "section": "Twinsies",
    "text": "Twinsies\n\nUnsafe Rust is exactly like Safe Rust with all the same rules and semantics.\nIt just lets you do some extra things that are Definitely Not Safe.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#payoffs",
    "href": "11_unsafe.html#payoffs",
    "title": "Unsafe",
    "section": "Payoffs",
    "text": "Payoffs\n\nThe value of this separation is that we gain the benefits of using an unsafe language like C\n\nlow level control over implementation details\n\n‚Ä¶without most (citation needed) of the problems that come with trying to integrate it with a completely different safe language.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-rust-1",
    "href": "11_unsafe.html#safe-rust-1",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nSafe Rust guarantees certain things about your code.\n\nMost of these won‚Äôt even make sense to you unless you write C",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-prevents",
    "href": "11_unsafe.html#safe-prevents",
    "title": "Unsafe",
    "section": "Safe Prevents",
    "text": "Safe Prevents\n\nDereferencing (using the * operator on) dangling or unaligned pointers (see below)\nBreaking the ‚Äúpointer aliasing rules‚Äù using & (borrow) and mut\nCalling a function with the wrong call types\nCausing a data race when multithreading\nExecuting code compiled for hardware other than currently hosting the process not support\nProducing invalid values like something other than 0 or 1 for a boolean.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-allows",
    "href": "11_unsafe.html#safe-allows",
    "title": "Unsafe",
    "section": "Safe Allows",
    "text": "Safe Allows\n\nDeadlocks when multithreading\nLeaks of memory and other resources\nExiting without calling destructors\nExposing randomized base addresses through pointer leaks\nInteger overflow (recall SHA wrapping)\nLogic errors\n\nlet val = 7;\nlet val_is_even = if val % 2 == 1 { true } else { false };",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#unsafe-allows",
    "href": "11_unsafe.html#unsafe-allows",
    "title": "Unsafe",
    "section": "Unsafe allows:",
    "text": "Unsafe allows:\n\nDereference a raw pointer.\nCall an unsafe function or method.\nAccess or modify a mutable static variable.\nImplement an unsafe trait.\nAccess fields of unions.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#simply",
    "href": "11_unsafe.html#simply",
    "title": "Unsafe",
    "section": "Simply‚Ä¶",
    "text": "Simply‚Ä¶\n\nWrite Rust code normally.\nIf you are doing something unsafe, include it in an unsafe block.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#unions",
    "href": "11_unsafe.html#unions",
    "title": "Unsafe",
    "section": "Unions",
    "text": "Unions\nunion MyUnion {\n    f: f32,\n    u: u32,\n}\n\nfn main() {\n    let mut u = MyUnion { f: 0.0 };\n\n    unsafe {\n        println!(\"Bits as float: {}\", u.f);\n        println!(\"Bits as integer: {:#x}\", u.u);\n    }\n\n    u.u = 0x3F800000; // This is the bit pattern for 1.0 in IEEE 754\n\n    unsafe {\n        println!(\"After manual bit update, float is: {}\", u.f);\n    }\n}",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#dangling",
    "href": "11_unsafe.html#dangling",
    "title": "Unsafe",
    "section": "Dangling",
    "text": "Dangling\n\nThis worked fine for me, but technically isn‚Äôt supported.\n\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#the-reference",
    "href": "11_unsafe.html#the-reference",
    "title": "Unsafe",
    "section": "The Reference",
    "text": "The Reference\n\nThe reference is much more‚Ä¶ verbose.\nIt‚Äôs here\n\n\nBreaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n\n\nViolating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#previously-in-rust",
    "href": "11_unsafe.html#previously-in-rust",
    "title": "Unsafe",
    "section": "Previously in Rust",
    "text": "Previously in Rust\n\nSafe Rust ensures that references are always valid\n\nThat is, borrows via &\nThese always have some plausible correct value in them (if the code compiles)",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#the-frontier",
    "href": "11_unsafe.html#the-frontier",
    "title": "Unsafe",
    "section": "The Frontier",
    "text": "The Frontier\n\nAt the edge of Safe and Unsafe Rust are raw pointers.\n\nCan be immutable *const T or mutable *mut T.\nVs. C, the asterisk is part of the name and not an operator.\n\nThis is annoying.\n\n\nRaw pointers are inherently unsafe, so they can be created in safe Rust.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#differences",
    "href": "11_unsafe.html#differences",
    "title": "Unsafe",
    "section": "Differences",
    "text": "Differences\n\nThese raw pointers:\n\nAre allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location\nAren‚Äôt guaranteed to point to valid memory\nAre allowed to be null\nDon‚Äôt implement any automatic cleanup",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#example",
    "href": "11_unsafe.html#example",
    "title": "Unsafe",
    "section": "Example",
    "text": "Example\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#this-is-safe",
    "href": "11_unsafe.html#this-is-safe",
    "title": "Unsafe",
    "section": "This is safe!",
    "text": "This is safe!\n\nThere is nothing unsafe and creating a variable that refers to some value.\nAfter all, what‚Äôs the worst thing that can happen?\nThese lines of code only facilitate novel possible ways of interfacing with the underlying data.\nIn this case, we know these pointers are valid and point to 5.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#casts",
    "href": "11_unsafe.html#casts",
    "title": "Unsafe",
    "section": "Casts",
    "text": "Casts\n\nWe can get a potentially invalid reference using ‚Äúcasts‚Äù with the as keyword.\n\nWe take a numeric value and treat it as a reference.\nThis numerical value represents a location in numerical organized computer memory.\n\n\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\nThis is still safe so far!",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#dereference",
    "href": "11_unsafe.html#dereference",
    "title": "Unsafe",
    "section": "Dereference",
    "text": "Dereference\n\nWe now can use the dereference asterisk * operator.\nThis is decidedly unsafe.\n\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n\nUnsafe to Rust but we know it will work.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#runtime-crash",
    "href": "11_unsafe.html#runtime-crash",
    "title": "Unsafe",
    "section": "Runtime Crash",
    "text": "Runtime Crash\n\nThis is both unsafe and (almost certainly) won‚Äôt work.\n\n\n\nsrc/main.rs\n\nfn main() {\n    let address = 0x0usize;\n    let r = address as *const i32;\n    unsafe {\n        dbg!(*r);\n    }\n}\n\n\nFun exercise: try to take the deferences out of the unsafe block.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#announcements-1",
    "href": "11_unsafe.html#announcements-1",
    "title": "Unsafe",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept.¬†at 1440 PT.\nJust a quick demo for HW this week, check it out whenever.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.rjs.html#announcements",
    "href": "11_unsafe.rjs.html#announcements",
    "title": "Unsafe",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to OS in Rust\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept.¬†at 1440 PT.\nJust a quick demo for HW this week, check it out whenever."
  },
  {
    "objectID": "11_unsafe.rjs.html#today",
    "href": "11_unsafe.rjs.html#today",
    "title": "Unsafe",
    "section": "Today",
    "text": "Today\n\nUnsafe\nUB\nDereferencing"
  },
  {
    "objectID": "11_unsafe.rjs.html#the-dark-arts-of-unsafe-rust",
    "href": "11_unsafe.rjs.html#the-dark-arts-of-unsafe-rust",
    "title": "Unsafe",
    "section": "The Dark Arts of Unsafe Rust",
    "text": "The Dark Arts of Unsafe Rust\n\nTHE KNOWLEDGE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF UNLEASHING INDESCRIBABLE HORRORS THAT SHATTER YOUR PSYCHE AND SET YOUR MIND ADRIFT IN THE UNKNOWABLY INFINITE COSMOS."
  },
  {
    "objectID": "11_unsafe.rjs.html#motivation",
    "href": "11_unsafe.rjs.html#motivation",
    "title": "Unsafe",
    "section": "Motivation",
    "text": "Motivation\n\nOften we don‚Äôt worry about low-level implementation details.\n\nHow many bits is an integer in Python?\nHow many bits is this array in Rust?\n\n\nlet mut array: [i32; 3] = [0; 3];\n\nWho could possibly care how much space the empty tuple occupies?"
  },
  {
    "objectID": "11_unsafe.rjs.html#sometimes-it-matters",
    "href": "11_unsafe.rjs.html#sometimes-it-matters",
    "title": "Unsafe",
    "section": "Sometimes it matters‚Ä¶",
    "text": "Sometimes it matters‚Ä¶\n\nThe most common reason is performance, but\nMore importantly, these details can become a matter of correctness when interfacing directly with\n\nhardware,\noperating systems, or\nother languages (by which we mean C)"
  },
  {
    "objectID": "11_unsafe.rjs.html#legacy",
    "href": "11_unsafe.rjs.html#legacy",
    "title": "Unsafe",
    "section": "Legacy",
    "text": "Legacy\nWhen implementation details start to matter in a safe programming language, programmers usually have three options:\n\nfiddle with the code to ‚Äúencourage‚Äù the compiler/runtime to perform an optimization\nadopt a more unidiomatic or cumbersome design to get the desired implementation\nrewrite the implementation in a language that lets you deal with those details"
  },
  {
    "objectID": "11_unsafe.rjs.html#rust-on-c",
    "href": "11_unsafe.rjs.html#rust-on-c",
    "title": "Unsafe",
    "section": "Rust on C",
    "text": "Rust on C\n\nUnfortunately, C is incredibly unsafe to use (sometimes for good reason), and this unsafety is magnified when trying to interoperate with another language. Care must be taken to ensure C and the other language agree on what‚Äôs happening, and that they don‚Äôt step on each other‚Äôs toes."
  },
  {
    "objectID": "11_unsafe.rjs.html#both-and",
    "href": "11_unsafe.rjs.html#both-and",
    "title": "Unsafe",
    "section": "Both, and",
    "text": "Both, and\n\nSo what does this have to do with Rust?\n\nWell, unlike C, Rust is a safe programming language.\nBut, like C, Rust is an unsafe programming language.\n\nMore accurately, Rust contains both a safe and unsafe programming language.\n\n\nRust can be thought of as a combination of two programming languages: Safe Rust and Unsafe Rust."
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-rust",
    "href": "11_unsafe.rjs.html#safe-rust",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nThe default case\nWhat we‚Äôve used to far, at least officially\n\nYou may have incidentally dabbled in unsafe.\nGood for you.\n\nSafe Rust only really makes one guarantee.\n\n\nRust‚Äôs memory safety guarantees enforced at compile time\n\n\nThat is, you can never try to read something that doesn‚Äôt exist."
  },
  {
    "objectID": "11_unsafe.rjs.html#unsafe-rust",
    "href": "11_unsafe.rjs.html#unsafe-rust",
    "title": "Unsafe",
    "section": "Unsafe Rust",
    "text": "Unsafe Rust\n\nSometimes, you may want to have two reference to an object that are both mutable.\n\nFor example, if you are implementing a suffix tree, a task I didn‚Äôt assign last term because it was miserable in safe Rust.\n\nSometimes, you want to do so in a way that can‚Äôt possibly break anything.\n\nFor example, you may only be using provably correct algorithms (whatever that means).\nBut of course, rustc isn‚Äôt a theorem prover‚Ä¶"
  },
  {
    "objectID": "11_unsafe.rjs.html#warning",
    "href": "11_unsafe.rjs.html#warning",
    "title": "Unsafe",
    "section": "Warning",
    "text": "Warning\n\nUnsafe Rust is, well, not (safe). In fact, Unsafe Rust lets us do some really unsafe things. Things the Rust authors will implore you not to do, but we‚Äôll do anyway."
  },
  {
    "objectID": "11_unsafe.rjs.html#true-rust",
    "href": "11_unsafe.rjs.html#true-rust",
    "title": "Unsafe",
    "section": "True Rust",
    "text": "True Rust\n\nSafe Rust is the true Rust programming language.\nIf all you do is write Safe Rust, you will never have to worry about type-safety or memory-safety.\nYou will never endure\n\na dangling pointer,\na use-after-free, or\nany other kind of Undefined Behavior (a.k.a. UB)."
  },
  {
    "objectID": "11_unsafe.rjs.html#std",
    "href": "11_unsafe.rjs.html#std",
    "title": "Unsafe",
    "section": "std",
    "text": "std\n\nThe standard library also gives you enough utilities out of the box that you‚Äôll be able to write high-performance applications and libraries in pure idiomatic Safe Rust.\nAssuming, of course, you are working on a system where std is already implemented.\nNot, you know, writing your own OS or own std."
  },
  {
    "objectID": "11_unsafe.rjs.html#twinsies",
    "href": "11_unsafe.rjs.html#twinsies",
    "title": "Unsafe",
    "section": "Twinsies",
    "text": "Twinsies\n\nUnsafe Rust is exactly like Safe Rust with all the same rules and semantics.\nIt just lets you do some extra things that are Definitely Not Safe."
  },
  {
    "objectID": "11_unsafe.rjs.html#payoffs",
    "href": "11_unsafe.rjs.html#payoffs",
    "title": "Unsafe",
    "section": "Payoffs",
    "text": "Payoffs\n\nThe value of this separation is that we gain the benefits of using an unsafe language like C\n\nlow level control over implementation details\n\n‚Ä¶without most (citation needed) of the problems that come with trying to integrate it with a completely different safe language."
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-rust-1",
    "href": "11_unsafe.rjs.html#safe-rust-1",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nSafe Rust guarantees certain things about your code.\n\nMost of these won‚Äôt even make sense to you unless you write C"
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-prevents",
    "href": "11_unsafe.rjs.html#safe-prevents",
    "title": "Unsafe",
    "section": "Safe Prevents",
    "text": "Safe Prevents\n\nDereferencing (using the * operator on) dangling or unaligned pointers (see below)\nBreaking the ‚Äúpointer aliasing rules‚Äù using & (borrow) and mut\nCalling a function with the wrong call types\nCausing a data race when multithreading\nExecuting code compiled for hardware other than currently hosting the process not support\nProducing invalid values like something other than 0 or 1 for a boolean."
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-allows",
    "href": "11_unsafe.rjs.html#safe-allows",
    "title": "Unsafe",
    "section": "Safe Allows",
    "text": "Safe Allows\n\nDeadlocks when multithreading\nLeaks of memory and other resources\nExiting without calling destructors\nExposing randomized base addresses through pointer leaks\nInteger overflow (recall SHA wrapping)\nLogic errors\n\nlet val = 7;\nlet val_is_even = if val % 2 == 1 { true } else { false };"
  },
  {
    "objectID": "11_unsafe.rjs.html#unsafe-allows",
    "href": "11_unsafe.rjs.html#unsafe-allows",
    "title": "Unsafe",
    "section": "Unsafe allows:",
    "text": "Unsafe allows:\n\nDereference a raw pointer.\nCall an unsafe function or method.\nAccess or modify a mutable static variable.\nImplement an unsafe trait.\nAccess fields of unions."
  },
  {
    "objectID": "11_unsafe.rjs.html#simply",
    "href": "11_unsafe.rjs.html#simply",
    "title": "Unsafe",
    "section": "Simply‚Ä¶",
    "text": "Simply‚Ä¶\n\nWrite Rust code normally.\nIf you are doing something unsafe, include it in an unsafe block."
  },
  {
    "objectID": "11_unsafe.rjs.html#unions",
    "href": "11_unsafe.rjs.html#unions",
    "title": "Unsafe",
    "section": "Unions",
    "text": "Unions\nunion MyUnion {\n    f: f32,\n    u: u32,\n}\n\nfn main() {\n    let mut u = MyUnion { f: 0.0 };\n\n    unsafe {\n        println!(\"Bits as float: {}\", u.f);\n        println!(\"Bits as integer: {:#x}\", u.u);\n    }\n\n    u.u = 0x3F800000; // This is the bit pattern for 1.0 in IEEE 754\n\n    unsafe {\n        println!(\"After manual bit update, float is: {}\", u.f);\n    }\n}"
  },
  {
    "objectID": "11_unsafe.rjs.html#dangling",
    "href": "11_unsafe.rjs.html#dangling",
    "title": "Unsafe",
    "section": "Dangling",
    "text": "Dangling\n\nThis worked fine for me, but technically isn‚Äôt supported.\n\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}"
  },
  {
    "objectID": "11_unsafe.rjs.html#the-reference",
    "href": "11_unsafe.rjs.html#the-reference",
    "title": "Unsafe",
    "section": "The Reference",
    "text": "The Reference\n\nThe reference is much more‚Ä¶ verbose.\nIt‚Äôs here\n\n\nBreaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n\n\nViolating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented."
  },
  {
    "objectID": "11_unsafe.rjs.html#previously-in-rust",
    "href": "11_unsafe.rjs.html#previously-in-rust",
    "title": "Unsafe",
    "section": "Previously in Rust",
    "text": "Previously in Rust\n\nSafe Rust ensures that references are always valid\n\nThat is, borrows via &\nThese always have some plausible correct value in them (if the code compiles)"
  },
  {
    "objectID": "11_unsafe.rjs.html#the-frontier",
    "href": "11_unsafe.rjs.html#the-frontier",
    "title": "Unsafe",
    "section": "The Frontier",
    "text": "The Frontier\n\nAt the edge of Safe and Unsafe Rust are raw pointers.\n\nCan be immutable *const T or mutable *mut T.\nVs. C, the asterisk is part of the name and not an operator.\n\nThis is annoying.\n\n\nRaw pointers are inherently unsafe, so they can be created in safe Rust."
  },
  {
    "objectID": "11_unsafe.rjs.html#differences",
    "href": "11_unsafe.rjs.html#differences",
    "title": "Unsafe",
    "section": "Differences",
    "text": "Differences\n\nThese raw pointers:\n\nAre allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location\nAren‚Äôt guaranteed to point to valid memory\nAre allowed to be null\nDon‚Äôt implement any automatic cleanup"
  },
  {
    "objectID": "11_unsafe.rjs.html#example",
    "href": "11_unsafe.rjs.html#example",
    "title": "Unsafe",
    "section": "Example",
    "text": "Example\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;"
  },
  {
    "objectID": "11_unsafe.rjs.html#this-is-safe",
    "href": "11_unsafe.rjs.html#this-is-safe",
    "title": "Unsafe",
    "section": "This is safe!",
    "text": "This is safe!\n\nThere is nothing unsafe and creating a variable that refers to some value.\nAfter all, what‚Äôs the worst thing that can happen?\nThese lines of code only facilitate novel possible ways of interfacing with the underlying data.\nIn this case, we know these pointers are valid and point to 5."
  },
  {
    "objectID": "11_unsafe.rjs.html#casts",
    "href": "11_unsafe.rjs.html#casts",
    "title": "Unsafe",
    "section": "Casts",
    "text": "Casts\n\nWe can get a potentially invalid reference using ‚Äúcasts‚Äù with the as keyword.\n\nWe take a numeric value and treat it as a reference.\nThis numerical value represents a location in numerical organized computer memory.\n\n\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\nThis is still safe so far!"
  },
  {
    "objectID": "11_unsafe.rjs.html#dereference",
    "href": "11_unsafe.rjs.html#dereference",
    "title": "Unsafe",
    "section": "Dereference",
    "text": "Dereference\n\nWe now can use the dereference asterisk * operator.\nThis is decidedly unsafe.\n\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n\nUnsafe to Rust but we know it will work."
  },
  {
    "objectID": "11_unsafe.rjs.html#runtime-crash",
    "href": "11_unsafe.rjs.html#runtime-crash",
    "title": "Unsafe",
    "section": "Runtime Crash",
    "text": "Runtime Crash\n\nThis is both unsafe and (almost certainly) won‚Äôt work.\n\n\n\nsrc/main.rs\n\nfn main() {\n    let address = 0x0usize;\n    let r = address as *const i32;\n    unsafe {\n        dbg!(*r);\n    }\n}\n\n\nFun exercise: try to take the deferences out of the unsafe block."
  },
  {
    "objectID": "11_unsafe.rjs.html#announcements-1",
    "href": "11_unsafe.rjs.html#announcements-1",
    "title": "Unsafe",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept.¬†at 1440 PT.\nJust a quick demo for HW this week, check it out whenever."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OS in Rust",
    "section": "",
    "text": "CS 371 ‚ÄúOS in Rust‚Äù\n\nCalled:\n\nCS 371: Advanced Systems Computing, Adv. Operating Systems\n\nThe second semester class in a:\n\nCompiled language, with\nNo garbage collector.\n\nIn the second semester, one of the \\(n\\) great systems\n\nOperating System (OS)\nCompiler\nWeb Server\n\nTaught this year on OS and in Rust.\n\nSo to me, ‚ÄúOS in Rust‚Äù\n\n\n\nMW 1310-1440\n\n\nProf.¬†Calvin\n\n\nSyllabus\n\nSyllabus link\n\n\n\n\nCalendar\n\n\n\nWeek\nDate (M)\nLecture (M)\nLab (W)\nHW (F)\n\n\n\n\n0x0\n01/12\nDerust\nwc\nCLI\n\n\n0x1\n01/19\nNone\nUnsafe\nSplits\n\n\n0x2\n01/26\nOSes\nTransmute\nmalloc\n\n\n0x3\n02/02\nBare Metal\nLinker\nRISC-V\n\n\n0x4\n02/09\nKernel\nBoot\nHello\n\n\n0x5\n02/16\nText\nFormat\nGraphics\n\n\n0x6\n02/23\nTest\nSerial\nIntegration\n\n\n0x7\n03/02\nExceptions\n\n\n\n\n0x8\n03/09\nFaults\n\n\n\n\n0x9\n03/16\nInterrupts\n\n\n\n\n0bX\n03/23\nNone\nNone\nNone\n\n\n0xA\n03/30\nPaging\n\n\n\n\n0xB\n03/06\nPage Tables\n\n\n\n\n0xC\n04/13\nThe Heap\nNone\n\n\n\n0xD\n04/20\nAllocators\n\n\n\n\n0xE\n04/29\nasync\n\nNone\n\n\n\n\nFinal OS due Tuesday, May 5th, from 2:00 pm - 5:00 pm (5 PM ET on 5/5)\n\n\nLecture Recordings"
  },
  {
    "objectID": "40_kernel.html",
    "href": "40_kernel.html",
    "title": "Kernel",
    "section": "",
    "text": "Action Items:\n\nIs qemu working at all.\n\nThe coolest assignment ever for a second week in a row.\nI‚Äôm glad you all love it",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#announcements",
    "href": "40_kernel.html#announcements",
    "title": "Kernel",
    "section": "",
    "text": "Action Items:\n\nIs qemu working at all.\n\nThe coolest assignment ever for a second week in a row.\nI‚Äôm glad you all love it",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#today",
    "href": "40_kernel.html#today",
    "title": "Kernel",
    "section": "Today",
    "text": "Today\n\nBackground\nKernel",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#citations",
    "href": "40_kernel.html#citations",
    "title": "Kernel",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nA Minimal Rust Kernel",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-boot-process",
    "href": "40_kernel.html#the-boot-process",
    "title": "Kernel",
    "section": "The Boot Process",
    "text": "The Boot Process\n\nPOV: You are an inanimate piece of silicon.\n\nYou contain wires connected to logic gates.\nSomewhere, a switch is flipped.\nElectrons flow into some of your wires, through some gates.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#first-steps",
    "href": "40_kernel.html#first-steps",
    "title": "Kernel",
    "section": "First Steps",
    "text": "First Steps\n\nWhat determines the initial arrangement of gates?\nWhere do electrons flow?\nThis is determined by the boot process\n\nOccurs on every power-up\nDetermined by hardware design\nMore fundamental than the OS",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#firmware",
    "href": "40_kernel.html#firmware",
    "title": "Kernel",
    "section": "Firmware",
    "text": "Firmware\n\nWhat is between hardware and software?\n\nFirmware.\n\nOn power-up, devices execute code embedded in physical read only memory (ROM).\n\nRead more: ROM\n\nIs it software? Is it hardware? Who can say.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#enter-the-cpu",
    "href": "40_kernel.html#enter-the-cpu",
    "title": "Kernel",
    "section": "Enter the CPU",
    "text": "Enter the CPU\n\nUsually, power-up occurs on a ‚Äúmotherboard‚Äù hosting, among other things, the bus.\n\nNamed ‚Äúmother‚Äù after the ‚ÄúMU/TH/UR‚Äù on ship computer in Alien (1979)\nThis is a lie.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#not-code-but-ware",
    "href": "40_kernel.html#not-code-but-ware",
    "title": "Kernel",
    "section": "Not ‚Äúcode‚Äù but ‚Äúware‚Äù",
    "text": "Not ‚Äúcode‚Äù but ‚Äúware‚Äù\n\nSo firmware isn‚Äôt really like CPU code (like Rust or C), but it does:\n\nTell circuitry where to direct electrons within the CPU.\nAlso wake up e.g.¬†the MMU.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#enter-the-os",
    "href": "40_kernel.html#enter-the-os",
    "title": "Kernel",
    "section": "Enter the OS",
    "text": "Enter the OS\n\nWith the CPU primed but not yet ticking through clock cycles, all that remains is to either\n\nExecute a bare metal executable, or\nBoot an operating system to enable the next higher-level task.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#what-it-sounds-like",
    "href": "40_kernel.html#what-it-sounds-like",
    "title": "Kernel",
    "section": "What it sounds like",
    "text": "What it sounds like\n\nWe regard, then, the operating system as a system which operates the hardware on behalf of higher level software.\n\nHence, ‚Äúsystems computing‚Äù.\nHopefully the contrast to software is a bit more clear here.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside",
    "href": "40_kernel.html#aside",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nI am supposed to teach you about the ‚Äúpower-on self-test‚Äù.\nA bit electrical engineering for me.\n\n\nA power-on self-test (POST) is a process performed by firmware or software routines immediately after a computer or other digital electronic device is powered on.\n\n\nNeat! Moving on.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#competing-standards",
    "href": "40_kernel.html#competing-standards",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nLucky us, there is no widely agreed upon way to do firmware.\nThere‚Äôs the cool, old way that doesn‚Äôt work well but is easy.\n\n‚ÄúBasic Input/Output System‚Äú BIOS\n1981",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#competing-standards-1",
    "href": "40_kernel.html#competing-standards-1",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nThere‚Äôs the new way that is too hard to use for normal people like us.\n\nAs in people who do anything else ever.\nIt‚Äôs good though we promise.\n‚ÄúUnified Extensible Firmware Interface‚Äù UEFI.\nMay make you use it for a lab. More.\n2006",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#bios-boot",
    "href": "40_kernel.html#bios-boot",
    "title": "Kernel",
    "section": "BIOS Boot",
    "text": "BIOS Boot\n\nI actually started fooling around with the BIOS before UEFI even existed.\n\nI was a normal kid though 100%.\n\nFortunately it‚Äôs still basically around. Quoth Blog:\n\n\nThis is great, because you can use the same boot logic across all machines from the last century.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#upsides",
    "href": "40_kernel.html#upsides",
    "title": "Kernel",
    "section": "Upsides",
    "text": "Upsides\n\nBlog says it‚Äôs a downside that this means you have to do 16-bit mode.\n\nI say: that‚Äôs cool.\nI can‚Äôt count higher than about 0xFFFF anyways.\n\nThe blog impolitely calls 1980s bootloaders ‚Äúarchaic‚Äù instead of ‚Äúvintage‚Äù, ‚Äúretro‚Äù, or ‚Äúfoundational‚Äù.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#bootable-disks",
    "href": "40_kernel.html#bootable-disks",
    "title": "Kernel",
    "section": "Bootable Disks",
    "text": "Bootable Disks\n\nI should also tell you about bootable disks\nNowadays we all boot from SSD or rarely HDD.\nBut you have probably at some point booted from USB.\n\nUsually when removing a virus like Microsoft Windows from your system.\n\nOlden days computers could boot from floppy disks, etc.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#bootlaoder",
    "href": "40_kernel.html#bootlaoder",
    "title": "Kernel",
    "section": "Bootlaoder",
    "text": "Bootlaoder\n\nI mentioned 1980s bootloaders.\n\nNo relation to bootleggers or boatloaders.\n\n512-byte portion of executable code stored at the bootable disk‚Äôs ‚Äúbeginning‚Äù.\n\nOn a HDD this is physically the outermost ring of addressable magnetic regions.\nI don‚Äôt know how SSDs work as Samsung, SK Hynix, or Micron (shout out Boise).",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#data-structures",
    "href": "40_kernel.html#data-structures",
    "title": "Kernel",
    "section": "Data Structures",
    "text": "Data Structures\n\nMost bootloaders are larger than 512 bytes.\nSo bootloaders are commonly split into a 512 byte first stage that loads a latter stage.\n\nThis is why we should still be teaching linked lists, basically.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#location-location",
    "href": "40_kernel.html#location-location",
    "title": "Kernel",
    "section": "Location, Location",
    "text": "Location, Location\n\nThe bootloader lives in a reserved physical (HDD) or logical (SSD) location.\nDoes the OS?\n\nWith respect to itself, yes, the OS probably says it lives at memory location zero.\nWith respect to underlying hardware? Probably not.\n\nGotta find it.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#booting-the-os",
    "href": "40_kernel.html#booting-the-os",
    "title": "Kernel",
    "section": "Booting the OS",
    "text": "Booting the OS\n\nThe bootloader has to determine the location of the kernel image on disk and load it into memory.\n\nBasically this is the definition of the kernel, the minimal OS internal that runs first.\nImage here means we have physical bits capturing some information, so copies of the bits may live in different places.\n\nSSD and RAM, for example.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#switcheroo",
    "href": "40_kernel.html#switcheroo",
    "title": "Kernel",
    "section": "Switcheroo",
    "text": "Switcheroo\n\nThe OS probably is not a 16-bit OS.\n\nUnless? Lab idea? Hold me back!\n\nBig OS wants me to tell you that:\n\n16-bit mode is called ‚Äúreal mode‚Äù\n32-bit mode is called ‚Äúprotected mode‚Äù\n64-bit mode is called ‚Äúlong mode‚Äù.\n\nRecall we were writing 64-bit bare metal.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#hand-wave",
    "href": "40_kernel.html#hand-wave",
    "title": "Kernel",
    "section": "Hand-wave",
    "text": "Hand-wave\n\nWriting a bootloader is a bit cumbersome as it requires assembly language and ‚Äúwrite this magic value to this processor register‚Äù.\n\n\nInstead use a bootimage that automatically prepends a bootloader to your kernel.\n\n\nThis is called ‚Äúcheating‚Äù and is a good way to get ahead in life.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#a-minimal-kernel",
    "href": "40_kernel.html#a-minimal-kernel",
    "title": "Kernel",
    "section": "A Minimal Kernel",
    "text": "A Minimal Kernel\n\nLet‚Äôs make a kernel.\nSpecifically, a disk image that prints a ‚ÄúHello World!‚Äù to the screen when booted.\nWe extending our bare metal executable.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#target-triple",
    "href": "40_kernel.html#target-triple",
    "title": "Kernel",
    "section": "Target Triple",
    "text": "Target Triple\n\nWe recall the ‚Äútarget triple‚Äù\nImagine host triple is x86_64-unknown-linux-gnu\n\nCPU architecture (x86_64),\nVendor (unknown) - It‚Äôs Intel #Portland\nOperating system (linux)\nThe ABI (gnu).",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#our-target",
    "href": "40_kernel.html#our-target",
    "title": "Kernel",
    "section": "Our Target",
    "text": "Our Target\n\nI am aware of no existing target triple suitable for this course.\nSo, make our own.\nIt‚Äôs not too bad, just JSON.\n\nWe‚Äôll specify some easy stuff, like architecture.\nSome weird stuff, like manual memory layouts.\nAnd get on with things.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#json",
    "href": "40_kernel.html#json",
    "title": "Kernel",
    "section": "JSON",
    "text": "JSON\n\nJSON rules by the way.\n\n{\n    \"llvm-target\": \"x86_64-unknown-linux-gnu\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"linux\",\n    \"executables\": true,\n    \"linker-flavor\": \"gcc\",\n    \"pre-link-args\": [\"-m64\"],\n    \"morestack\": false\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#some-context",
    "href": "40_kernel.html#some-context",
    "title": "Kernel",
    "section": "Some context",
    "text": "Some context\n\nMost fields are required by LLVM.\nData layout field defines the size of integer, float (ew), and pointer types.\nRust uses conditional compilation, such as via target-pointer-width.\nThe pre-link-args field specifies arguments passed to the linker.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#arm64-take-notes",
    "href": "40_kernel.html#arm64-take-notes",
    "title": "Kernel",
    "section": "ARM64 Take Notes",
    "text": "ARM64 Take Notes\n\nWe also target x86_64.\nStart here:\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#changes",
    "href": "40_kernel.html#changes",
    "title": "Kernel",
    "section": "Changes",
    "text": "Changes\n\nNote that we changed the OS in the llvm-target and the os field to none, because we will run on bare metal.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    ...\n    \"os\": \"none\",\n    ...\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#linking",
    "href": "40_kernel.html#linking",
    "title": "Kernel",
    "section": "Linking",
    "text": "Linking\n\nWe‚Äôll add the following build-related entries:\n\n\n\nx86_64-osirs.json\n\n{\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n}\n\n\nFor OS-agnosticism, we use the cross-platform ‚ÄúLLD‚Äù linker that is shipped with Rust for linking our kernel.\n\nMore.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#panic-abort",
    "href": "40_kernel.html#panic-abort",
    "title": "Kernel",
    "section": "Panic Abort",
    "text": "Panic Abort\n\nYou know how I feel about unwinding.\n\nI have never relaxed in my life.\nI‚Äôve only panicked and given up.\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"panic-strategy\": \"abort\",\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#target-vs.-toml",
    "href": "40_kernel.html#target-vs.-toml",
    "title": "Kernel",
    "section": "Target vs.¬†TOML",
    "text": "Target vs.¬†TOML\n\nThis has the same effect as the panic = \"abort\" option in our Cargo.toml\nSo we can remove it from there!\nThis is better though:\n\nWe will use core, an architecture specific library, and we need core to also panic abort.\n‚ÄúIt is the portable glue between the language and its libraries, defining the intrinsic and primitive building blocks of all Rust code.‚Äù",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#red-zone",
    "href": "40_kernel.html#red-zone",
    "title": "Kernel",
    "section": "Red Zone",
    "text": "Red Zone\n\nOkay red zone is not particularly relevant to this class.\nBut it is extremely cool.\n\n\n\nx86_64-osirs.json\n\n{\n    \"disable-redzone\": true,\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#ancient-nemesis",
    "href": "40_kernel.html#ancient-nemesis",
    "title": "Kernel",
    "section": "Ancient Nemesis",
    "text": "Ancient Nemesis\n\nYou all know I love floating point numbers.\n\nAnd with good reason!\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"features\": \"-mmx,-sse,+soft-float\",\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#turn-off-floats",
    "href": "40_kernel.html#turn-off-floats",
    "title": "Kernel",
    "section": "Turn off floats",
    "text": "Turn off floats\n\nfeatures enables/disables target features.\nWe disable the mmx and sse features by prefixing them with a minus\nWe enable the soft-float feature by prefixing it with a plus.\nNote that there must be no spaces between different flags!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#mmxsse",
    "href": "40_kernel.html#mmxsse",
    "title": "Kernel",
    "section": "MMX/SSE",
    "text": "MMX/SSE\n\nThe mmx and sse features are performance optimizing vector operations from when Intel though they‚Äôd be able to hold off NVIDIA in the 90s.\nThese are braodly called Single Instruction Multiple Data (SIMD) instructions and are historically important.\n\nFoundation of numpy\n\nWe aren‚Äôt using data frames in our kernel.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#soft-float",
    "href": "40_kernel.html#soft-float",
    "title": "Kernel",
    "section": "Soft Float",
    "text": "Soft Float\n\nFloating point operations on x86_64 require SIMD registers by default.\n\nThat‚Äôs right - floats are worse than you thought!\n\nTo solve this problem, we add the soft-float feature, which emulates all floating point operations through software functions based on normal integers.\n\nJust like f16",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-1",
    "href": "40_kernel.html#aside-1",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nWe also need to tell the Rust compiler rustc that we want to use the corresponding ABI.\n\n\n\nx86_64-osirs.json\n\n{\n    \"rustc-abi\": \"x86-softfloat\"\n}\n\n\nI am 100% sure I can write an OS without hard or soft floats but I haven‚Äôt worked far enough ahead to be absolutely certain.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#altogether",
    "href": "40_kernel.html#altogether",
    "title": "Kernel",
    "section": "Altogether",
    "text": "Altogether\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true,\n    \"features\": \"-mmx,-sse,+soft-float\",\n    \"rustc-abi\": \"x86-softfloat\"\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#i-just-curl",
    "href": "40_kernel.html#i-just-curl",
    "title": "Kernel",
    "section": "I just curl",
    "text": "I just curl\ncurl https://raw.githubusercontent.com/phil-opp/blog_os/refs/heads/post-02/x86_64-blog_os.json -o x86_64-osirs.json",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#tree",
    "href": "40_kernel.html#tree",
    "title": "Kernel",
    "section": "Tree",
    "text": "Tree\n\nFor me looks like this.\n\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.rs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ old.rs\n‚îî‚îÄ‚îÄ x86_64-osirs.json\n\n1 directory, 5 files",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#back-to-loops",
    "href": "40_kernel.html#back-to-loops",
    "title": "Kernel",
    "section": "Back to loops",
    "text": "Back to loops\n\nBy the way, I‚Äôve switched from cool, good recursion back to unexciting, drab loops\nInfinite recursion blows up the call stack and instantly segmentation faults.\n\nThis is because someone other than me wrote rustc.\nI am not about to write rustc!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#current-main",
    "href": "40_kernel.html#current-main",
    "title": "Kernel",
    "section": "Current main",
    "text": "Current main\n\n\nsrc/main.rs\n\n\u0016#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#a-note",
    "href": "40_kernel.html#a-note",
    "title": "Kernel",
    "section": "A note",
    "text": "A note\n\nRemember the earlier mention of core\n\nHow we need core to also panic abort?\nWe note when looking at src/main.rs we do have a core reference.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#linux-everywhere",
    "href": "40_kernel.html#linux-everywhere",
    "title": "Kernel",
    "section": "Linux Everywhere",
    "text": "Linux Everywhere\n\nOkay so we aren‚Äôt going to use Linux on our device.\nBut we are going to use Linux conventions\n\nNot Linux software, but Linux as a social technology.\n\nThe ld.lld ‚Äúlinker-flavor‚Äù instructs LLVM to compile with the -flavor gnu flag.\nThis means that we need an entry point named _start - same as before!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#build-it",
    "href": "40_kernel.html#build-it",
    "title": "Kernel",
    "section": "Build it",
    "text": "Build it\n\nI bet it will work now.\n\nUse our new target by passing the name of the JSON file as --target:\n\n\n$ cargo b --target x86_64-osirs.json\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: Error loading target specification: Field target-pointer-width in target specification is required. Run `rustc --print target-list` for a list of built-in targets",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-2",
    "href": "40_kernel.html#aside-2",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip two slides!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#okay-so",
    "href": "40_kernel.html#okay-so",
    "title": "Kernel",
    "section": "Okay so",
    "text": "Okay so\n\nHuh?\n\nField target-pointer-width in target specification is required.\n\nWe very explicitly included that.\nIn the most annoying thing in the universe, rustc expect pointer width as a JSON string and not a JSON integer.\n\nRead more\nIt‚Äôs fixed in Nightly, but I sleep at night, so I‚Äôm busy.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#fix-it",
    "href": "40_kernel.html#fix-it",
    "title": "Kernel",
    "section": "Fix it?",
    "text": "Fix it?\n\nI kid you not this is the solution.\n\n‚ÄúRust has a type system!‚Äù\nSure it does.\n\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\",",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#now-it-works",
    "href": "40_kernel.html#now-it-works",
    "title": "Kernel",
    "section": "Now it works",
    "text": "Now it works\n\nThis time it will work.\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nOkay I was bamboozled.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-core",
    "href": "40_kernel.html#the-core",
    "title": "Kernel",
    "section": "The Core",
    "text": "The Core\n\n\n\nThe Core is a 2003 American science fiction disaster film directed by Jon Amiel with screenplay written by Cooper Layne and John Rogers.\n\n\nI haven‚Äôt seen it but it apparently passes the Bechdel Test",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#wrong-core",
    "href": "40_kernel.html#wrong-core",
    "title": "Kernel",
    "section": "Wrong Core",
    "text": "Wrong Core\n\nWe actually meant the Rust compiler core library.\n\nRead more\n\nThis library contains basic Rust types such as Result, Option, and iterators, and is implicitly linked to all no_std crates.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-problem",
    "href": "40_kernel.html#the-problem",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\ncore is usually pre-compiled (and then, of course, linked).\nBut we made a new target which needs a new core.\nNo problem, we‚Äôll just tell rustc to do some compilation.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#config",
    "href": "40_kernel.html#config",
    "title": "Kernel",
    "section": "Config",
    "text": "Config\n\nThe most graceful to do this that I am aware of is with a .cargo/config.toml\nBasically, we can write down some things we always want cargo to do, and store them in TOML file in the hidden .cargo folder.\nI just made the folder then opened it up in my most beloved neon vimothy.\n\nmdkir .cargo\nnvim .cargo/config.toml",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#check-in",
    "href": "40_kernel.html#check-in",
    "title": "Kernel",
    "section": "Check in",
    "text": "Check in\nmdkir .cargo\nnvim .cargo/config.toml\n\nUnderstanding check - what happens if you don‚Äôt make .cargo first?",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-build-std-option",
    "href": "40_kernel.html#the-build-std-option",
    "title": "Kernel",
    "section": "The build-std Option",
    "text": "The build-std Option\n\nbuild-std is a feature of Cargo.\nWe can recompile core and other standard library crates on demand.\n\nVs. using the precompiled versions shipped with the Rust installation.\n\nRead more.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#my-config",
    "href": "40_kernel.html#my-config",
    "title": "Kernel",
    "section": "My Config",
    "text": "My Config\n\nWe can use a pretty sparse config though we‚Äôll want to add more latter.\nI specify the ‚Äúbuild-std‚Äù option in TOML.\nWe want to build-std\nWe want to build the core\n\n\n\n.cargo/config.toml\n\n\u0016build-std = [\"core\"]\n\n\nI bet this will work.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#oh.",
    "href": "40_kernel.html#oh.",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#unstable",
    "href": "40_kernel.html#unstable",
    "title": "Kernel",
    "section": "Unstable",
    "text": "Unstable\n\nSo apparently build-std is not a stable feature of the Rust language.\n\nThis means the Rust designers can change or remove it at any time.\n\nTo use unstable features, we have to tell cargo they are unstable.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#mental-model",
    "href": "40_kernel.html#mental-model",
    "title": "Kernel",
    "section": "Mental model",
    "text": "Mental model\n\nThink of it a bit like unsafe, but for the language instead of the executables.\n\nWhen an executable is unsafe, it may crash or leak your private key.\nWhen a language is unstable, it may not compile or may compile then leak your private key.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#update-config",
    "href": "40_kernel.html#update-config",
    "title": "Kernel",
    "section": "Update config",
    "text": "Update config\n\nWe prepend an [unstable] label to our build-std configuration.\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nI bet it will work now (it won‚Äôt).",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#oh.-1",
    "href": "40_kernel.html#oh.-1",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#nightly",
    "href": "40_kernel.html#nightly",
    "title": "Kernel",
    "section": "Nightly",
    "text": "Nightly\n\nOkay folks here‚Äôs the deal.\nI‚Äôm not happy about it either.\nbuild-std - which we need - is unstable and\n[unstable] is only available in nightly Rust.\n\nThe version of Rust for nerds.\n\nNot to worry, we are nerds and can use it.\n\nSimply add a +nightly right after cargo.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#try-two-things",
    "href": "40_kernel.html#try-two-things",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere‚Äôs two things that also still won‚Äôt work.\n\ncargo +nightly b --target x86_64-osirs.json\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#try-two-things-1",
    "href": "40_kernel.html#try-two-things-1",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere‚Äôs two things that also still won‚Äôt work.\n\ncargo +nightly b\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"/home/user/tmp/32/target/debug/deps/{libcore-0c26ef2bd74962c1,libcompiler_builtins-40a77a01cbdbd500}.rlib\" \"-L\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/raw-dylibs\" \"-Wl,-Bdynamic\" \"-B&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld\" \"-fuse-ld=lld\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: rust-lld: error: duplicate symbol: _start\n          &gt;&gt;&gt; defined at /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(_start)\n          &gt;&gt;&gt; defined at main.rs:6 (src/main.rs:6)\n          &gt;&gt;&gt;            /home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391.3hpwl9lytayxk9wu897na7tu0.0wpyfaj.rcgu.o:(.text._start+0x0)\n          collect2: error: ld returned 1 exit status\n\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-problem-1",
    "href": "40_kernel.html#the-problem-1",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\nNot everything works the same way with nightly and stable rust.\n\nThat‚Äôs why it‚Äôs not stable.\n\nWe will encounter two examples immediately, both related to JSON.\nLet‚Äôs look at this:\n\n$ cargo +nightly b --target x86_64-osirs.json\nerror: `.json` target specs require -Zjson-target-spec",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#one-solution",
    "href": "40_kernel.html#one-solution",
    "title": "Kernel",
    "section": "One Solution",
    "text": "One Solution\n\nWe can of course just put -Zjson-target-spec in there.\nWe get an error, but one we are clever enough to handle.\n\n$ cargo +nightly b --target x86_64-osirs.json -Zjson-target-spec\n\nGives this:\n\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#another-solution",
    "href": "40_kernel.html#another-solution",
    "title": "Kernel",
    "section": "Another Solution",
    "text": "Another Solution\n\nHowever, that -Zjson-target-spec looks an awful lot like a .cargo/config.toml option‚Ä¶\n\nI believe that is also unstable‚Ä¶\n‚Ä¶ after all, it works fine on stable!\n\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nWe can then get the same error with less typing:\n\ncargo +nightly b --target x86_64-osirs.json",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-error",
    "href": "40_kernel.html#the-error",
    "title": "Kernel",
    "section": "The error",
    "text": "The error\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets\n\nDoes that remind you of anything?\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\",",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-3",
    "href": "40_kernel.html#aside-3",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip one slide!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#revert",
    "href": "40_kernel.html#revert",
    "title": "Kernel",
    "section": "Revert!",
    "text": "Revert!\n\nChange the string integers back to integer integers in your JSON file and you will be living a charmed and blessed life.\n\nA long one, compilation is 10+ seconds for me.\n\n\n$ cargo +nightly b --target x86_64-osirs.json\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n^[[A    Building [==========&gt;                  ] 2/5: core, compiler_builtins                                                                Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 10.18s",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-4",
    "href": "40_kernel.html#aside-4",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nBy the way, are you tired of specifying the target every time?\n\nSounds like a problem for .cargo/config.toml!\n\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#run-again",
    "href": "40_kernel.html#run-again",
    "title": "Kernel",
    "section": "Run again",
    "text": "Run again\n\nBy the way it will be fast now.\n\n$ cargo +nightly b\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-nightly",
    "href": "40_kernel.html#aside-nightly",
    "title": "Kernel",
    "section": "Aside: Nightly",
    "text": "Aside: Nightly\n\nSurely you can also update .cargo/config.toml to use nightly!\n\nYou can‚Äôt. You can solve the problem other ways though.\nLeft as an exercise to the interested student.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-notfutureproofing",
    "href": "40_kernel.html#aside-notfutureproofing",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I can make a kernel without floats.\nSo I removed the two soft-float lines and it still worked for now.\n\n$ diff old.boring x86_64-osirs.json\n13,15c13\n&lt;     \"disable-redzone\": true,\n&lt;     \"features\": \"-mmx,-sse,+soft-float\",\n&lt;     \"rustc-abi\": \"x86-softfloat\"\n---\n&gt;     \"disable-redzone\": true",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-notfutureproofing-1",
    "href": "40_kernel.html#aside-notfutureproofing-1",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I could make a kernel without compiler-builtins\nThese are memory related functions where Rust often uses linked C implementations.\nI‚Äôm leaving them out for now and will add them in when I need them.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std-features = [\"compiler-builtins-mem\"]\nbuild-std = [\"core\", \"compiler_builtins\"]",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#boot-it",
    "href": "40_kernel.html#boot-it",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n\nAnd with that, I bet this will totally work.\nLet‚Äôs break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed ‚Äúmisc‚Äù qemu\n\nReal ones will use apt\n\nsudo apt install qemu-system-x86",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#boot-it-1",
    "href": "40_kernel.html#boot-it-1",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#main-file",
    "href": "40_kernel.html#main-file",
    "title": "Kernel",
    "section": "Main File",
    "text": "Main File\n\nUnaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#config-file",
    "href": "40_kernel.html#config-file",
    "title": "Kernel",
    "section": "Config File",
    "text": "Config File\n\nAll new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#target-file",
    "href": "40_kernel.html#target-file",
    "title": "Kernel",
    "section": "Target File",
    "text": "Target File\n\nAll new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#cargo-file",
    "href": "40_kernel.html#cargo-file",
    "title": "Kernel",
    "section": "Cargo File",
    "text": "Cargo File\n\nMove panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.rjs.html#announcements",
    "href": "40_kernel.rjs.html#announcements",
    "title": "Kernel",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nIs qemu working at all.\n\nThe coolest assignment ever for a second week in a row.\nI‚Äôm glad you all love it"
  },
  {
    "objectID": "40_kernel.rjs.html#today",
    "href": "40_kernel.rjs.html#today",
    "title": "Kernel",
    "section": "Today",
    "text": "Today\n\nBackground\nKernel"
  },
  {
    "objectID": "40_kernel.rjs.html#citations",
    "href": "40_kernel.rjs.html#citations",
    "title": "Kernel",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nA Minimal Rust Kernel"
  },
  {
    "objectID": "40_kernel.rjs.html#the-boot-process",
    "href": "40_kernel.rjs.html#the-boot-process",
    "title": "Kernel",
    "section": "The Boot Process",
    "text": "The Boot Process\n\nPOV: You are an inanimate piece of silicon.\n\nYou contain wires connected to logic gates.\nSomewhere, a switch is flipped.\nElectrons flow into some of your wires, through some gates."
  },
  {
    "objectID": "40_kernel.rjs.html#first-steps",
    "href": "40_kernel.rjs.html#first-steps",
    "title": "Kernel",
    "section": "First Steps",
    "text": "First Steps\n\nWhat determines the initial arrangement of gates?\nWhere do electrons flow?\nThis is determined by the boot process\n\nOccurs on every power-up\nDetermined by hardware design\nMore fundamental than the OS"
  },
  {
    "objectID": "40_kernel.rjs.html#firmware",
    "href": "40_kernel.rjs.html#firmware",
    "title": "Kernel",
    "section": "Firmware",
    "text": "Firmware\n\nWhat is between hardware and software?\n\nFirmware.\n\nOn power-up, devices execute code embedded in physical read only memory (ROM).\n\nRead more: ROM\n\nIs it software? Is it hardware? Who can say."
  },
  {
    "objectID": "40_kernel.rjs.html#enter-the-cpu",
    "href": "40_kernel.rjs.html#enter-the-cpu",
    "title": "Kernel",
    "section": "Enter the CPU",
    "text": "Enter the CPU\n\nUsually, power-up occurs on a ‚Äúmotherboard‚Äù hosting, among other things, the bus.\n\nNamed ‚Äúmother‚Äù after the ‚ÄúMU/TH/UR‚Äù on ship computer in Alien (1979)\nThis is a lie."
  },
  {
    "objectID": "40_kernel.rjs.html#not-code-but-ware",
    "href": "40_kernel.rjs.html#not-code-but-ware",
    "title": "Kernel",
    "section": "Not ‚Äúcode‚Äù but ‚Äúware‚Äù",
    "text": "Not ‚Äúcode‚Äù but ‚Äúware‚Äù\n\nSo firmware isn‚Äôt really like CPU code (like Rust or C), but it does:\n\nTell circuitry where to direct electrons within the CPU.\nAlso wake up e.g.¬†the MMU."
  },
  {
    "objectID": "40_kernel.rjs.html#enter-the-os",
    "href": "40_kernel.rjs.html#enter-the-os",
    "title": "Kernel",
    "section": "Enter the OS",
    "text": "Enter the OS\n\nWith the CPU primed but not yet ticking through clock cycles, all that remains is to either\n\nExecute a bare metal executable, or\nBoot an operating system to enable the next higher-level task."
  },
  {
    "objectID": "40_kernel.rjs.html#what-it-sounds-like",
    "href": "40_kernel.rjs.html#what-it-sounds-like",
    "title": "Kernel",
    "section": "What it sounds like",
    "text": "What it sounds like\n\nWe regard, then, the operating system as a system which operates the hardware on behalf of higher level software.\n\nHence, ‚Äúsystems computing‚Äù.\nHopefully the contrast to software is a bit more clear here."
  },
  {
    "objectID": "40_kernel.rjs.html#aside",
    "href": "40_kernel.rjs.html#aside",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nI am supposed to teach you about the ‚Äúpower-on self-test‚Äù.\nA bit electrical engineering for me.\n\n\nA power-on self-test (POST) is a process performed by firmware or software routines immediately after a computer or other digital electronic device is powered on.\n\n\nNeat! Moving on."
  },
  {
    "objectID": "40_kernel.rjs.html#competing-standards",
    "href": "40_kernel.rjs.html#competing-standards",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nLucky us, there is no widely agreed upon way to do firmware.\nThere‚Äôs the cool, old way that doesn‚Äôt work well but is easy.\n\n‚ÄúBasic Input/Output System‚Äú BIOS\n1981"
  },
  {
    "objectID": "40_kernel.rjs.html#competing-standards-1",
    "href": "40_kernel.rjs.html#competing-standards-1",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nThere‚Äôs the new way that is too hard to use for normal people like us.\n\nAs in people who do anything else ever.\nIt‚Äôs good though we promise.\n‚ÄúUnified Extensible Firmware Interface‚Äù UEFI.\nMay make you use it for a lab. More.\n2006"
  },
  {
    "objectID": "40_kernel.rjs.html#bios-boot",
    "href": "40_kernel.rjs.html#bios-boot",
    "title": "Kernel",
    "section": "BIOS Boot",
    "text": "BIOS Boot\n\nI actually started fooling around with the BIOS before UEFI even existed.\n\nI was a normal kid though 100%.\n\nFortunately it‚Äôs still basically around. Quoth Blog:\n\n\nThis is great, because you can use the same boot logic across all machines from the last century."
  },
  {
    "objectID": "40_kernel.rjs.html#upsides",
    "href": "40_kernel.rjs.html#upsides",
    "title": "Kernel",
    "section": "Upsides",
    "text": "Upsides\n\nBlog says it‚Äôs a downside that this means you have to do 16-bit mode.\n\nI say: that‚Äôs cool.\nI can‚Äôt count higher than about 0xFFFF anyways.\n\nThe blog impolitely calls 1980s bootloaders ‚Äúarchaic‚Äù instead of ‚Äúvintage‚Äù, ‚Äúretro‚Äù, or ‚Äúfoundational‚Äù."
  },
  {
    "objectID": "40_kernel.rjs.html#bootable-disks",
    "href": "40_kernel.rjs.html#bootable-disks",
    "title": "Kernel",
    "section": "Bootable Disks",
    "text": "Bootable Disks\n\nI should also tell you about bootable disks\nNowadays we all boot from SSD or rarely HDD.\nBut you have probably at some point booted from USB.\n\nUsually when removing a virus like Microsoft Windows from your system.\n\nOlden days computers could boot from floppy disks, etc."
  },
  {
    "objectID": "40_kernel.rjs.html#bootlaoder",
    "href": "40_kernel.rjs.html#bootlaoder",
    "title": "Kernel",
    "section": "Bootlaoder",
    "text": "Bootlaoder\n\nI mentioned 1980s bootloaders.\n\nNo relation to bootleggers or boatloaders.\n\n512-byte portion of executable code stored at the bootable disk‚Äôs ‚Äúbeginning‚Äù.\n\nOn a HDD this is physically the outermost ring of addressable magnetic regions.\nI don‚Äôt know how SSDs work as Samsung, SK Hynix, or Micron (shout out Boise)."
  },
  {
    "objectID": "40_kernel.rjs.html#data-structures",
    "href": "40_kernel.rjs.html#data-structures",
    "title": "Kernel",
    "section": "Data Structures",
    "text": "Data Structures\n\nMost bootloaders are larger than 512 bytes.\nSo bootloaders are commonly split into a 512 byte first stage that loads a latter stage.\n\nThis is why we should still be teaching linked lists, basically."
  },
  {
    "objectID": "40_kernel.rjs.html#location-location",
    "href": "40_kernel.rjs.html#location-location",
    "title": "Kernel",
    "section": "Location, Location",
    "text": "Location, Location\n\nThe bootloader lives in a reserved physical (HDD) or logical (SSD) location.\nDoes the OS?\n\nWith respect to itself, yes, the OS probably says it lives at memory location zero.\nWith respect to underlying hardware? Probably not.\n\nGotta find it."
  },
  {
    "objectID": "40_kernel.rjs.html#booting-the-os",
    "href": "40_kernel.rjs.html#booting-the-os",
    "title": "Kernel",
    "section": "Booting the OS",
    "text": "Booting the OS\n\nThe bootloader has to determine the location of the kernel image on disk and load it into memory.\n\nBasically this is the definition of the kernel, the minimal OS internal that runs first.\nImage here means we have physical bits capturing some information, so copies of the bits may live in different places.\n\nSSD and RAM, for example."
  },
  {
    "objectID": "40_kernel.rjs.html#switcheroo",
    "href": "40_kernel.rjs.html#switcheroo",
    "title": "Kernel",
    "section": "Switcheroo",
    "text": "Switcheroo\n\nThe OS probably is not a 16-bit OS.\n\nUnless? Lab idea? Hold me back!\n\nBig OS wants me to tell you that:\n\n16-bit mode is called ‚Äúreal mode‚Äù\n32-bit mode is called ‚Äúprotected mode‚Äù\n64-bit mode is called ‚Äúlong mode‚Äù.\n\nRecall we were writing 64-bit bare metal."
  },
  {
    "objectID": "40_kernel.rjs.html#hand-wave",
    "href": "40_kernel.rjs.html#hand-wave",
    "title": "Kernel",
    "section": "Hand-wave",
    "text": "Hand-wave\n\nWriting a bootloader is a bit cumbersome as it requires assembly language and ‚Äúwrite this magic value to this processor register‚Äù.\n\n\nInstead use a bootimage that automatically prepends a bootloader to your kernel.\n\n\nThis is called ‚Äúcheating‚Äù and is a good way to get ahead in life."
  },
  {
    "objectID": "40_kernel.rjs.html#a-minimal-kernel",
    "href": "40_kernel.rjs.html#a-minimal-kernel",
    "title": "Kernel",
    "section": "A Minimal Kernel",
    "text": "A Minimal Kernel\n\nLet‚Äôs make a kernel.\nSpecifically, a disk image that prints a ‚ÄúHello World!‚Äù to the screen when booted.\nWe extending our bare metal executable."
  },
  {
    "objectID": "40_kernel.rjs.html#target-triple",
    "href": "40_kernel.rjs.html#target-triple",
    "title": "Kernel",
    "section": "Target Triple",
    "text": "Target Triple\n\nWe recall the ‚Äútarget triple‚Äù\nImagine host triple is x86_64-unknown-linux-gnu\n\nCPU architecture (x86_64),\nVendor (unknown) - It‚Äôs Intel #Portland\nOperating system (linux)\nThe ABI (gnu)."
  },
  {
    "objectID": "40_kernel.rjs.html#our-target",
    "href": "40_kernel.rjs.html#our-target",
    "title": "Kernel",
    "section": "Our Target",
    "text": "Our Target\n\nI am aware of no existing target triple suitable for this course.\nSo, make our own.\nIt‚Äôs not too bad, just JSON.\n\nWe‚Äôll specify some easy stuff, like architecture.\nSome weird stuff, like manual memory layouts.\nAnd get on with things."
  },
  {
    "objectID": "40_kernel.rjs.html#json",
    "href": "40_kernel.rjs.html#json",
    "title": "Kernel",
    "section": "JSON",
    "text": "JSON\n\nJSON rules by the way.\n\n{\n    \"llvm-target\": \"x86_64-unknown-linux-gnu\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"linux\",\n    \"executables\": true,\n    \"linker-flavor\": \"gcc\",\n    \"pre-link-args\": [\"-m64\"],\n    \"morestack\": false\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#some-context",
    "href": "40_kernel.rjs.html#some-context",
    "title": "Kernel",
    "section": "Some context",
    "text": "Some context\n\nMost fields are required by LLVM.\nData layout field defines the size of integer, float (ew), and pointer types.\nRust uses conditional compilation, such as via target-pointer-width.\nThe pre-link-args field specifies arguments passed to the linker."
  },
  {
    "objectID": "40_kernel.rjs.html#arm64-take-notes",
    "href": "40_kernel.rjs.html#arm64-take-notes",
    "title": "Kernel",
    "section": "ARM64 Take Notes",
    "text": "ARM64 Take Notes\n\nWe also target x86_64.\nStart here:\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#changes",
    "href": "40_kernel.rjs.html#changes",
    "title": "Kernel",
    "section": "Changes",
    "text": "Changes\n\nNote that we changed the OS in the llvm-target and the os field to none, because we will run on bare metal.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    ...\n    \"os\": \"none\",\n    ...\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#linking",
    "href": "40_kernel.rjs.html#linking",
    "title": "Kernel",
    "section": "Linking",
    "text": "Linking\n\nWe‚Äôll add the following build-related entries:\n\n\n\nx86_64-osirs.json\n\n{\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n}\n\n\nFor OS-agnosticism, we use the cross-platform ‚ÄúLLD‚Äù linker that is shipped with Rust for linking our kernel.\n\nMore."
  },
  {
    "objectID": "40_kernel.rjs.html#panic-abort",
    "href": "40_kernel.rjs.html#panic-abort",
    "title": "Kernel",
    "section": "Panic Abort",
    "text": "Panic Abort\n\nYou know how I feel about unwinding.\n\nI have never relaxed in my life.\nI‚Äôve only panicked and given up.\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"panic-strategy\": \"abort\",\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#target-vs.-toml",
    "href": "40_kernel.rjs.html#target-vs.-toml",
    "title": "Kernel",
    "section": "Target vs.¬†TOML",
    "text": "Target vs.¬†TOML\n\nThis has the same effect as the panic = \"abort\" option in our Cargo.toml\nSo we can remove it from there!\nThis is better though:\n\nWe will use core, an architecture specific library, and we need core to also panic abort.\n‚ÄúIt is the portable glue between the language and its libraries, defining the intrinsic and primitive building blocks of all Rust code.‚Äù"
  },
  {
    "objectID": "40_kernel.rjs.html#red-zone",
    "href": "40_kernel.rjs.html#red-zone",
    "title": "Kernel",
    "section": "Red Zone",
    "text": "Red Zone\n\nOkay red zone is not particularly relevant to this class.\nBut it is extremely cool.\n\n\n\nx86_64-osirs.json\n\n{\n    \"disable-redzone\": true,\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#ancient-nemesis",
    "href": "40_kernel.rjs.html#ancient-nemesis",
    "title": "Kernel",
    "section": "Ancient Nemesis",
    "text": "Ancient Nemesis\n\nYou all know I love floating point numbers.\n\nAnd with good reason!\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"features\": \"-mmx,-sse,+soft-float\",\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#turn-off-floats",
    "href": "40_kernel.rjs.html#turn-off-floats",
    "title": "Kernel",
    "section": "Turn off floats",
    "text": "Turn off floats\n\nfeatures enables/disables target features.\nWe disable the mmx and sse features by prefixing them with a minus\nWe enable the soft-float feature by prefixing it with a plus.\nNote that there must be no spaces between different flags!"
  },
  {
    "objectID": "40_kernel.rjs.html#mmxsse",
    "href": "40_kernel.rjs.html#mmxsse",
    "title": "Kernel",
    "section": "MMX/SSE",
    "text": "MMX/SSE\n\nThe mmx and sse features are performance optimizing vector operations from when Intel though they‚Äôd be able to hold off NVIDIA in the 90s.\nThese are braodly called Single Instruction Multiple Data (SIMD) instructions and are historically important.\n\nFoundation of numpy\n\nWe aren‚Äôt using data frames in our kernel."
  },
  {
    "objectID": "40_kernel.rjs.html#soft-float",
    "href": "40_kernel.rjs.html#soft-float",
    "title": "Kernel",
    "section": "Soft Float",
    "text": "Soft Float\n\nFloating point operations on x86_64 require SIMD registers by default.\n\nThat‚Äôs right - floats are worse than you thought!\n\nTo solve this problem, we add the soft-float feature, which emulates all floating point operations through software functions based on normal integers.\n\nJust like f16"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-1",
    "href": "40_kernel.rjs.html#aside-1",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nWe also need to tell the Rust compiler rustc that we want to use the corresponding ABI.\n\n\n\nx86_64-osirs.json\n\n{\n    \"rustc-abi\": \"x86-softfloat\"\n}\n\n\nI am 100% sure I can write an OS without hard or soft floats but I haven‚Äôt worked far enough ahead to be absolutely certain."
  },
  {
    "objectID": "40_kernel.rjs.html#altogether",
    "href": "40_kernel.rjs.html#altogether",
    "title": "Kernel",
    "section": "Altogether",
    "text": "Altogether\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true,\n    \"features\": \"-mmx,-sse,+soft-float\",\n    \"rustc-abi\": \"x86-softfloat\"\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#i-just-curl",
    "href": "40_kernel.rjs.html#i-just-curl",
    "title": "Kernel",
    "section": "I just curl",
    "text": "I just curl\ncurl https://raw.githubusercontent.com/phil-opp/blog_os/refs/heads/post-02/x86_64-blog_os.json -o x86_64-osirs.json"
  },
  {
    "objectID": "40_kernel.rjs.html#tree",
    "href": "40_kernel.rjs.html#tree",
    "title": "Kernel",
    "section": "Tree",
    "text": "Tree\n\nFor me looks like this.\n\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.rs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ old.rs\n‚îî‚îÄ‚îÄ x86_64-osirs.json\n\n1 directory, 5 files"
  },
  {
    "objectID": "40_kernel.rjs.html#back-to-loops",
    "href": "40_kernel.rjs.html#back-to-loops",
    "title": "Kernel",
    "section": "Back to loops",
    "text": "Back to loops\n\nBy the way, I‚Äôve switched from cool, good recursion back to unexciting, drab loops\nInfinite recursion blows up the call stack and instantly segmentation faults.\n\nThis is because someone other than me wrote rustc.\nI am not about to write rustc!"
  },
  {
    "objectID": "40_kernel.rjs.html#current-main",
    "href": "40_kernel.rjs.html#current-main",
    "title": "Kernel",
    "section": "Current main",
    "text": "Current main\n\n\nsrc/main.rs\n\n\u0016#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#a-note",
    "href": "40_kernel.rjs.html#a-note",
    "title": "Kernel",
    "section": "A note",
    "text": "A note\n\nRemember the earlier mention of core\n\nHow we need core to also panic abort?\nWe note when looking at src/main.rs we do have a core reference."
  },
  {
    "objectID": "40_kernel.rjs.html#linux-everywhere",
    "href": "40_kernel.rjs.html#linux-everywhere",
    "title": "Kernel",
    "section": "Linux Everywhere",
    "text": "Linux Everywhere\n\nOkay so we aren‚Äôt going to use Linux on our device.\nBut we are going to use Linux conventions\n\nNot Linux software, but Linux as a social technology.\n\nThe ld.lld ‚Äúlinker-flavor‚Äù instructs LLVM to compile with the -flavor gnu flag.\nThis means that we need an entry point named _start - same as before!"
  },
  {
    "objectID": "40_kernel.rjs.html#build-it",
    "href": "40_kernel.rjs.html#build-it",
    "title": "Kernel",
    "section": "Build it",
    "text": "Build it\n\nI bet it will work now.\n\nUse our new target by passing the name of the JSON file as --target:\n\n\n$ cargo b --target x86_64-osirs.json\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: Error loading target specification: Field target-pointer-width in target specification is required. Run `rustc --print target-list` for a list of built-in targets"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-2",
    "href": "40_kernel.rjs.html#aside-2",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip two slides!"
  },
  {
    "objectID": "40_kernel.rjs.html#okay-so",
    "href": "40_kernel.rjs.html#okay-so",
    "title": "Kernel",
    "section": "Okay so",
    "text": "Okay so\n\nHuh?\n\nField target-pointer-width in target specification is required.\n\nWe very explicitly included that.\nIn the most annoying thing in the universe, rustc expect pointer width as a JSON string and not a JSON integer.\n\nRead more\nIt‚Äôs fixed in Nightly, but I sleep at night, so I‚Äôm busy."
  },
  {
    "objectID": "40_kernel.rjs.html#fix-it",
    "href": "40_kernel.rjs.html#fix-it",
    "title": "Kernel",
    "section": "Fix it?",
    "text": "Fix it?\n\nI kid you not this is the solution.\n\n‚ÄúRust has a type system!‚Äù\nSure it does.\n\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\","
  },
  {
    "objectID": "40_kernel.rjs.html#now-it-works",
    "href": "40_kernel.rjs.html#now-it-works",
    "title": "Kernel",
    "section": "Now it works",
    "text": "Now it works\n\nThis time it will work.\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nOkay I was bamboozled."
  },
  {
    "objectID": "40_kernel.rjs.html#the-core",
    "href": "40_kernel.rjs.html#the-core",
    "title": "Kernel",
    "section": "The Core",
    "text": "The Core\n\n\n\nThe Core is a 2003 American science fiction disaster film directed by Jon Amiel with screenplay written by Cooper Layne and John Rogers.\n\n\nI haven‚Äôt seen it but it apparently passes the Bechdel Test"
  },
  {
    "objectID": "40_kernel.rjs.html#wrong-core",
    "href": "40_kernel.rjs.html#wrong-core",
    "title": "Kernel",
    "section": "Wrong Core",
    "text": "Wrong Core\n\nWe actually meant the Rust compiler core library.\n\nRead more\n\nThis library contains basic Rust types such as Result, Option, and iterators, and is implicitly linked to all no_std crates."
  },
  {
    "objectID": "40_kernel.rjs.html#the-problem",
    "href": "40_kernel.rjs.html#the-problem",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\ncore is usually pre-compiled (and then, of course, linked).\nBut we made a new target which needs a new core.\nNo problem, we‚Äôll just tell rustc to do some compilation."
  },
  {
    "objectID": "40_kernel.rjs.html#config",
    "href": "40_kernel.rjs.html#config",
    "title": "Kernel",
    "section": "Config",
    "text": "Config\n\nThe most graceful to do this that I am aware of is with a .cargo/config.toml\nBasically, we can write down some things we always want cargo to do, and store them in TOML file in the hidden .cargo folder.\nI just made the folder then opened it up in my most beloved neon vimothy.\n\nmdkir .cargo\nnvim .cargo/config.toml"
  },
  {
    "objectID": "40_kernel.rjs.html#check-in",
    "href": "40_kernel.rjs.html#check-in",
    "title": "Kernel",
    "section": "Check in",
    "text": "Check in\nmdkir .cargo\nnvim .cargo/config.toml\n\nUnderstanding check - what happens if you don‚Äôt make .cargo first?"
  },
  {
    "objectID": "40_kernel.rjs.html#the-build-std-option",
    "href": "40_kernel.rjs.html#the-build-std-option",
    "title": "Kernel",
    "section": "The build-std Option",
    "text": "The build-std Option\n\nbuild-std is a feature of Cargo.\nWe can recompile core and other standard library crates on demand.\n\nVs. using the precompiled versions shipped with the Rust installation.\n\nRead more."
  },
  {
    "objectID": "40_kernel.rjs.html#my-config",
    "href": "40_kernel.rjs.html#my-config",
    "title": "Kernel",
    "section": "My Config",
    "text": "My Config\n\nWe can use a pretty sparse config though we‚Äôll want to add more latter.\nI specify the ‚Äúbuild-std‚Äù option in TOML.\nWe want to build-std\nWe want to build the core\n\n\n\n.cargo/config.toml\n\n\u0016build-std = [\"core\"]\n\n\nI bet this will work."
  },
  {
    "objectID": "40_kernel.rjs.html#oh.",
    "href": "40_kernel.rjs.html#oh.",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "40_kernel.rjs.html#unstable",
    "href": "40_kernel.rjs.html#unstable",
    "title": "Kernel",
    "section": "Unstable",
    "text": "Unstable\n\nSo apparently build-std is not a stable feature of the Rust language.\n\nThis means the Rust designers can change or remove it at any time.\n\nTo use unstable features, we have to tell cargo they are unstable."
  },
  {
    "objectID": "40_kernel.rjs.html#mental-model",
    "href": "40_kernel.rjs.html#mental-model",
    "title": "Kernel",
    "section": "Mental model",
    "text": "Mental model\n\nThink of it a bit like unsafe, but for the language instead of the executables.\n\nWhen an executable is unsafe, it may crash or leak your private key.\nWhen a language is unstable, it may not compile or may compile then leak your private key."
  },
  {
    "objectID": "40_kernel.rjs.html#update-config",
    "href": "40_kernel.rjs.html#update-config",
    "title": "Kernel",
    "section": "Update config",
    "text": "Update config\n\nWe prepend an [unstable] label to our build-std configuration.\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nI bet it will work now (it won‚Äôt)."
  },
  {
    "objectID": "40_kernel.rjs.html#oh.-1",
    "href": "40_kernel.rjs.html#oh.-1",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "40_kernel.rjs.html#nightly",
    "href": "40_kernel.rjs.html#nightly",
    "title": "Kernel",
    "section": "Nightly",
    "text": "Nightly\n\nOkay folks here‚Äôs the deal.\nI‚Äôm not happy about it either.\nbuild-std - which we need - is unstable and\n[unstable] is only available in nightly Rust.\n\nThe version of Rust for nerds.\n\nNot to worry, we are nerds and can use it.\n\nSimply add a +nightly right after cargo."
  },
  {
    "objectID": "40_kernel.rjs.html#try-two-things",
    "href": "40_kernel.rjs.html#try-two-things",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere‚Äôs two things that also still won‚Äôt work.\n\ncargo +nightly b --target x86_64-osirs.json\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec"
  },
  {
    "objectID": "40_kernel.rjs.html#try-two-things-1",
    "href": "40_kernel.rjs.html#try-two-things-1",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere‚Äôs two things that also still won‚Äôt work.\n\ncargo +nightly b\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"/home/user/tmp/32/target/debug/deps/{libcore-0c26ef2bd74962c1,libcompiler_builtins-40a77a01cbdbd500}.rlib\" \"-L\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/raw-dylibs\" \"-Wl,-Bdynamic\" \"-B&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld\" \"-fuse-ld=lld\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: rust-lld: error: duplicate symbol: _start\n          &gt;&gt;&gt; defined at /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(_start)\n          &gt;&gt;&gt; defined at main.rs:6 (src/main.rs:6)\n          &gt;&gt;&gt;            /home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391.3hpwl9lytayxk9wu897na7tu0.0wpyfaj.rcgu.o:(.text._start+0x0)\n          collect2: error: ld returned 1 exit status\n\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "40_kernel.rjs.html#the-problem-1",
    "href": "40_kernel.rjs.html#the-problem-1",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\nNot everything works the same way with nightly and stable rust.\n\nThat‚Äôs why it‚Äôs not stable.\n\nWe will encounter two examples immediately, both related to JSON.\nLet‚Äôs look at this:\n\n$ cargo +nightly b --target x86_64-osirs.json\nerror: `.json` target specs require -Zjson-target-spec"
  },
  {
    "objectID": "40_kernel.rjs.html#one-solution",
    "href": "40_kernel.rjs.html#one-solution",
    "title": "Kernel",
    "section": "One Solution",
    "text": "One Solution\n\nWe can of course just put -Zjson-target-spec in there.\nWe get an error, but one we are clever enough to handle.\n\n$ cargo +nightly b --target x86_64-osirs.json -Zjson-target-spec\n\nGives this:\n\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets"
  },
  {
    "objectID": "40_kernel.rjs.html#another-solution",
    "href": "40_kernel.rjs.html#another-solution",
    "title": "Kernel",
    "section": "Another Solution",
    "text": "Another Solution\n\nHowever, that -Zjson-target-spec looks an awful lot like a .cargo/config.toml option‚Ä¶\n\nI believe that is also unstable‚Ä¶\n‚Ä¶ after all, it works fine on stable!\n\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nWe can then get the same error with less typing:\n\ncargo +nightly b --target x86_64-osirs.json"
  },
  {
    "objectID": "40_kernel.rjs.html#the-error",
    "href": "40_kernel.rjs.html#the-error",
    "title": "Kernel",
    "section": "The error",
    "text": "The error\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets\n\nDoes that remind you of anything?\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\","
  },
  {
    "objectID": "40_kernel.rjs.html#aside-3",
    "href": "40_kernel.rjs.html#aside-3",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip one slide!"
  },
  {
    "objectID": "40_kernel.rjs.html#revert",
    "href": "40_kernel.rjs.html#revert",
    "title": "Kernel",
    "section": "Revert!",
    "text": "Revert!\n\nChange the string integers back to integer integers in your JSON file and you will be living a charmed and blessed life.\n\nA long one, compilation is 10+ seconds for me.\n\n\n$ cargo +nightly b --target x86_64-osirs.json\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n^[[A    Building [==========&gt;                  ] 2/5: core, compiler_builtins                                                                Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 10.18s"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-4",
    "href": "40_kernel.rjs.html#aside-4",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nBy the way, are you tired of specifying the target every time?\n\nSounds like a problem for .cargo/config.toml!\n\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\""
  },
  {
    "objectID": "40_kernel.rjs.html#run-again",
    "href": "40_kernel.rjs.html#run-again",
    "title": "Kernel",
    "section": "Run again",
    "text": "Run again\n\nBy the way it will be fast now.\n\n$ cargo +nightly b\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-nightly",
    "href": "40_kernel.rjs.html#aside-nightly",
    "title": "Kernel",
    "section": "Aside: Nightly",
    "text": "Aside: Nightly\n\nSurely you can also update .cargo/config.toml to use nightly!\n\nYou can‚Äôt. You can solve the problem other ways though.\nLeft as an exercise to the interested student."
  },
  {
    "objectID": "40_kernel.rjs.html#aside-notfutureproofing",
    "href": "40_kernel.rjs.html#aside-notfutureproofing",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I can make a kernel without floats.\nSo I removed the two soft-float lines and it still worked for now.\n\n$ diff old.boring x86_64-osirs.json\n13,15c13\n&lt;     \"disable-redzone\": true,\n&lt;     \"features\": \"-mmx,-sse,+soft-float\",\n&lt;     \"rustc-abi\": \"x86-softfloat\"\n---\n&gt;     \"disable-redzone\": true"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-notfutureproofing-1",
    "href": "40_kernel.rjs.html#aside-notfutureproofing-1",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I could make a kernel without compiler-builtins\nThese are memory related functions where Rust often uses linked C implementations.\nI‚Äôm leaving them out for now and will add them in when I need them.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std-features = [\"compiler-builtins-mem\"]\nbuild-std = [\"core\", \"compiler_builtins\"]"
  },
  {
    "objectID": "40_kernel.rjs.html#boot-it",
    "href": "40_kernel.rjs.html#boot-it",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n\nAnd with that, I bet this will totally work.\nLet‚Äôs break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed ‚Äúmisc‚Äù qemu\n\nReal ones will use apt\n\nsudo apt install qemu-system-x86"
  },
  {
    "objectID": "40_kernel.rjs.html#boot-it-1",
    "href": "40_kernel.rjs.html#boot-it-1",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab."
  },
  {
    "objectID": "40_kernel.rjs.html#main-file",
    "href": "40_kernel.rjs.html#main-file",
    "title": "Kernel",
    "section": "Main File",
    "text": "Main File\n\nUnaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#config-file",
    "href": "40_kernel.rjs.html#config-file",
    "title": "Kernel",
    "section": "Config File",
    "text": "Config File\n\nAll new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\""
  },
  {
    "objectID": "40_kernel.rjs.html#target-file",
    "href": "40_kernel.rjs.html#target-file",
    "title": "Kernel",
    "section": "Target File",
    "text": "Target File\n\nAll new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#cargo-file",
    "href": "40_kernel.rjs.html#cargo-file",
    "title": "Kernel",
    "section": "Cargo File",
    "text": "Cargo File\n\nMove panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]"
  },
  {
    "objectID": "41_boot.html",
    "href": "41_boot.html",
    "title": "Boot",
    "section": "",
    "text": "We had add a .cargo/config.toml and updated our existing files.\nWe were able to build an executable for a bare metal target.\nWe have not yet run the executable, and will have to do so using qemu.\n\n\n\n\n\nLet‚Äôs break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed ‚Äúmisc‚Äù qemu\n\nReal ones will use apt\n\n\nsudo apt install qemu-system-x86\n\n\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab.\n\n\n\n\n\n\nUnaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}\n\n\n\n\n\nAll new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"\n\n\n\n\n\nAll new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}\n\n\n\n\n\nMove panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#where-we-left-off.",
    "href": "41_boot.html#where-we-left-off.",
    "title": "Boot",
    "section": "",
    "text": "We had add a .cargo/config.toml and updated our existing files.\nWe were able to build an executable for a bare metal target.\nWe have not yet run the executable, and will have to do so using qemu.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#qemu",
    "href": "41_boot.html#qemu",
    "title": "Boot",
    "section": "",
    "text": "Let‚Äôs break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed ‚Äúmisc‚Äù qemu\n\nReal ones will use apt\n\n\nsudo apt install qemu-system-x86",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#boot-it",
    "href": "41_boot.html#boot-it",
    "title": "Boot",
    "section": "",
    "text": "$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#main-file",
    "href": "41_boot.html#main-file",
    "title": "Boot",
    "section": "",
    "text": "Unaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#config-file",
    "href": "41_boot.html#config-file",
    "title": "Boot",
    "section": "",
    "text": "All new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#target-file",
    "href": "41_boot.html#target-file",
    "title": "Boot",
    "section": "",
    "text": "All new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#cargo-file",
    "href": "41_boot.html#cargo-file",
    "title": "Boot",
    "section": "",
    "text": "Move panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#running-our-kernel",
    "href": "41_boot.html#running-our-kernel",
    "title": "Boot",
    "section": "Running our Kernel",
    "text": "Running our Kernel\n\nNow that we have an executable that does something perceptible, it is time to run it.\nFirst, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader.\nThen we can run the disk image in qemu virtual machine‚Ä¶\n‚Ä¶or boot it on real hardware using a USB stick.\n\nIf you do that, you are responsible for what happens.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#creating-a-bootimage",
    "href": "41_boot.html#creating-a-bootimage",
    "title": "Boot",
    "section": "Creating a Bootimage",
    "text": "Creating a Bootimage\n\nTo turn our compiled kernel into a bootable disk image, we need to link it with a bootloader.\nRecall the bootloader is responsible for initializing the CPU and loading our kernel.\n\nMU/TH/UR dumping a bucket of electrons atop a CPU.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#work-smart-not-hard",
    "href": "41_boot.html#work-smart-not-hard",
    "title": "Boot",
    "section": "Work Smart Not Hard",
    "text": "Work Smart Not Hard\n\nWe do not write our own bootloader1.\nWe use the bootloader crate.\nThis crate implements a basic BIOS bootloader without any C dependencies.\n\nJust Rust and\ninline assembly (asm!, handwaved for the compilers class)\n\nTo use it for booting our kernel, we need to add a dependency on it:\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbootloader = \"0.9\"\n\n\nNote: We use bootloader v0.9.\nNewer versions allegedly use a different build system and will result in build errors.\n\nI didn‚Äôt check.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#onward",
    "href": "41_boot.html#onward",
    "title": "Boot",
    "section": "Onward!",
    "text": "Onward!\n\nAdding the bootloader as a dependency is not enough to actually create a bootable disk image.\nThe problem is that we need to link our kernel with the bootloader after compilation.\nBut Cargo has no support for post-build scripts.\n\nTypical Cargo L.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#install-bootimage",
    "href": "41_boot.html#install-bootimage",
    "title": "Boot",
    "section": "Install Bootimage",
    "text": "Install Bootimage\n\nTo solve this problem, use a tool named bootimage\nIt first compiles the kernel and bootloader.\nThen it links them together to create a bootable disk image.\nTo install the tool, we will use‚Ä¶ cargo:\n\ncargo install bootimage",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#create-bootimage",
    "href": "41_boot.html#create-bootimage",
    "title": "Boot",
    "section": "Create Bootimage",
    "text": "Create Bootimage\n\nOnce installed it is a simple matter to use:\n\ncargo bootimage\n\nThis will obviously work on the first try, unless it doesn‚Äôt.\nIn point of fact, I expect you to be able to fix two or three sequential errors you should see after using this command.\n\nStop here and get a bootimage working with no errors.\nYou can consult lecture materials and also review the recommendations of Cargo when it reports an error.\nIf you get stuck here‚Äôs a spoiler.\n\n\n\nrustup +nightly component add llvm-tools-preview\ncargo +nightly bootimage",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#how-does-it-work",
    "href": "41_boot.html#how-does-it-work",
    "title": "Boot",
    "section": "How does it work?",
    "text": "How does it work?\nThe bootimage tool performs the following steps behind the scenes:\n\nIt compiles our kernel to an ELF file.\nIt compiles the bootloader dependency as a standalone executable.\nIt links the bytes of the kernel ELF file to the bootloader.\n\nRead about the rust-osdev/bootloader",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#on-boot",
    "href": "41_boot.html#on-boot",
    "title": "Boot",
    "section": "On Boot",
    "text": "On Boot\n\nWhen booted, the bootloader reads and parses the appended ELF file.\nIt then maps the program segments to virtual addresses.\nZeroes the .bss section, and sets up a stack.\n\n.bss holds static variables.\nLike static mut BUS from the Malloc assignment.\n\nIt reads the entry point address (_start).\nIt ‚Äújumps‚Äù to _start and begins executing the code there.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#booting-it-in-qemu",
    "href": "41_boot.html#booting-it-in-qemu",
    "title": "Boot",
    "section": "Booting it in QEMU",
    "text": "Booting it in QEMU\n\nWe can now boot the disk image in a virtual machine.\nTo boot it in qemu, execute the following command:\n\nqemu-system-x86_64 -drive format=raw,file=target/x86_64-osirs/debug/bootimage-osirs.bin\n\nNaturally this won‚Äôt work if you have other names for your files, but hopefully you get the gist.\nThis opens a separate window ‚ÄúQEMU‚Äù window and currently display nothing.\n\nWe want to continue to open this graphics window so we have somewhere to look at text when we finally get it to work!",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#real-machine",
    "href": "41_boot.html#real-machine",
    "title": "Boot",
    "section": "Real Machine",
    "text": "Real Machine\n\n\n\n\n\n\nCautionDon‚Äôt do this\n\n\n\nDon‚Äôt do this.\n\n\n\nIt is also possible to write it to a USB stick and boot it on a real machine, but be careful to choose the correct device name, because everything on that device is overwritten:\n\ndd if=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX && sync\n\nWhere sdX is the device name of your USB stick.\nAfter writing the image to the USB stick, you can run it on real hardware by booting from it.\nYou probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick.\nNote that it currently doesn‚Äôt work for UEFI machines, since the bootloader crate has no UEFI support yet.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#using-cargo-run",
    "href": "41_boot.html#using-cargo-run",
    "title": "Boot",
    "section": "Using cargo run",
    "text": "Using cargo run\nTo make it easier to run our kernel in QEMU, we can set the runner configuration key for cargo:\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"\n\n[target.'cfg(target_os = \"none\")']\nrunner = \"bootimage runner\"\n\n\ntarget.'cfg(target_os = \"none\")' matches any case where \"os\" is \"none\".\n\nLike our custom target.\n\nThe runner key specifies the command that should be invoked for cargo run.\nThe command is run after a successful build with the executable path passed as the first argument.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#runners",
    "href": "41_boot.html#runners",
    "title": "Boot",
    "section": "Runners",
    "text": "Runners\n\nThe bootimage runner command is specifically designed to be usable as a runner executable.\nIt links the given executable with the project‚Äôs bootloader dependency and then launches QEMU.\nSee the Readme of bootimage for more details and possible configuration options.\nNow we can use cargo run to compile our kernel and boot it in QEMU!",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#footnotes",
    "href": "41_boot.html#footnotes",
    "title": "Boot",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis would be cool and fun and we should do it sometime, we just have other things to do!‚Ü©Ô∏é",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "12_split_at.html",
    "href": "12_split_at.html",
    "title": "Splits",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#homework",
    "href": "12_split_at.html#homework",
    "title": "Splits",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#citation",
    "href": "12_split_at.html#citation",
    "title": "Splits",
    "section": "Citation",
    "text": "Citation\n\nCalling an Unsafe Function or Method\nIn a way, an OS is an unsafe function or method‚Ä¶ (this is a stretch)",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#requirements",
    "href": "12_split_at.html#requirements",
    "title": "Splits",
    "section": "Requirements",
    "text": "Requirements\n\nUpdate repository for this course.\nNew crate for this homework.\nFollow the write-up",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#unsafe",
    "href": "12_split_at.html#unsafe",
    "title": "Splits",
    "section": "Unsafe",
    "text": "Unsafe\n\nHere is an unsafe function named dangerous that doesn‚Äôt do anything in its body:\n\n    unsafe fn dangerous() {}\n\n    unsafe {\n        dangerous();\n    }\n\nWe must call the dangerous function within a separate unsafe block.\nIf we try to call dangerous without the unsafe block, we‚Äôll get an error.",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#creating-a-safe-abstraction-over-unsafe-code",
    "href": "12_split_at.html#creating-a-safe-abstraction-over-unsafe-code",
    "title": "Splits",
    "section": "Creating a Safe Abstraction over Unsafe Code",
    "text": "Creating a Safe Abstraction over Unsafe Code\n\nJust because a function contains unsafe code doesn‚Äôt mean we need to mark the entire function as unsafe.\n\nThis blew my mind.\n\nIn fact, wrapping unsafe code in a safe function is a common abstraction.\nAs an example, let‚Äôs study the split_at_mut function from the standard library, which requires some unsafe code.\n\n\nNo Safe Way\nPeople scared of Portland refer to Safeway I shop at as the ‚ÄúUnsafeway‚Äù which I think is hilarious\n\nWe‚Äôll explore how we might implement it.\nThis safe method is defined on mutable slices:\n\nIt takes one slice and makes it two by splitting the slice at the index given as an argument.\n\nHere‚Äôs an example.\n\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n\n    let (a, b) = r.split_at_mut(3);\n\nThere‚Äôs no safe way to do this.\n\nThis won‚Äôt work\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n    let len = values.len();\n\n    assert!(mid &lt;= len);\n\n    (&mut values[..mid], &mut values[mid..])\n}\n\nIt explodes:\n\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n --&gt; src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n  |                         - let's call the lifetime of this reference `'1`\n...\n6 |     (&mut values[..mid], &mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for `'1`\n  |\n  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n\n\nEnter the Borrow Checker\n\nRust‚Äôs borrow checker can‚Äôt understand that we‚Äôre borrowing different parts of the slice\n\nIt only knows that we‚Äôre borrowing from the same slice twice.\n\nBorrowing different parts of a slice is fundamentally okay because the two slices aren‚Äôt overlapping, but‚Ä¶\n\nrustc isn‚Äôt smart enough to know this.\n\nWhen we know code is okay, but Rust doesn‚Äôt, it‚Äôs time to reach for unsafe code.\n\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n\n    let ptr = values.as_mut_ptr();\n    let mid = std::cmp::min(values.len(), mid);\n\n    unsafe {\n        (\n            std::slice::from_raw_parts_mut(ptr, mid),\n            std::slice::from_raw_parts_mut(ptr.add(mid), values.len() - mid),\n        )\n    }\n}",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "52_graphics.html",
    "href": "52_graphics.html",
    "title": "Graphics",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#homework",
    "href": "52_graphics.html#homework",
    "title": "Graphics",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#requirements",
    "href": "52_graphics.html#requirements",
    "title": "Graphics",
    "section": "Requirements",
    "text": "Requirements\nBe advised this is a multistage lab that is intended to be interesting rather than easy.\n\nCreate a src/colors.rs to display all background colors.\nDisplay and screendump the background colors to .ppm\nExtract hex values from the .ppm\nCreate a script to convert images from url to VGA buffer array\n\nDownload\nScale\nColor map\nOutput to src/colors/img.rs as a datatype of some kind.\n\nAdd a function to src/colors.rs to display the image in src/img.rs.\n\nAnd call the function from `src/main.rs",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#step-0",
    "href": "52_graphics.html#step-0",
    "title": "Graphics",
    "section": "Step 0",
    "text": "Step 0\n\nComplete the ‚ÄúFormat‚Äù lab.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#step-1",
    "href": "52_graphics.html#step-1",
    "title": "Graphics",
    "section": "Step 1",
    "text": "Step 1\n\nAdd a function to src/main.rs to display all background colors in qemu via the VGA buffer.\n\n\nFor this lab, we will display images using the VGA text buffer background color.\nTo do that, we need to know what colors we have.\nTo learn what colors we have, we will first display all of them.\n\n\nColors\n\nI created a new file.\n\nI am planning to not use it after the lab so I factored it out.\n\n\n\n\nsrc/colors.rs\n\npub fn colors() {\n    // I had 9 total lines here.\n    // 1 line was in an unsafe block (which was 3 lines total)\n}\n\n\n\nMain\n\nThere are two minor changes to main.\n\nI call colors in _start and nothing else.\nI add mod colors; early in the file.\n\n\n\n\nsrc/main.rs\n\n\u0016#![no_std]\n#![no_main]\n\nmod colors;\nmod vga;\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    colors::colors();\n    loop {}\n}\n\n\n\nYour task\n\nCreate 16 evenly sized columns, one for each background color, across the screen.\nDisplay no text.\nRecall that there are 80 horizontal by 25 vertical characters.\nRecall that there are 720 horizontal by 400 vertical pixels.\nI am creating the below example using hexcodes I extracted and raw HTML.\n\nIt is hardcoded to 720 \\(\\times\\) 400 and may look odd on some screens.\nIt is not an image.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIt is obviously trivial to extract color values from this.\nFortunately, you are still required to include a src/colors.rs in your 52 folder.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#step-2",
    "href": "52_graphics.html#step-2",
    "title": "Graphics",
    "section": "Step 2",
    "text": "Step 2\n\nDisplay and screendump the background colors to .ppm\n\n\nEasy step.\nOnce your qemu is displaying as above, you are ready to proceed.\n\n\nThe Monitor\n\nqemu has more features than I can recall anymore; most of them very cool.\nOne is the ‚ÄúMonitor‚Äù\nWithin the QEMU window, you can use\n\nCtrl+Alt+2\nFrom here, you can input a variety of commands.\n\nRead more\n\nAt least try help and have at least on thought about it.\n\nqemu is listed on a job ad for a Google position in Portland starting at 113k/yr as I type this.\n\n\n\n\nScreendump\n\nTry to following.\n\nYou can choose your own filename.\nI used dump.ppm\nYou will want to use .ppm\n\n\nscreendump dump.ppm\n\nQEMU documentation states:\n\n\nSave screen into PPM image filename.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#step-3",
    "href": "52_graphics.html#step-3",
    "title": "Graphics",
    "section": "Step 3",
    "text": "Step 3\n\nExtract hex values from the .ppm\n\n\nPPM files\n\nThe PPM file format is ancient and I‚Äôm not sure of the authoritative documentation.\nThis appears correct to me. https://netpbm.sourceforge.net/doc/ppm.html\nYou don‚Äôt need to dwell on it overlong but:\n\nThere is a header that gives the filetype, the size, and highest brightness value.\nThere‚Äôs a block write of pixels.\n\n\n\n\nhead\n\nIt is trivial to verify you have a well formed PPM file.\n\nWe use head to read the first \\(n\\) lines of a file.\nWe use -3 to specify that \\(n=3\\)\nOnly the first 3 lines are human readable.\n\n\nhead -3 dump.ppm\n\nIf you do not see the following, something went wrong.\n\nP6\n720 400\n255\n\nThis states that:\n\nYou have a PPM image of type P6, this is the most common format (there is a less used P3)\nYour image is 720 by 400 pixels\nBrightness is out of 255.\n\nFrom here I perceive 2 ‚Äúobvious‚Äù options.\n\nUse some combination of head, tail, hexdump and other command line utilities to extract all hex values.\nUse Python, NumPy, and PIL, all of which you likely have on your device, to extract all hex values.\nBe advised you can compute the precise location of the first instance of every color in either a .ppm file or a NumPy array as you have perfect knowledge about the number of pixels.\n\nThese two are free:\n\nimport numpy as np\nfrom PIL import Image\n\nIMG_NAME = \"dump.ppm\"\n\nimg = np.array(Image.open(IMG_NAME))\nprint(img[0][:10])\ncat dump.ppm | tail -1 | head -c4 | hexdump\n\nI ended up using Python here because I was going to use Python for the next step.\n\nUnless?",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#step-4",
    "href": "52_graphics.html#step-4",
    "title": "Graphics",
    "section": "Step 4",
    "text": "Step 4\n\nCreate a script to convert images from url to VGA buffer array\n\n\nDownload\nScale\nColor map\nOutput to src/img.rs as a (Rust) datatype of some kind.\n\nThe following instructions assume students will proceed using Python‚Äôs NumPy package. This fulfills a secondary learning objective of familiarity with vector operations that were discussed briefly here.\n\nAs a fun bit, you may want to set up your script to optionally accept a URL at command line.\n\nI did this, and it made testing a bit easier.\nI also had an IMG_URL pointed at something that would otherwise display if there was no argument.\n\n\n\n\n\n\n\n\nNoteExtension for Advanced Students\n\n\n\n\n\nAdvanced students will already be familiar with these operations and with Python. They should complete Step 4 in CUDA C++, fulfilling the extension learning objective of familiarity with GPU programming and bus operations as mediated by the host/device metaphor. If you do not have access to a physical NVIDIA GPU, I provide instructions on usage in Colab here.\nLearning CUDA is straight-forward and an all-around good time. Learning C++ is quite the opposite. By combining both, you can practice moderation.\nCUDA Programming Guide\n\n\n\n\nUse of Numpy\n\nDownload\nGiven this is an advanced class, I‚Äôm going to trust you to do the following without providing example code.\n\nRegard it as ‚Äúunsporting‚Äù to download a file and work with a local copy.\nUse requests to get an image by url.\n\nYou can read this\nYou can use this URL\n\nhttps://cd-public.github.io/ai101/images/photo-cat.jpg\nUse BytesIO to interpret the HTTP response as a file.\nUse PIL‚Äôs Image API to open the image.\n\nYou can read this\n\nCoerce the image to a NumPy array using NumPy.\n\n\nImages\nI only got .jpg and .webp to work for some reason, but it‚Äôs not a big deal and you aren‚Äôt required to learn PIL.\n\nI took this myself so it is definitely free to use.\n\nHer name is Ursula.\n\nhttps://cd-public.github.io/ai101/images/photo-cat.jpg\nThis is a wide picture that should be fine, from a tourism bureau.\n\nRead more\n\nhttps://www.leadvilletwinlakes.com/wp-content/themes/yootheme/cache/ba/View-of-Mount-Massive-LCTP-Cropped-scaled-ba58e696.webp\nAnd maybe the best for testing, an Adobe Stock rainbow.\n\nThe url looked unstable so I‚Äôm rehosting.\nHopefully I‚Äôm hosting stably.\n\nhttps://cd-rs.github.io/os/img/rainbow.jpg\n\n\n\n\n\nScale\n\nDo I look like I know how to scale images?\n\nProbably either sample or average.\nI don‚Äôt think I care.\n\nMy code scales to fit the VGA buffer horizontally.\n\nThen either ‚Äúsquish‚Äù or ‚Äústretch‚Äù vertically.\nYou could also crop horizontally.\n\nDoesn‚Äôt matter to me.\n\nRecall, the VGA buffer has more pixels than we are addressing.\nYou can only address characters, which are many pixels in size.\nYour image will be low resolution.\n\n\n\n\nColor Map\n\n\n\n\n\n\nNoteCode Structure Note\n\n\n\nI included my code extracting hex-values from dump.ppm here.\nI thought it made more sense than making a new file, it shared similar imports, and was only a few lines.\nPlus, if I run on another system, which may have a different color representation, I‚Äôll be able to quickly generate the .ppm and have no other steps!\n\n\n\nYou image will include colors that cannot be recognized by the VGA text buffer.\nYou will need to compute color distance between the\n\nColor you are trying to show, and\nThe 16 available colors you computed in a previous step.\n\nA naive approach would be to regard colors in 3-space with dimensions of R, G, and B values.\n\nThis is appropriate, but sub-optimal.\nSo it‚Äôs what I did.\n\n\n\n\n\n\n\n\nNoteExtension for Advanced Students\n\n\n\n\n\nAdvanced students will already be familiar with distance in \\(n\\)-space and hexcodes and should use a perceptually uniform color space. In this case, L*a*b.\nRead more\nThere is first class support in Python, I hear, and you can learn more from this poster, but one of Professor Brown‚Äôs undergraduate researchers.\nPoster\n\n\n\nYou are doing this in NumPy to take advantage of vectorized operations.\n\nRead more\nRegard it as ‚Äúunsporting‚Äù to use loops for a single pixel.\n\nI didn‚Äôt vectorize across the full pixel array because I converted to a string in the same stage (as a list comprehension).\nYou will want to look up ‚Äúargmin‚Äù.\n\n\n\n\nOutput\n\nI used a list comprehension to map my colormapper across the scaled pixel array, format to string, and write to a .rs file.\n\nYou are not required to use a single line, obviously.\n\nI want to show file sizes.\n\nI wrote only single lines of code (no blocks) with open lines between.\nIt was not minimized but it was not verbose either.\n\n5 imports\n4 ‚Äúconstants‚Äù\n\nPython doesn‚Äôt have constants.\n\n6 lines of executable code.\n\n$ wc url_to_rs.py src/colors/img.rs\n22   75  704 url_to_rs.py\n 0 2006 9257 src/colors/img.rs\n\nI wrote to src/colors/img.rs as it was I think the place a file used by src/colors.rs should be.\n\nI didn‚Äôt love this because I had to make a new directory.\n\nI just mkdir once rather than scripting this step.\n\nDo whatever you want here, as long as your url_to_rs.py writes to the right place.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "52_graphics.html#step-5",
    "href": "52_graphics.html#step-5",
    "title": "Graphics",
    "section": "Step 5",
    "text": "Step 5\n\nAdd a image() function to src/colors.rs that:\n\nReads the image data from src/colors/img.rs\nWrites the image data to the VGA text buffer as background colors.\n\nCall this function from src/main.rs\nLook at your image.\n\n\nExample\n\nHere is my result over the ‚ÄúMt. Massive‚Äù image from the tourism bureau.\n\n\nOriginal\n\nHosting cross-site.\n\n\n\n\nVGA Text Buffer\n\nExtracted to .ppm, converted to .png, converted to base64 and directly embedded.",
    "crumbs": [
      "Graphics"
    ]
  },
  {
    "objectID": "61_serial.html",
    "href": "61_serial.html",
    "title": "Serial",
    "section": "",
    "text": "We are trying to get automated testing working.\nWe can quickly open and close QEMU.\nWe want to blast QEMU to stdout\nAnd ideally not open QEMU.\nWe just recently turned to the serial port.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#recall",
    "href": "61_serial.html#recall",
    "title": "Serial",
    "section": "",
    "text": "We are trying to get automated testing working.\nWe can quickly open and close QEMU.\nWe want to blast QEMU to stdout\nAnd ideally not open QEMU.\nWe just recently turned to the serial port.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#serial-port",
    "href": "61_serial.html#serial-port",
    "title": "Serial",
    "section": "Serial Port",
    "text": "Serial Port\n\nEasy mode is a serial port\n\nAn old interface standard which is no longer found in modern computers.\n\nIt is easy to program and‚Ä¶\nQEMU can redirect the bytes sent over serial to the host.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#uart",
    "href": "61_serial.html#uart",
    "title": "Serial",
    "section": "UART",
    "text": "UART\n\nThe chips implementing a serial interface are called UARTs\n\nUniversal asynchronous receiver-transmitter\n\n\n\nIt was one of the earliest computer communication devices, used to attach teletypewriters for an operator console. It was also an early hardware system for the Internet.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#popular",
    "href": "61_serial.html#popular",
    "title": "Serial",
    "section": "Popular",
    "text": "Popular\n\nUART 16550 is popular, nominally, so we‚Äôll use that.\n\nThe various UARTs are all basically the same, like ASCII vs.¬†Code Page ???\n\nThere is, naturally, a uart_165001 crate.\n\nAdd it to your dependencies in the expect manner (in Cargo.toml).",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#todo",
    "href": "61_serial.html#todo",
    "title": "Serial",
    "section": "TODO",
    "text": "TODO\n# in Cargo.toml\n\n[dependencies]\nuart_16550 = \"0.2.0\"\nThe uart_16550 crate contains a SerialPort struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that, we create a new serial module with the following content:\n// in src/main.rs\n\nmod serial;\n// in src/serial.rs\n\nuse uart_16550::SerialPort;\nuse spin::Mutex;\nuse lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref SERIAL1: Mutex&lt;SerialPort&gt; = {\n        let mut serial_port = unsafe { SerialPort::new(0x3F8) };\n        serial_port.init();\n        Mutex::new(serial_port)\n    };\n}\nLike with the VGA text buffer, we use lazy_static and a spinlock to create a static writer instance. By using lazy_static we can ensure that the init method is called exactly once on its first use.\nLike the isa-debug-exit device, the UART is programmed using port I/O. Since the UART is more complex, it uses multiple I/O ports for programming different device registers. The unsafe SerialPort::new function expects the address of the first I/O port of the UART as an argument, from which it can calculate the addresses of all needed ports. We‚Äôre passing the port address 0x3F8, which is the standard port number for the first serial interface.\nTo make the serial port easily usable, we add serial_print! and serial_println! macros:\n// in src/serial.rs\n\n#[doc(hidden)]\npub fn _print(args: ::core::fmt::Arguments) {\n    use core::fmt::Write;\n    SERIAL1.lock().write_fmt(args).expect(\"Printing to serial failed\");\n}\n\n/// Prints to the host through the serial interface.\n#[macro_export]\nmacro_rules! serial_print {\n    ($($arg:tt)*) =&gt; {\n        $crate::serial::_print(format_args!($($arg)*));\n    };\n}\n\n/// Prints to the host through the serial interface, appending a newline.\n#[macro_export]\nmacro_rules! serial_println {\n    () =&gt; ($crate::serial_print!(\"\\n\"));\n    ($fmt:expr) =&gt; ($crate::serial_print!(concat!($fmt, \"\\n\")));\n    ($fmt:expr, $($arg:tt)*) =&gt; ($crate::serial_print!(\n        concat!($fmt, \"\\n\"), $($arg)*));\n}\nThe implementation is very similar to the implementation of our print and println macros. Since the SerialPort type already implements the fmt::Write trait, we don‚Äôt need to provide our own implementation.\nNow we can print to the serial interface instead of the VGA text buffer in our test code:\n// in src/main.rs\n\n#[cfg(test)]\nfn test_runner(tests: &[&dyn Fn()]) {\n    serial_println!(\"Running {} tests\", tests.len());\n    [‚Ä¶]\n}\n\n#[test_case]\nfn trivial_assertion() {\n    serial_print!(\"trivial assertion... \");\n    assert_eq!(1, 1);\n    serial_println!(\"[ok]\");\n}\nNote that the serial_println macro lives directly under the root namespace because we used the #[macro_export] attribute, so importing it through use crate::serial::serial_println will not work.\n\nQEMU Arguments\nTo see the serial output from QEMU, we need to use the -serial argument to redirect the output to stdout:\n# in Cargo.toml\n\n[package.metadata.bootimage]\ntest-args = [\n    \"-device\", \"isa-debug-exit,iobase=0xf4,iosize=0x04\", \"-serial\", \"stdio\"\n]\nWhen we run cargo test now, we see the test output directly in the console:\n&gt; cargo test\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a\nBuilding bootloader\n    Finished release [optimized + debuginfo] target(s) in 0.02s\nRunning: `qemu-system-x86_64 -drive format=raw,file=/‚Ä¶/target/x86_64-blog_os/debug/\n    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device\n    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`\nRunning 1 tests\ntrivial assertion... [ok]\nHowever, when a test fails, we still see the output inside QEMU because our panic handler still uses println. To simulate this, we can change the assertion in our trivial_assertion test to assert_eq!(0, 1):\n\n\n\nQEMU printing ‚ÄúHello World!‚Äù and ‚Äúpanicked at ‚Äòassertion failed: (left == right) left: 0, right: 1‚Äô, src/main.rs:55:5\n\n\nWe see that the panic message is still printed to the VGA buffer, while the other test output is printed to the serial port. The panic message is quite useful, so it would be useful to see it in the console too.\n\n\nPrint an Error Message on Panic\nTo exit QEMU with an error message on a panic, we can use conditional compilation to use a different panic handler in testing mode:\n// in src/main.rs\n\n// our existing panic handler\n#[cfg(not(test))] // new attribute\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n// our panic handler in test mode\n#[cfg(test)]\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    serial_println!(\"[failed]\\n\");\n    serial_println!(\"Error: {}\\n\", info);\n    exit_qemu(QemuExitCode::Failed);\n    loop {}\n}\nFor our test panic handler, we use serial_println instead of println and then exit QEMU with a failure exit code. Note that we still need an endless loop after the exit_qemu call because the compiler does not know that the isa-debug-exit device causes a program exit.\nNow QEMU also exits for failed tests and prints a useful error message on the console:\n&gt; cargo test\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a\nBuilding bootloader\n    Finished release [optimized + debuginfo] target(s) in 0.02s\nRunning: `qemu-system-x86_64 -drive format=raw,file=/‚Ä¶/target/x86_64-blog_os/debug/\n    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device\n    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`\nRunning 1 tests\ntrivial assertion... [failed]\n\nError: panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `1`', src/main.rs:65:5\nSince we see all test output on the console now, we no longer need the QEMU window that pops up for a short time. So we can hide it completely.\n\n\nHiding QEMU\nSince we report out the complete test results using the isa-debug-exit device and the serial port, we don‚Äôt need the QEMU window anymore. We can hide it by passing the -display none argument to QEMU:\n# in Cargo.toml\n\n[package.metadata.bootimage]\ntest-args = [\n    \"-device\", \"isa-debug-exit,iobase=0xf4,iosize=0x04\", \"-serial\", \"stdio\",\n    \"-display\", \"none\"\n]\nNow QEMU runs completely in the background and no window gets opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as CI services or SSH connections.\n\n\nTimeouts\nSince cargo test waits until the test runner exits, a test that never returns can block the test runner forever. That‚Äôs unfortunate, but not a big problem in practice since it‚Äôs usually easy to avoid endless loops. In our case, however, endless loops can occur in various situations:\n\nThe bootloader fails to load our kernel, which causes the system to reboot endlessly.\nThe BIOS/UEFI firmware fails to load the bootloader, which causes the same endless rebooting.\nThe CPU enters a loop {} statement at the end of some of our functions, for example because the QEMU exit device doesn‚Äôt work properly.\nThe hardware causes a system reset, for example when a CPU exception is not caught (explained in a future post).\n\nSince endless loops can occur in so many situations, the bootimage tool sets a timeout of 5 minutes for each test executable by default. If the test does not finish within this time, it is marked as failed and a ‚ÄúTimed Out‚Äù error is printed to the console. This feature ensures that tests that are stuck in an endless loop don‚Äôt block cargo test forever.\nYou can try it yourself by adding a loop {} statement in the trivial_assertion test. When you run cargo test, you see that the test is marked as timed out after 5 minutes. The timeout duration is configurable through a test-timeout key in the Cargo.toml:\n# in Cargo.toml\n\n[package.metadata.bootimage]\ntest-timeout = 300          # (in seconds)\nIf you don‚Äôt want to wait 5 minutes for the trivial_assertion test to time out, you can temporarily decrease the above value.\n\n\nInsert Printing Automatically\nOur trivial_assertion test currently needs to print its own status information using serial_print!/serial_println!:\n#[test_case]\nfn trivial_assertion() {\n    serial_print!(\"trivial assertion... \");\n    assert_eq!(1, 1);\n    serial_println!(\"[ok]\");\n}\nManually adding these print statements for every test we write is cumbersome, so let‚Äôs update our test_runner to print these messages automatically. To do that, we need to create a new Testable trait:\n// in src/main.rs\n\npub trait Testable {\n    fn run(&self) -&gt; ();\n}\nThe trick now is to implement this trait for all types T that implement the Fn() trait:\n// in src/main.rs\n\nimpl&lt;T&gt; Testable for T\nwhere\n    T: Fn(),\n{\n    fn run(&self) {\n        serial_print!(\"{}...\\t\", core::any::type_name::&lt;T&gt;());\n        self();\n        serial_println!(\"[ok]\");\n    }\n}\nWe implement the run function by first printing the function name using the any::type_name function. This function is implemented directly in the compiler and returns a string description of every type. For functions, the type is their name, so this is exactly what we want in this case. The \\t character is the tab character, which adds some alignment to the [ok] messages.\nAfter printing the function name, we invoke the test function through self(). This only works because we require that self implements the Fn() trait. After the test function returns, we print [ok] to indicate that the function did not panic.\nThe last step is to update our test_runner to use the new Testable trait:\n// in src/main.rs\n\n#[cfg(test)]\npub fn test_runner(tests: &[&dyn Testable]) { // new\n    serial_println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test.run(); // new\n    }\n    exit_qemu(QemuExitCode::Success);\n}\nThe only two changes are the type of the tests argument from &[&dyn Fn()] to &[&dyn Testable] and the fact that we now call test.run() instead of test().\nWe can now remove the print statements from our trivial_assertion test since they‚Äôre now printed automatically:\n// in src/main.rs\n\n#[test_case]\nfn trivial_assertion() {\n    assert_eq!(1, 1);\n}\nThe cargo test output now looks like this:\nRunning 1 tests\nblog_os::trivial_assertion...   [ok]\nThe function name now includes the full path to the function, which is useful when test functions in different modules have the same name. Otherwise, the output looks the same as before, but we no longer need to add print statements to our tests manually.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#testing-the-vga-buffer",
    "href": "61_serial.html#testing-the-vga-buffer",
    "title": "Serial",
    "section": "Testing the VGA Buffer",
    "text": "Testing the VGA Buffer\nNow that we have a working test framework, we can create a few tests for our VGA buffer implementation. First, we create a very simple test to verify that println works without panicking:\n// in src/vga_buffer.rs\n\n#[test_case]\nfn test_println_simple() {\n    println!(\"test_println_simple output\");\n}\nThe test just prints something to the VGA buffer. If it finishes without panicking, it means that the println invocation did not panic either.\nTo ensure that no panic occurs even if many lines are printed and lines are shifted off the screen, we can create another test:\n// in src/vga_buffer.rs\n\n#[test_case]\nfn test_println_many() {\n    for _ in 0..200 {\n        println!(\"test_println_many output\");\n    }\n}\nWe can also create a test function to verify that the printed lines really appear on the screen:\n// in src/vga_buffer.rs\n\n#[test_case]\nfn test_println_output() {\n    let s = \"Some test string that fits on a single line\";\n    println!(\"{}\", s);\n    for (i, c) in s.chars().enumerate() {\n        let screen_char = WRITER.lock().buffer.chars[BUFFER_HEIGHT - 2][i].read();\n        assert_eq!(char::from(screen_char.ascii_character), c);\n    }\n}\nThe function defines a test string, prints it using println, and then iterates over the screen characters of the static WRITER, which represents the VGA text buffer. Since println prints to the last screen line and then immediately appends a newline, the string should appear on line BUFFER_HEIGHT - 2.\nBy using enumerate, we count the number of iterations in the variable i, which we then use for loading the screen character corresponding to c. By comparing the ascii_character of the screen character with c, we ensure that each character of the string really appears in the VGA text buffer.\nAs you can imagine, we could create many more test functions. For example, a function that tests that no panic occurs when printing very long lines and that they‚Äôre wrapped correctly, or a function for testing that newlines, non-printable characters, and non-unicode characters are handled correctly.\nFor the rest of this post, however, we will explain how to create integration tests to test the interaction of different components together.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#integration-tests",
    "href": "61_serial.html#integration-tests",
    "title": "Serial",
    "section": "Integration Tests",
    "text": "Integration Tests\nThe convention for integration tests in Rust is to put them into a tests directory in the project root (i.e., next to the src directory). Both the default test framework and custom test frameworks will automatically pick up and execute all tests in that directory.\nAll integration tests are their own executables and completely separate from our main.rs. This means that each test needs to define its own entry point function. Let‚Äôs create an example integration test named basic_boot to see how it works in detail:\n// in tests/basic_boot.rs\n\n#![no_std]\n#![no_main]\n#![feature(custom_test_frameworks)]\n#![test_runner(crate::test_runner)]\n#![reexport_test_harness_main = \"test_main\"]\n\nuse core::panic::PanicInfo;\n\n#[unsafe(no_mangle)] // don't mangle the name of this function\npub extern \"C\" fn _start() -&gt; ! {\n    test_main();\n\n    loop {}\n}\n\nfn test_runner(tests: &[&dyn Fn()]) {\n    unimplemented!();\n}\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    loop {}\n}\nSince integration tests are separate executables, we need to provide all the crate attributes (no_std, no_main, test_runner, etc.) again. We also need to create a new entry point function _start, which calls the test entry point function test_main. We don‚Äôt need any cfg(test) attributes because integration test executables are never built in non-test mode.\nWe use the unimplemented macro that always panics as a placeholder for the test_runner function and just loop in the panic handler for now. Ideally, we want to implement these functions exactly as we did in our main.rs using the serial_println macro and the exit_qemu function. The problem is that we don‚Äôt have access to these functions since tests are built completely separately from our main.rs executable.\nIf you run cargo test at this stage, you will get an endless loop because the panic handler loops endlessly. You need to use the ctrl+c keyboard shortcut for exiting QEMU.\n\nCreate a Library\nTo make the required functions available to our integration test, we need to split off a library from our main.rs, which can be included by other crates and integration test executables. To do this, we create a new src/lib.rs file:\n// src/lib.rs\n\n#![no_std]\nLike the main.rs, the lib.rs is a special file that is automatically recognized by cargo. The library is a separate compilation unit, so we need to specify the #![no_std] attribute again.\nTo make our library work with cargo test, we need to also move the test functions and attributes from main.rs to lib.rs:\n// in src/lib.rs\n\n#![cfg_attr(test, no_main)]\n#![feature(custom_test_frameworks)]\n#![test_runner(crate::test_runner)]\n#![reexport_test_harness_main = \"test_main\"]\n\nuse core::panic::PanicInfo;\n\npub trait Testable {\n    fn run(&self) -&gt; ();\n}\n\nimpl&lt;T&gt; Testable for T\nwhere\n    T: Fn(),\n{\n    fn run(&self) {\n        serial_print!(\"{}...\\t\", core::any::type_name::&lt;T&gt;());\n        self();\n        serial_println!(\"[ok]\");\n    }\n}\n\npub fn test_runner(tests: &[&dyn Testable]) {\n    serial_println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test.run();\n    }\n    exit_qemu(QemuExitCode::Success);\n}\n\npub fn test_panic_handler(info: &PanicInfo) -&gt; ! {\n    serial_println!(\"[failed]\\n\");\n    serial_println!(\"Error: {}\\n\", info);\n    exit_qemu(QemuExitCode::Failed);\n    loop {}\n}\n\n/// Entry point for `cargo test`\n#[cfg(test)]\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    test_main();\n    loop {}\n}\n\n#[cfg(test)]\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    test_panic_handler(info)\n}\nTo make our test_runner available to executables and integration tests, we make it public and don‚Äôt apply the cfg(test) attribute to it. We also factor out the implementation of our panic handler into a public test_panic_handler function, so that it is available for executables too.\nSince our lib.rs is tested independently of our main.rs, we need to add a _start entry point and a panic handler when the library is compiled in test mode. By using the cfg_attr crate attribute, we conditionally enable the no_main attribute in this case.\nWe also move over the QemuExitCode enum and the exit_qemu function and make them public:\n// in src/lib.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u32)]\npub enum QemuExitCode {\n    Success = 0x10,\n    Failed = 0x11,\n}\n\npub fn exit_qemu(exit_code: QemuExitCode) {\n    use x86_64::instructions::port::Port;\n\n    unsafe {\n        let mut port = Port::new(0xf4);\n        port.write(exit_code as u32);\n    }\n}\nNow executables and integration tests can import these functions from the library and don‚Äôt need to define their own implementations. To also make println and serial_println available, we move the module declarations too:\n// in src/lib.rs\n\npub mod serial;\npub mod vga_buffer;\nWe make the modules public to make them usable outside of our library. This is also required for making our println and serial_println macros usable since they use the _print functions of the modules.\nNow we can update our main.rs to use the library:\n// in src/main.rs\n\n#![no_std]\n#![no_main]\n#![feature(custom_test_frameworks)]\n#![test_runner(blog_os::test_runner)]\n#![reexport_test_harness_main = \"test_main\"]\n\nuse core::panic::PanicInfo;\nuse blog_os::println;\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello World{}\", \"!\");\n\n    #[cfg(test)]\n    test_main();\n\n    loop {}\n}\n\n/// This function is called on panic.\n#[cfg(not(test))]\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[cfg(test)]\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    blog_os::test_panic_handler(info)\n}\nThe library is usable like a normal external crate. It is called blog_os, like our crate. The above code uses the blog_os::test_runner function in the test_runner attribute and the blog_os::test_panic_handler function in our cfg(test) panic handler. It also imports the println macro to make it available to our _start and panic functions.\nAt this point, cargo run and cargo test should work again. Of course, cargo test still loops endlessly (you can exit with ctrl+c). Let‚Äôs fix this by using the required library functions in our integration test.\n\n\nCompleting the Integration Test\nLike our src/main.rs, our tests/basic_boot.rs executable can import types from our new library. This allows us to import the missing components to complete our test:\n// in tests/basic_boot.rs\n\n#![test_runner(blog_os::test_runner)]\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    blog_os::test_panic_handler(info)\n}\nInstead of reimplementing the test runner, we use the test_runner function from our library by changing the #![test_runner(crate::test_runner)] attribute to #![test_runner(blog_os::test_runner)]. We then don‚Äôt need the test_runner stub function in basic_boot.rs anymore, so we can remove it. For our panic handler, we call the blog_os::test_panic_handler function like we did in our main.rs.\nNow cargo test exits normally again. When you run it, you will see that it builds and runs the tests for our lib.rs, main.rs, and basic_boot.rs separately after each other. For the main.rs and the basic_boot integration tests, it reports ‚ÄúRunning 0 tests‚Äù since these files don‚Äôt have any functions annotated with #[test_case].\nWe can now add tests to our basic_boot.rs. For example, we can test that println works without panicking, like we did in the VGA buffer tests:\n// in tests/basic_boot.rs\n\nuse blog_os::println;\n\n#[test_case]\nfn test_println() {\n    println!(\"test_println output\");\n}\nWhen we run cargo test now, we see that it finds and executes the test function.\nThe test might seem a bit useless right now since it‚Äôs almost identical to one of the VGA buffer tests. However, in the future, the _start functions of our main.rs and lib.rs might grow and call various initialization routines before running the test_main function, so that the two tests are executed in very different environments.\nBy testing println in a basic_boot environment without calling any initialization routines in _start, we can ensure that println works right after booting. This is important because we rely on it, e.g., for printing panic messages.\n\n\nFuture Tests\nThe power of integration tests is that they‚Äôre treated as completely separate executables. This gives them complete control over the environment, which makes it possible to test that the code interacts correctly with the CPU or hardware devices.\nOur basic_boot test is a very simple example of an integration test. In the future, our kernel will become much more featureful and interact with the hardware in various ways. By adding integration tests, we can ensure that these interactions work (and keep working) as expected. Some ideas for possible future tests are:\n\nCPU Exceptions: When the code performs invalid operations (e.g., divides by zero), the CPU throws an exception. The kernel can register handler functions for such exceptions. An integration test could verify that the correct exception handler is called when a CPU exception occurs or that the execution continues correctly after a resolvable exception.\nPage Tables: Page tables define which memory regions are valid and accessible. By modifying the page tables, it is possible to allocate new memory regions, for example when launching programs. An integration test could modify the page tables in the _start function and verify that the modifications have the desired effects in #[test_case] functions.\nUserspace Programs: Userspace programs are programs with limited access to the system‚Äôs resources. For example, they don‚Äôt have access to kernel data structures or to the memory of other programs. An integration test could launch userspace programs that perform forbidden operations and verify that the kernel prevents them all.\n\nAs you can imagine, many more tests are possible. By adding such tests, we can ensure that we don‚Äôt break them accidentally when we add new features to our kernel or refactor our code. This is especially important when our kernel becomes larger and more complex.\n\n\nTests that Should Panic\nThe test framework of the standard library supports a #[should_panic] attribute that allows constructing tests that should fail. This is useful, for example, to verify that a function fails when an invalid argument is passed. Unfortunately, this attribute isn‚Äôt supported in #[no_std] crates since it requires support from the standard library.\nWhile we can‚Äôt use the #[should_panic] attribute in our kernel, we can get similar behavior by creating an integration test that exits with a success error code from the panic handler. Let‚Äôs start creating such a test with the name should_panic:\n// in tests/should_panic.rs\n\n#![no_std]\n#![no_main]\n\nuse core::panic::PanicInfo;\nuse blog_os::{QemuExitCode, exit_qemu, serial_println};\n\n#[panic_handler]\nfn panic(_info: &PanicInfo) -&gt; ! {\n    serial_println!(\"[ok]\");\n    exit_qemu(QemuExitCode::Success);\n    loop {}\n}\nThis test is still incomplete as it doesn‚Äôt define a _start function or any of the custom test runner attributes yet. Let‚Äôs add the missing parts:\n// in tests/should_panic.rs\n\n#![feature(custom_test_frameworks)]\n#![test_runner(test_runner)]\n#![reexport_test_harness_main = \"test_main\"]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    test_main();\n\n    loop {}\n}\n\npub fn test_runner(tests: &[&dyn Fn()]) {\n    serial_println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test();\n        serial_println!(\"[test did not panic]\");\n        exit_qemu(QemuExitCode::Failed);\n    }\n    exit_qemu(QemuExitCode::Success);\n}\nInstead of reusing the test_runner from our lib.rs, the test defines its own test_runner function that exits with a failure exit code when a test returns without panicking (we want our tests to panic). If no test function is defined, the runner exits with a success error code. Since the runner always exits after running a single test, it does not make sense to define more than one #[test_case] function.\nNow we can create a test that should fail:\n// in tests/should_panic.rs\n\nuse blog_os::serial_print;\n\n#[test_case]\nfn should_fail() {\n    serial_print!(\"should_panic::should_fail...\\t\");\n    assert_eq!(0, 1);\n}\nThe test uses assert_eq to assert that 0 and 1 are equal. Of course, this fails, so our test panics as desired. Note that we need to manually print the function name using serial_print! here because we don‚Äôt use the Testable trait.\nWhen we run the test through cargo test --test should_panic we see that it is successful because the test panicked as expected. When we comment out the assertion and run the test again, we see that it indeed fails with the ‚Äútest did not panic‚Äù message.\nA significant drawback of this approach is that it only works for a single test function. With multiple #[test_case] functions, only the first function is executed because the execution cannot continue after the panic handler has been called. I currently don‚Äôt know of a good way to solve this problem, so let me know if you have an idea!\n\n\nNo Harness Tests\nFor integration tests that only have a single test function (like our should_panic test), the test runner isn‚Äôt really needed. For cases like this, we can disable the test runner completely and run our test directly in the _start function.\nThe key to this is to disable the harness flag for the test in the Cargo.toml, which defines whether a test runner is used for an integration test. When it‚Äôs set to false, both the default test runner and the custom test runner feature are disabled, so that the test is treated like a normal executable.\nLet‚Äôs disable the harness flag for our should_panic test:\n# in Cargo.toml\n\n[[test]]\nname = \"should_panic\"\nharness = false\nNow we vastly simplify our should_panic test by removing the test_runner-related code. The result looks like this:\n// in tests/should_panic.rs\n\n#![no_std]\n#![no_main]\n\nuse core::panic::PanicInfo;\nuse blog_os::{exit_qemu, serial_print, serial_println, QemuExitCode};\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    should_fail();\n    serial_println!(\"[test did not panic]\");\n    exit_qemu(QemuExitCode::Failed);\n    loop{}\n}\n\nfn should_fail() {\n    serial_print!(\"should_panic::should_fail...\\t\");\n    assert_eq!(0, 1);\n}\n\n#[panic_handler]\nfn panic(_info: &PanicInfo) -&gt; ! {\n    serial_println!(\"[ok]\");\n    exit_qemu(QemuExitCode::Success);\n    loop {}\n}\nWe now call the should_fail function directly from our _start function and exit with a failure exit code if it returns. When we run cargo test --test should_panic now, we see that the test behaves exactly as before.\nApart from creating should_panic tests, disabling the harness attribute can also be useful for complex integration tests, for example, when the individual test functions have side effects and need to be run in a specified order.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#summary",
    "href": "61_serial.html#summary",
    "title": "Serial",
    "section": "Summary",
    "text": "Summary\nTesting is a very useful technique to ensure that certain components have the desired behavior. Even if they cannot show the absence of bugs, they‚Äôre still a useful tool for finding them and especially for avoiding regressions.\nThis post explained how to set up a test framework for our Rust kernel. We used Rust‚Äôs custom test frameworks feature to implement support for a simple #[test_case] attribute in our bare-metal environment. Using the isa-debug-exit device of QEMU, our test runner can exit QEMU after running the tests and report the test status. To print error messages to the console instead of the VGA buffer, we created a basic driver for the serial port.\nAfter creating some tests for our println macro, we explored integration tests in the second half of the post. We learned that they live in the tests directory and are treated as completely separate executables. To give them access to the exit_qemu function and the serial_println macro, we moved most of our code into a library that can be imported by all executables and integration tests. Since integration tests run in their own separate environment, they make it possible to test interactions with the hardware or to create tests that should panic.\nWe now have a test framework that runs in a realistic environment inside QEMU. By creating more tests in future posts, we can keep our kernel maintainable when it becomes more complex.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#whats-next",
    "href": "61_serial.html#whats-next",
    "title": "Serial",
    "section": "What‚Äôs next?",
    "text": "What‚Äôs next?\nIn the next post, we will explore CPU exceptions. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called ‚Äúpage fault‚Äù). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "61_serial.html#timeout",
    "href": "61_serial.html#timeout",
    "title": "Serial",
    "section": "Timeout",
    "text": "Timeout\n\nThis is 700 lines of markdown source which usually is enough.\nOtherwise we proceed to ‚ÄúFormat‚Äù.",
    "crumbs": [
      "Serial"
    ]
  },
  {
    "objectID": "00_derust.rjs.html#announcements",
    "href": "00_derust.rjs.html#announcements",
    "title": "Derust",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to OS in Rust\n\nThe most famous systems topic‚Ä¶\nNow in Rust, your favorite language!\n\nAction Items:\n\nAccess the course webpage\nJoin the Discord!\n\nWe‚Äôll use CSSA.\n\nSet up Linux/Rust/Git."
  },
  {
    "objectID": "00_derust.rjs.html#homework",
    "href": "00_derust.rjs.html#homework",
    "title": "Derust",
    "section": "Homework",
    "text": "Homework\n\nThe first homework, wc, is ready now.\n\nMostly just Rust practice.\n\nDue Friday, 23 Jan at 1440 PT.\n\nFriday of next week."
  },
  {
    "objectID": "00_derust.rjs.html#today",
    "href": "00_derust.rjs.html#today",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust"
  },
  {
    "objectID": "00_derust.rjs.html#it-me",
    "href": "00_derust.rjs.html#it-me",
    "title": "Derust",
    "section": "It me",
    "text": "It me\n\nName\n\n(Prof.¬†)?Calvin\n\nCredentials\n\nB.A. Mathematics\nB.S., M.S., Ph.D.¬†Computer Science\n\nPronouns\n\nthey/them"
  },
  {
    "objectID": "00_derust.rjs.html#the-great-work",
    "href": "00_derust.rjs.html#the-great-work",
    "title": "Derust",
    "section": "The Great Work",
    "text": "The Great Work\n\nThesis Title\n\nMining Secure Behavior of Hardware Designs\n\nPlain English\n\nJust as there are bugs in code that makes software, modern hardware is also written in code and therefore may contain bugs. I find these bugs."
  },
  {
    "objectID": "00_derust.rjs.html#course-format",
    "href": "00_derust.rjs.html#course-format",
    "title": "Derust",
    "section": "Course Format",
    "text": "Course Format\n\nLecture Monday\nLab Wednesday\nHomework due Friday 1440 PT (the next Friday)\n\nYou should all meet on Friday.\n\nIn-class midterm week of 3/16\nYour OS is due whenever the final is scheduled.\n\nWaiting on registrar to announce."
  },
  {
    "objectID": "00_derust.rjs.html#grade-policy",
    "href": "00_derust.rjs.html#grade-policy",
    "title": "Derust",
    "section": "Grade Policy",
    "text": "Grade Policy\n\nYour voices have been heard:\n\n\nI think failing my systems class was the best thing that happened to me.\n\n\nThis course demanded strong self-motivation‚Ä¶ Thus, I didn‚Äôt learn as much as I might‚Äôve if grading mattered more."
  },
  {
    "objectID": "00_derust.rjs.html#specification-grading",
    "href": "00_derust.rjs.html#specification-grading",
    "title": "Derust",
    "section": "Specification Grading",
    "text": "Specification Grading\n\nBasically, I will assign some stuff but you don‚Äôt have to do all of it perfectly.\n\nNo partial credit, everything is boolean grading.\n\nI took distributions over final, midterm, and Lab/HW"
  },
  {
    "objectID": "00_derust.rjs.html#it-pays-to-get-as",
    "href": "00_derust.rjs.html#it-pays-to-get-as",
    "title": "Derust",
    "section": "It pays to get A‚Äôs",
    "text": "It pays to get A‚Äôs\n\n\n\nGrade\nRequirements\n\n\n\n\nA\nFinal meets spec\n\n\nA\n90% ave HW/Lab/Midterm, Final compiles\n\n\nA-\n90% ave HW/Lab, Midterm/Final compile\n\n\nA-\nMidterm meets spec, Final compiles"
  },
  {
    "objectID": "00_derust.rjs.html#but-bs-are-the-knees",
    "href": "00_derust.rjs.html#but-bs-are-the-knees",
    "title": "Derust",
    "section": "But B‚Äôs are the Knees",
    "text": "But B‚Äôs are the Knees\n\n\n\nGrade\nRequirements\n\n\n\n\nB+\n90% ave HW/Lab, Midterm compiles\n\n\nB\n80% ave HW/Lab, Midterm compiles\n\n\nB-\n80% ave HW/Lab"
  },
  {
    "objectID": "00_derust.rjs.html#these-may-earn-degrees",
    "href": "00_derust.rjs.html#these-may-earn-degrees",
    "title": "Derust",
    "section": "These may (???) earn degrees",
    "text": "These may (???) earn degrees\n\n\n\nGrade\nRequirements\n\n\n\n\nC\n80% ave Lab\n\n\nD\n60% ave Lab\n\n\nF\nAnything else"
  },
  {
    "objectID": "00_derust.rjs.html#lab-grading",
    "href": "00_derust.rjs.html#lab-grading",
    "title": "Derust",
    "section": "Lab Grading",
    "text": "Lab Grading\n\n‚ÄúA‚Äù (=100%)\n\nMeets spec by end of class\n\n‚ÄúB‚Äù (=90%)\n\nCompiles at end of class\n\n‚ÄúF‚Äù (=0%)\n\nAnything else"
  },
  {
    "objectID": "00_derust.rjs.html#hw-grading",
    "href": "00_derust.rjs.html#hw-grading",
    "title": "Derust",
    "section": "HW Grading",
    "text": "HW Grading\n\n‚ÄúA‚Äù (=100%)\n\nOn time\nPasses autograder.\n\nI lack confidence I can make excellent autograders for all stages, so give me some grace here.\n\n\n‚ÄúB‚Äù (=90%)\n\nOn time\nCompiles\n\n‚ÄúF‚Äù (=0%)\n\nAnything else"
  },
  {
    "objectID": "00_derust.rjs.html#final",
    "href": "00_derust.rjs.html#final",
    "title": "Derust",
    "section": "Final",
    "text": "Final\n\nCreate, document, and publish an operating system‚Ä¶ in Rust!\n\nFree-standing binary\nFaults/exceptions/interrupts\nMemory management"
  },
  {
    "objectID": "00_derust.rjs.html#late-work-policy",
    "href": "00_derust.rjs.html#late-work-policy",
    "title": "Derust",
    "section": "Late Work Policy",
    "text": "Late Work Policy\n\nLate work is not accepted.\n\nNo exceptions.\nThe specification grading framework incorpates tolerances.\nAn OS that meets spec by end-of-term is an A, always."
  },
  {
    "objectID": "00_derust.rjs.html#ai-policy",
    "href": "00_derust.rjs.html#ai-policy",
    "title": "Derust",
    "section": "AI Policy",
    "text": "AI Policy\n\nI would be shocked if it is helpful to you.\nIf you think it is helpful, that is probably not a good sign.\nYou can use it (I wouldn‚Äôt)"
  },
  {
    "objectID": "00_derust.rjs.html#collaboration-policy",
    "href": "00_derust.rjs.html#collaboration-policy",
    "title": "Derust",
    "section": "Collaboration Policy",
    "text": "Collaboration Policy\n\nYou should chat with each other.\nYou should write your own code.\nIf someone shows you something and you don‚Äôt understand it as well as code you write yourself, it is a waste of your time to use the code.\n\nBut not a waste as a way to learn."
  },
  {
    "objectID": "00_derust.rjs.html#a-la-151",
    "href": "00_derust.rjs.html#a-la-151",
    "title": "Derust",
    "section": "a la 151",
    "text": "a la 151\n\nThis term we will have sections\nMeet Friday 1310-1440\nMeant to help unpack learning in class and work on homework.\nSingle section/section-leader (Jimmy)\nMiss more than 4 sections and drop one ‚Äúbin‚Äù on specification grading.\n\nUnless excused."
  },
  {
    "objectID": "00_derust.rjs.html#the-hard-part",
    "href": "00_derust.rjs.html#the-hard-part",
    "title": "Derust",
    "section": "The Hard Part",
    "text": "The Hard Part\n\nAfter ~10 years of systems research I‚Äôve convinced myself only two things really matter:\n\nReferences, and\nRecursion\n\nRecursion isn‚Äôt too bad‚Ä¶\n\n&gt;&gt;&gt; exp = lambda b, n : b if n == 1 else b*exp(b,n-1)\n&gt;&gt;&gt; exp(2,8)\n256\n\nCovered in 271 and possibly 351 and no longer interesting on its own, though will be used."
  },
  {
    "objectID": "00_derust.rjs.html#references",
    "href": "00_derust.rjs.html#references",
    "title": "Derust",
    "section": "References",
    "text": "References\n\nReferences are a beast, but without them nothing makes sense!\n\n\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; def addx():\n...     x += 1\n...\n&gt;&gt;&gt; addx()\nUnboundLocalError:\n&lt;blah blah blah error messages&gt;\n\n&gt;&gt;&gt; x = [1]\n&gt;&gt;&gt; def addx():\n...     x[0] += 1\n...\n&gt;&gt;&gt; addx()\n&gt;&gt;&gt; x\n[2]"
  },
  {
    "objectID": "00_derust.rjs.html#insight",
    "href": "00_derust.rjs.html#insight",
    "title": "Derust",
    "section": "Insight",
    "text": "Insight\n\nDefinition:\n\nReferences: Values that are meaningful only as keys to values in key-value memory storage, as a memory addresses.\n\nImportance:\n\nThis key-value storage is a service provided by the operating system!"
  },
  {
    "objectID": "00_derust.rjs.html#python-and-oses",
    "href": "00_derust.rjs.html#python-and-oses",
    "title": "Derust",
    "section": "Python and OSes",
    "text": "Python and OSes\n\nWhy not .py (.js, .java, .cs, .cpp, etc)?\n\nThese languages assume an underlying OS (or VM or browser).\nThere is more to life than running code other people wrote.\nGood languages (except Java) but not for us\nThe other systems language is C (and maybe C++)"
  },
  {
    "objectID": "00_derust.rjs.html#rust-and-references",
    "href": "00_derust.rjs.html#rust-and-references",
    "title": "Derust",
    "section": "Rust and References",
    "text": "Rust and References\n\nRust:\n\nObscures references, but‚Ä¶\nDoes not obscure memory.\n\nThis is good!\n\nMemory matters, but pointers are historical accident.\n\nYou should probably use Rust in every application where correctness or performance matters."
  },
  {
    "objectID": "00_derust.rjs.html#rust-and-recursion",
    "href": "00_derust.rjs.html#rust-and-recursion",
    "title": "Derust",
    "section": "Rust and Recursion",
    "text": "Rust and Recursion\n\nSeparately, Rust is built on one of the most exciting ongoing computer science research efforts:\nLLVM (stands for LLVM)\nBasically, a way of turning human-readable code into machine-executable code.\n\nVery good at turning recursion into iteration and/or vice versa.\n\nThis term, we benefit from LLVM in that we can make Rust programs for platforms without an underlying OS."
  },
  {
    "objectID": "00_derust.rjs.html#citation",
    "href": "00_derust.rjs.html#citation",
    "title": "Derust",
    "section": "Citation",
    "text": "Citation\n\nWe will follow ‚ÄúPhilipp Oppermann‚Äôs blog‚Äù ‚ÄúWriting an OS in Rust‚Äù version 2.\nRead more."
  },
  {
    "objectID": "00_derust.rjs.html#bare-bones",
    "href": "00_derust.rjs.html#bare-bones",
    "title": "Derust",
    "section": "Bare Bones",
    "text": "Bare Bones\n\nA binary that doesn‚Äôt require an underlying OS.\nSomething that (1) runs and (2) prints.\nSimple I/O\nUnit and integration testing."
  },
  {
    "objectID": "00_derust.rjs.html#interrupts",
    "href": "00_derust.rjs.html#interrupts",
    "title": "Derust",
    "section": "Interrupts",
    "text": "Interrupts\n\nCPU Exceptions\n\nLike division by zero.\n\nDouble faults\n\nFaults while handling a fault.\n\nHardware interrupts\n\nLike I/O"
  },
  {
    "objectID": "00_derust.rjs.html#memory-management",
    "href": "00_derust.rjs.html#memory-management",
    "title": "Derust",
    "section": "Memory Management",
    "text": "Memory Management\n\nPaging\nPage tables\n\nTogether, how to find things you saved for a while.\n\nThe heap\nHeap allocation.\n\nTogether, how to find things you saved while working."
  },
  {
    "objectID": "00_derust.rjs.html#final-examproject",
    "href": "00_derust.rjs.html#final-examproject",
    "title": "Derust",
    "section": "Final Exam/Project",
    "text": "Final Exam/Project\n\nImplement Minimal OS in Rust\n\nIndividual\nUnder version control\nCompiles and runs and is tested"
  },
  {
    "objectID": "00_derust.rjs.html#vim",
    "href": "00_derust.rjs.html#vim",
    "title": "Derust",
    "section": "Vim",
    "text": "Vim\n\nYou should use vim or another console-based editor as a component of your learning in this class.\nThis will not be assessed (how can it be) but will likely be expected of you in life.\nI will live-code in vim probably.\n\nThis will be painful, but that is okay."
  },
  {
    "objectID": "00_derust.rjs.html#rust-features",
    "href": "00_derust.rjs.html#rust-features",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#options",
    "href": "00_derust.rjs.html#options",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes code makes sense.\nMAD\n\nfrom numpy import uint64\n\n# Multiply-add operation\ndef mad(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a + b * c"
  },
  {
    "objectID": "00_derust.rjs.html#options-1",
    "href": "00_derust.rjs.html#options-1",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes it doesn‚Äôt.\nThis needn‚Äôt return a positive value!\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a - b * c"
  },
  {
    "objectID": "00_derust.rjs.html#options-2",
    "href": "00_derust.rjs.html#options-2",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems‚Ä¶\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None"
  },
  {
    "objectID": "00_derust.rjs.html#options-3",
    "href": "00_derust.rjs.html#options-3",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems‚Ä¶\n\nfrom numpy import uint64\nfrom typing import Union\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; Union[None,uint64]:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None"
  },
  {
    "objectID": "00_derust.rjs.html#options-4",
    "href": "00_derust.rjs.html#options-4",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nEver wish there was a nice way to handle a Union[None,x] \\(\\forall x\\)?\nIt‚Äôs the option type:\n\nfn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {\n    if denominator == 0.0 {\n        None\n    } else {\n        Some(numerator / denominator)\n    }\n}"
  },
  {
    "objectID": "00_derust.rjs.html#rust-features-1",
    "href": "00_derust.rjs.html#rust-features-1",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#results",
    "href": "00_derust.rjs.html#results",
    "title": "Derust",
    "section": "Results",
    "text": "Results\n\nResults are basically options that incorporate error handling.\n\n// Linux Kernel Versions, latest is 6\nfn check_version(val: u8) -&gt; Result&lt;u8, &'static str&gt; {\n    if val &lt; 7 {\n        return Ok(val);\n    } else {\n        return Err(\"Not yet released.\")\n    }\n}"
  },
  {
    "objectID": "00_derust.rjs.html#check-it",
    "href": "00_derust.rjs.html#check-it",
    "title": "Derust",
    "section": "Check it",
    "text": "Check it\n\nAdd main.\n\n\n\nsrc/main.rs\n\n\u0016fn main() {\n    dbg!(check_version(4));\n    dbg!(check_version(7));\n}\n\n\ncargo r\n\n[src/main.rs:10:5] check_version(4) = Ok(\n    4,\n)\n[src/main.rs:11:5] check_version(7) = Err(\n    \"Not yet released.\",\n)"
  },
  {
    "objectID": "00_derust.rjs.html#rust-features-2",
    "href": "00_derust.rjs.html#rust-features-2",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#std",
    "href": "00_derust.rjs.html#std",
    "title": "Derust",
    "section": "std",
    "text": "std\n\nOptions, results, and more fun things, like vectors, are all part of std\n\n\nThe Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec&lt;T&gt; and Option&lt;T&gt;, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things."
  },
  {
    "objectID": "00_derust.rjs.html#iterators",
    "href": "00_derust.rjs.html#iterators",
    "title": "Derust",
    "section": "Iterators",
    "text": "Iterators\n\nAn iterator is pretty much a for-each loop, the Python loop type.\n\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n\nOh look, vec! from std"
  },
  {
    "objectID": "00_derust.rjs.html#closures",
    "href": "00_derust.rjs.html#closures",
    "title": "Derust",
    "section": "Closures",
    "text": "Closures\n\nA closure is pretty much a lambda function, like the Python lambda keyword.\n\nfn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n\nNo one can stop you from writing fn‚Äôs, not even people who actually know Rust!"
  },
  {
    "objectID": "00_derust.rjs.html#pattern-matching",
    "href": "00_derust.rjs.html#pattern-matching",
    "title": "Derust",
    "section": "Pattern Matching",
    "text": "Pattern Matching\n\nThe language designers intend options (and results) to be handled as follows:\n\nfn main() {\n    let s = \"Hello, world\";\n    match s.chars().nth(11) {\n        Some(c) =&gt; println!(\"The 11th character is {:?}\", c),\n        None =&gt; println!(\"String `s` is fewer than 11 characters in length\"),\n    }\n}\n\nBasically, if-else is ‚Äúun-Rust-like‚Äù most of the time."
  },
  {
    "objectID": "00_derust.rjs.html#formatting",
    "href": "00_derust.rjs.html#formatting",
    "title": "Derust",
    "section": "Formatting",
    "text": "Formatting\n\nprint!, println!, and format! are all nice ways to work with strings.\nHandy if you are an OS and want to interface with a human.\nAssuming you (the OS) know how to display text.\n\nWe‚Äôll get there.\n\n\nformat!(\"test\");                             // =&gt; \"test\"\nformat!(\"hello {}\", \"world!\");               // =&gt; \"hello world!\"\nformat!(\"x = {}, y = {val}\", 10, val = 30);  // =&gt; \"x = 10, y = 30\"\nlet (x, y) = (1, 2);\nformat!(\"{x} + {y} = 3\");                    // =&gt; \"1 + 2 = 3\"\n\nSimilar to Python f-strings and also every other language."
  },
  {
    "objectID": "00_derust.rjs.html#read-more",
    "href": "00_derust.rjs.html#read-more",
    "title": "Derust",
    "section": "Read More",
    "text": "Read More\n\nI use most of these language features in two extended examples.\n\nHex reader\nFibonacci"
  },
  {
    "objectID": "00_derust.rjs.html#rust-features-3",
    "href": "00_derust.rjs.html#rust-features-3",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#ownership",
    "href": "00_derust.rjs.html#ownership",
    "title": "Derust",
    "section": "Ownership",
    "text": "Ownership\n\nBig topic.\nBig deal.\nLearn by doing.\nQuick example."
  },
  {
    "objectID": "00_derust.rjs.html#size",
    "href": "00_derust.rjs.html#size",
    "title": "Derust",
    "section": "Size",
    "text": "Size\n\nVersus e.g.¬†u8 which was a fixed size.\nA string is not.\n\n// String of length 0\nlet s = \"\"; \n// Complete text of Bhagavad Gita\nlet t = \"Dhritarashtra said: O Sanjay, after gathering on the holy field of Kurukshetra, and desiring to fight, what did my sons and the sons of Pandu do? ...\n\nAnd in fact, if we implemented Python integers in Rust, they would follow similar rules.\n\nAnything that has no bounded upper size, basically."
  },
  {
    "objectID": "00_derust.rjs.html#ownership-rules",
    "href": "00_derust.rjs.html#ownership-rules",
    "title": "Derust",
    "section": "Ownership Rules",
    "text": "Ownership Rules\n\nEach value in Rust has an owner.\nThere can only be one owner at a time.\nWhen the owner goes out of scope, the value will be dropped."
  },
  {
    "objectID": "00_derust.rjs.html#scope",
    "href": "00_derust.rjs.html#scope",
    "title": "Derust",
    "section": "Scope",
    "text": "Scope\n\nQuoth Rust Book:\n\n{                      // s is not valid here, since it's not yet declared\n    let s = \"hello\";   // s is valid from this point forward\n\n    // do stuff with s\n}                      // this scope is now over, and s is no longer valid\n\nYou can experimentally verify each of the claims.\nBasically, the memory associated with s exists at some time points, but not others.\nThink: Address of building that hasn‚Äôt been made/has been condemned."
  },
  {
    "objectID": "00_derust.rjs.html#capital-s-string",
    "href": "00_derust.rjs.html#capital-s-string",
    "title": "Derust",
    "section": "Capital S String",
    "text": "Capital S String\n\nCapital S String is closer to data structure than a data type in some ways:\n\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{s}\"); // this will print `hello, world!`\n\nIt accepts a push operation a la a queue/stack/list, and must be initialized with a function call.\nA String is mutable, a literal is not."
  },
  {
    "objectID": "00_derust.rjs.html#its-confusing",
    "href": "00_derust.rjs.html#its-confusing",
    "title": "Derust",
    "section": "It‚Äôs confusing",
    "text": "It‚Äôs confusing\n\nThis leads to some un-Pythonic behavior.\nWe compare fixed size and variable size types, which have distinct behavior\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis doesn‚Äôt.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s;\n    println!(\"{s}\")\n}"
  },
  {
    "objectID": "00_derust.rjs.html#whats-happening",
    "href": "00_derust.rjs.html#whats-happening",
    "title": "Derust",
    "section": "What‚Äôs happening?",
    "text": "What‚Äôs happening?\n\ns passes ‚Äúout of scope‚Äù once its value is assigned to t.\nThereafter, there is no declared variable of name s.\nBut this only happens to some types.\n\nIt is unbounded types, but it‚Äôs unclear that e.g.¬†String::from(\"6\") isn‚Äôt a fixed width string of lenth 1 (to me at least)."
  },
  {
    "objectID": "00_derust.rjs.html#clone",
    "href": "00_derust.rjs.html#clone",
    "title": "Derust",
    "section": "Clone",
    "text": "Clone\n\nMy secret inside source with a real job (e.g.¬†not professor) who writes Rust and also thought this was a bit silly:\n\n\nWhenever I use Rust, I just always .clone and when someone asks me about it, I say that‚Äôs a performance optimization for latter.\n\n\nRust says the same thing, actually:\n\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n6 |     let t = s.clone();\n  |              ++++++++"
  },
  {
    "objectID": "00_derust.rjs.html#example",
    "href": "00_derust.rjs.html#example",
    "title": "Derust",
    "section": "Example",
    "text": "Example\n\nIt is reasonable to use .clone on capital S String for e.g.¬†Wordle, as needed.\nAs a challenge, don‚Äôt use .clone (you don‚Äôt need it)\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis works.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s.clone();\n    println!(\"{s}\")\n}"
  },
  {
    "objectID": "00_derust.rjs.html#today-1",
    "href": "00_derust.rjs.html#today-1",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust"
  },
  {
    "objectID": "00_derust.html",
    "href": "00_derust.html",
    "title": "Derust",
    "section": "",
    "text": "Welcome to OS in Rust\n\nThe most famous systems topic‚Ä¶\nNow in Rust, your favorite language!\n\nAction Items:\n\nAccess the course webpage\nJoin the Discord!\n\nWe‚Äôll use CSSA.\n\nSet up Linux/Rust/Git.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#announcements",
    "href": "00_derust.html#announcements",
    "title": "Derust",
    "section": "",
    "text": "Welcome to OS in Rust\n\nThe most famous systems topic‚Ä¶\nNow in Rust, your favorite language!\n\nAction Items:\n\nAccess the course webpage\nJoin the Discord!\n\nWe‚Äôll use CSSA.\n\nSet up Linux/Rust/Git.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#homework",
    "href": "00_derust.html#homework",
    "title": "Derust",
    "section": "Homework",
    "text": "Homework\n\nThe first homework, wc, is ready now.\n\nMostly just Rust practice.\n\nDue Friday, 23 Jan at 1440 PT.\n\nFriday of next week.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#today",
    "href": "00_derust.html#today",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#it-me",
    "href": "00_derust.html#it-me",
    "title": "Derust",
    "section": "It me",
    "text": "It me\n\nName\n\n(Prof.¬†)?Calvin\n\nCredentials\n\nB.A. Mathematics\nB.S., M.S., Ph.D.¬†Computer Science\n\nPronouns\n\nthey/them",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#the-great-work",
    "href": "00_derust.html#the-great-work",
    "title": "Derust",
    "section": "The Great Work",
    "text": "The Great Work\n\nThesis Title\n\nMining Secure Behavior of Hardware Designs\n\nPlain English\n\nJust as there are bugs in code that makes software, modern hardware is also written in code and therefore may contain bugs. I find these bugs.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#course-format",
    "href": "00_derust.html#course-format",
    "title": "Derust",
    "section": "Course Format",
    "text": "Course Format\n\nLecture Monday\nLab Wednesday\nHomework due Friday 1440 PT (the next Friday)\n\nYou should all meet on Friday.\n\nIn-class midterm week of 3/16\nYour OS is due whenever the final is scheduled.\n\nWaiting on registrar to announce.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#grade-policy",
    "href": "00_derust.html#grade-policy",
    "title": "Derust",
    "section": "Grade Policy",
    "text": "Grade Policy\n\nYour voices have been heard:\n\n\nI think failing my systems class was the best thing that happened to me.\n\n\nThis course demanded strong self-motivation‚Ä¶ Thus, I didn‚Äôt learn as much as I might‚Äôve if grading mattered more.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#specification-grading",
    "href": "00_derust.html#specification-grading",
    "title": "Derust",
    "section": "Specification Grading",
    "text": "Specification Grading\n\nBasically, I will assign some stuff but you don‚Äôt have to do all of it perfectly.\n\nNo partial credit, everything is boolean grading.\n\nI took distributions over final, midterm, and Lab/HW",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#it-pays-to-get-as",
    "href": "00_derust.html#it-pays-to-get-as",
    "title": "Derust",
    "section": "It pays to get A‚Äôs",
    "text": "It pays to get A‚Äôs\n\n\n\nGrade\nRequirements\n\n\n\n\nA\nFinal meets spec\n\n\nA\n90% ave HW/Lab/Midterm, Final compiles\n\n\nA-\n90% ave HW/Lab, Midterm/Final compile\n\n\nA-\nMidterm meets spec, Final compiles",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#but-bs-are-the-knees",
    "href": "00_derust.html#but-bs-are-the-knees",
    "title": "Derust",
    "section": "But B‚Äôs are the Knees",
    "text": "But B‚Äôs are the Knees\n\n\n\nGrade\nRequirements\n\n\n\n\nB+\n90% ave HW/Lab, Midterm compiles\n\n\nB\n80% ave HW/Lab, Midterm compiles\n\n\nB-\n80% ave HW/Lab",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#these-may-earn-degrees",
    "href": "00_derust.html#these-may-earn-degrees",
    "title": "Derust",
    "section": "These may (???) earn degrees",
    "text": "These may (???) earn degrees\n\n\n\nGrade\nRequirements\n\n\n\n\nC\n80% ave Lab\n\n\nD\n60% ave Lab\n\n\nF\nAnything else",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#lab-grading",
    "href": "00_derust.html#lab-grading",
    "title": "Derust",
    "section": "Lab Grading",
    "text": "Lab Grading\n\n‚ÄúA‚Äù (=100%)\n\nMeets spec by end of class\n\n‚ÄúB‚Äù (=90%)\n\nCompiles at end of class\n\n‚ÄúF‚Äù (=0%)\n\nAnything else",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#hw-grading",
    "href": "00_derust.html#hw-grading",
    "title": "Derust",
    "section": "HW Grading",
    "text": "HW Grading\n\n‚ÄúA‚Äù (=100%)\n\nOn time\nPasses autograder.\n\nI lack confidence I can make excellent autograders for all stages, so give me some grace here.\n\n\n‚ÄúB‚Äù (=90%)\n\nOn time\nCompiles\n\n‚ÄúF‚Äù (=0%)\n\nAnything else",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#final",
    "href": "00_derust.html#final",
    "title": "Derust",
    "section": "Final",
    "text": "Final\n\nCreate, document, and publish an operating system‚Ä¶ in Rust!\n\nFree-standing binary\nFaults/exceptions/interrupts\nMemory management",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#late-work-policy",
    "href": "00_derust.html#late-work-policy",
    "title": "Derust",
    "section": "Late Work Policy",
    "text": "Late Work Policy\n\nLate work is not accepted.\n\nNo exceptions.\nThe specification grading framework incorpates tolerances.\nAn OS that meets spec by end-of-term is an A, always.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#ai-policy",
    "href": "00_derust.html#ai-policy",
    "title": "Derust",
    "section": "AI Policy",
    "text": "AI Policy\n\nI would be shocked if it is helpful to you.\nIf you think it is helpful, that is probably not a good sign.\nYou can use it (I wouldn‚Äôt)",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#collaboration-policy",
    "href": "00_derust.html#collaboration-policy",
    "title": "Derust",
    "section": "Collaboration Policy",
    "text": "Collaboration Policy\n\nYou should chat with each other.\nYou should write your own code.\nIf someone shows you something and you don‚Äôt understand it as well as code you write yourself, it is a waste of your time to use the code.\n\nBut not a waste as a way to learn.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#a-la-151",
    "href": "00_derust.html#a-la-151",
    "title": "Derust",
    "section": "a la 151",
    "text": "a la 151\n\nThis term we will have sections\nMeet Friday 1310-1440\nMeant to help unpack learning in class and work on homework.\nSingle section/section-leader (Jimmy)\nMiss more than 4 sections and drop one ‚Äúbin‚Äù on specification grading.\n\nUnless excused.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#the-hard-part",
    "href": "00_derust.html#the-hard-part",
    "title": "Derust",
    "section": "The Hard Part",
    "text": "The Hard Part\n\nAfter ~10 years of systems research I‚Äôve convinced myself only two things really matter:\n\nReferences, and\nRecursion\n\nRecursion isn‚Äôt too bad‚Ä¶\n\n&gt;&gt;&gt; exp = lambda b, n : b if n == 1 else b*exp(b,n-1)\n&gt;&gt;&gt; exp(2,8)\n256\n\nCovered in 271 and possibly 351 and no longer interesting on its own, though will be used.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#references",
    "href": "00_derust.html#references",
    "title": "Derust",
    "section": "References",
    "text": "References\n\nReferences are a beast, but without them nothing makes sense!\n\n\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; def addx():\n...     x += 1\n...\n&gt;&gt;&gt; addx()\nUnboundLocalError:\n&lt;blah blah blah error messages&gt;\n\n&gt;&gt;&gt; x = [1]\n&gt;&gt;&gt; def addx():\n...     x[0] += 1\n...\n&gt;&gt;&gt; addx()\n&gt;&gt;&gt; x\n[2]",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#insight",
    "href": "00_derust.html#insight",
    "title": "Derust",
    "section": "Insight",
    "text": "Insight\n\nDefinition:\n\nReferences: Values that are meaningful only as keys to values in key-value memory storage, as a memory addresses.\n\nImportance:\n\nThis key-value storage is a service provided by the operating system!",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#python-and-oses",
    "href": "00_derust.html#python-and-oses",
    "title": "Derust",
    "section": "Python and OSes",
    "text": "Python and OSes\n\nWhy not .py (.js, .java, .cs, .cpp, etc)?\n\nThese languages assume an underlying OS (or VM or browser).\nThere is more to life than running code other people wrote.\nGood languages (except Java) but not for us\nThe other systems language is C (and maybe C++)",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-and-references",
    "href": "00_derust.html#rust-and-references",
    "title": "Derust",
    "section": "Rust and References",
    "text": "Rust and References\n\nRust:\n\nObscures references, but‚Ä¶\nDoes not obscure memory.\n\nThis is good!\n\nMemory matters, but pointers are historical accident.\n\nYou should probably use Rust in every application where correctness or performance matters.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-and-recursion",
    "href": "00_derust.html#rust-and-recursion",
    "title": "Derust",
    "section": "Rust and Recursion",
    "text": "Rust and Recursion\n\nSeparately, Rust is built on one of the most exciting ongoing computer science research efforts:\nLLVM (stands for LLVM)\nBasically, a way of turning human-readable code into machine-executable code.\n\nVery good at turning recursion into iteration and/or vice versa.\n\nThis term, we benefit from LLVM in that we can make Rust programs for platforms without an underlying OS.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#citation",
    "href": "00_derust.html#citation",
    "title": "Derust",
    "section": "Citation",
    "text": "Citation\n\nWe will follow ‚ÄúPhilipp Oppermann‚Äôs blog‚Äù ‚ÄúWriting an OS in Rust‚Äù version 2.\nRead more.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#bare-bones",
    "href": "00_derust.html#bare-bones",
    "title": "Derust",
    "section": "Bare Bones",
    "text": "Bare Bones\n\nA binary that doesn‚Äôt require an underlying OS.\nSomething that (1) runs and (2) prints.\nSimple I/O\nUnit and integration testing.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#interrupts",
    "href": "00_derust.html#interrupts",
    "title": "Derust",
    "section": "Interrupts",
    "text": "Interrupts\n\nCPU Exceptions\n\nLike division by zero.\n\nDouble faults\n\nFaults while handling a fault.\n\nHardware interrupts\n\nLike I/O",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#memory-management",
    "href": "00_derust.html#memory-management",
    "title": "Derust",
    "section": "Memory Management",
    "text": "Memory Management\n\nPaging\nPage tables\n\nTogether, how to find things you saved for a while.\n\nThe heap\nHeap allocation.\n\nTogether, how to find things you saved while working.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#final-examproject",
    "href": "00_derust.html#final-examproject",
    "title": "Derust",
    "section": "Final Exam/Project",
    "text": "Final Exam/Project\n\nImplement Minimal OS in Rust\n\nIndividual\nUnder version control\nCompiles and runs and is tested",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#vim",
    "href": "00_derust.html#vim",
    "title": "Derust",
    "section": "Vim",
    "text": "Vim\n\nYou should use vim or another console-based editor as a component of your learning in this class.\nThis will not be assessed (how can it be) but will likely be expected of you in life.\nI will live-code in vim probably.\n\nThis will be painful, but that is okay.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features",
    "href": "00_derust.html#rust-features",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options",
    "href": "00_derust.html#options",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes code makes sense.\nMAD\n\nfrom numpy import uint64\n\n# Multiply-add operation\ndef mad(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a + b * c",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-1",
    "href": "00_derust.html#options-1",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes it doesn‚Äôt.\nThis needn‚Äôt return a positive value!\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a - b * c",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-2",
    "href": "00_derust.html#options-2",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems‚Ä¶\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-3",
    "href": "00_derust.html#options-3",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems‚Ä¶\n\nfrom numpy import uint64\nfrom typing import Union\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; Union[None,uint64]:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-4",
    "href": "00_derust.html#options-4",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nEver wish there was a nice way to handle a Union[None,x] \\(\\forall x\\)?\nIt‚Äôs the option type:\n\nfn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {\n    if denominator == 0.0 {\n        None\n    } else {\n        Some(numerator / denominator)\n    }\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features-1",
    "href": "00_derust.html#rust-features-1",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#results",
    "href": "00_derust.html#results",
    "title": "Derust",
    "section": "Results",
    "text": "Results\n\nResults are basically options that incorporate error handling.\n\n// Linux Kernel Versions, latest is 6\nfn check_version(val: u8) -&gt; Result&lt;u8, &'static str&gt; {\n    if val &lt; 7 {\n        return Ok(val);\n    } else {\n        return Err(\"Not yet released.\")\n    }\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#check-it",
    "href": "00_derust.html#check-it",
    "title": "Derust",
    "section": "Check it",
    "text": "Check it\n\nAdd main.\n\n\n\nsrc/main.rs\n\n\u0016fn main() {\n    dbg!(check_version(4));\n    dbg!(check_version(7));\n}\n\n\ncargo r\n\n[src/main.rs:10:5] check_version(4) = Ok(\n    4,\n)\n[src/main.rs:11:5] check_version(7) = Err(\n    \"Not yet released.\",\n)",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features-2",
    "href": "00_derust.html#rust-features-2",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#std",
    "href": "00_derust.html#std",
    "title": "Derust",
    "section": "std",
    "text": "std\n\nOptions, results, and more fun things, like vectors, are all part of std\n\n\nThe Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec&lt;T&gt; and Option&lt;T&gt;, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#iterators",
    "href": "00_derust.html#iterators",
    "title": "Derust",
    "section": "Iterators",
    "text": "Iterators\n\nAn iterator is pretty much a for-each loop, the Python loop type.\n\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n\nOh look, vec! from std",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#closures",
    "href": "00_derust.html#closures",
    "title": "Derust",
    "section": "Closures",
    "text": "Closures\n\nA closure is pretty much a lambda function, like the Python lambda keyword.\n\nfn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n\nNo one can stop you from writing fn‚Äôs, not even people who actually know Rust!",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#pattern-matching",
    "href": "00_derust.html#pattern-matching",
    "title": "Derust",
    "section": "Pattern Matching",
    "text": "Pattern Matching\n\nThe language designers intend options (and results) to be handled as follows:\n\nfn main() {\n    let s = \"Hello, world\";\n    match s.chars().nth(11) {\n        Some(c) =&gt; println!(\"The 11th character is {:?}\", c),\n        None =&gt; println!(\"String `s` is fewer than 11 characters in length\"),\n    }\n}\n\nBasically, if-else is ‚Äúun-Rust-like‚Äù most of the time.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#formatting",
    "href": "00_derust.html#formatting",
    "title": "Derust",
    "section": "Formatting",
    "text": "Formatting\n\nprint!, println!, and format! are all nice ways to work with strings.\nHandy if you are an OS and want to interface with a human.\nAssuming you (the OS) know how to display text.\n\nWe‚Äôll get there.\n\n\nformat!(\"test\");                             // =&gt; \"test\"\nformat!(\"hello {}\", \"world!\");               // =&gt; \"hello world!\"\nformat!(\"x = {}, y = {val}\", 10, val = 30);  // =&gt; \"x = 10, y = 30\"\nlet (x, y) = (1, 2);\nformat!(\"{x} + {y} = 3\");                    // =&gt; \"1 + 2 = 3\"\n\nSimilar to Python f-strings and also every other language.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#read-more",
    "href": "00_derust.html#read-more",
    "title": "Derust",
    "section": "Read More",
    "text": "Read More\n\nI use most of these language features in two extended examples.\n\nHex reader\nFibonacci",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features-3",
    "href": "00_derust.html#rust-features-3",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#ownership",
    "href": "00_derust.html#ownership",
    "title": "Derust",
    "section": "Ownership",
    "text": "Ownership\n\nBig topic.\nBig deal.\nLearn by doing.\nQuick example.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#size",
    "href": "00_derust.html#size",
    "title": "Derust",
    "section": "Size",
    "text": "Size\n\nVersus e.g.¬†u8 which was a fixed size.\nA string is not.\n\n// String of length 0\nlet s = \"\"; \n// Complete text of Bhagavad Gita\nlet t = \"Dhritarashtra said: O Sanjay, after gathering on the holy field of Kurukshetra, and desiring to fight, what did my sons and the sons of Pandu do? ...\n\nAnd in fact, if we implemented Python integers in Rust, they would follow similar rules.\n\nAnything that has no bounded upper size, basically.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#ownership-rules",
    "href": "00_derust.html#ownership-rules",
    "title": "Derust",
    "section": "Ownership Rules",
    "text": "Ownership Rules\n\nEach value in Rust has an owner.\nThere can only be one owner at a time.\nWhen the owner goes out of scope, the value will be dropped.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#scope",
    "href": "00_derust.html#scope",
    "title": "Derust",
    "section": "Scope",
    "text": "Scope\n\nQuoth Rust Book:\n\n{                      // s is not valid here, since it's not yet declared\n    let s = \"hello\";   // s is valid from this point forward\n\n    // do stuff with s\n}                      // this scope is now over, and s is no longer valid\n\nYou can experimentally verify each of the claims.\nBasically, the memory associated with s exists at some time points, but not others.\nThink: Address of building that hasn‚Äôt been made/has been condemned.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#capital-s-string",
    "href": "00_derust.html#capital-s-string",
    "title": "Derust",
    "section": "Capital S String",
    "text": "Capital S String\n\nCapital S String is closer to data structure than a data type in some ways:\n\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{s}\"); // this will print `hello, world!`\n\nIt accepts a push operation a la a queue/stack/list, and must be initialized with a function call.\nA String is mutable, a literal is not.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#its-confusing",
    "href": "00_derust.html#its-confusing",
    "title": "Derust",
    "section": "It‚Äôs confusing",
    "text": "It‚Äôs confusing\n\nThis leads to some un-Pythonic behavior.\nWe compare fixed size and variable size types, which have distinct behavior\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis doesn‚Äôt.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s;\n    println!(\"{s}\")\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#whats-happening",
    "href": "00_derust.html#whats-happening",
    "title": "Derust",
    "section": "What‚Äôs happening?",
    "text": "What‚Äôs happening?\n\ns passes ‚Äúout of scope‚Äù once its value is assigned to t.\nThereafter, there is no declared variable of name s.\nBut this only happens to some types.\n\nIt is unbounded types, but it‚Äôs unclear that e.g.¬†String::from(\"6\") isn‚Äôt a fixed width string of lenth 1 (to me at least).",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#clone",
    "href": "00_derust.html#clone",
    "title": "Derust",
    "section": "Clone",
    "text": "Clone\n\nMy secret inside source with a real job (e.g.¬†not professor) who writes Rust and also thought this was a bit silly:\n\n\nWhenever I use Rust, I just always .clone and when someone asks me about it, I say that‚Äôs a performance optimization for latter.\n\n\nRust says the same thing, actually:\n\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n6 |     let t = s.clone();\n  |              ++++++++",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#example",
    "href": "00_derust.html#example",
    "title": "Derust",
    "section": "Example",
    "text": "Example\n\nIt is reasonable to use .clone on capital S String for e.g.¬†Wordle, as needed.\nAs a challenge, don‚Äôt use .clone (you don‚Äôt need it)\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis works.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s.clone();\n    println!(\"{s}\")\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#today-1",
    "href": "00_derust.html#today-1",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "50_text.rjs.html#announcements",
    "href": "50_text.rjs.html#announcements",
    "title": "Text",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nDo you text output yet?\n\nThe coolest assignment ever for a third week in a row.\nHow do I keep getting away with it."
  },
  {
    "objectID": "50_text.rjs.html#citations",
    "href": "50_text.rjs.html#citations",
    "title": "Text",
    "section": "Citations",
    "text": "Citations\n\nI tried to steal this but I thought it was too bad and changed everything.\n\nVGA Text Mode"
  },
  {
    "objectID": "50_text.rjs.html#vga-text-mode",
    "href": "50_text.rjs.html#vga-text-mode",
    "title": "Text",
    "section": "VGA Text Mode",
    "text": "VGA Text Mode\n\nWe recall VGA text mode from the homework.\n\nA simple way to print text to the screen.\n\nWe recall that Rust prints via a ‚Äúmacro‚Äù\nNow we:\n\nCreate an interface to encapsulating all unsafety in a separate module.\nWe also implement support for Rust‚Äôs formatting macros"
  },
  {
    "objectID": "50_text.rjs.html#the-buffer",
    "href": "50_text.rjs.html#the-buffer",
    "title": "Text",
    "section": "The Buffer",
    "text": "The Buffer\n\nTo print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware.\n\nA byte passing over a bus to fixed location will render as ASCII on a screen."
  },
  {
    "objectID": "50_text.rjs.html#d-or-2d",
    "href": "50_text.rjs.html#d-or-2d",
    "title": "Text",
    "section": "1d or 2d",
    "text": "1d or 2d\n\nThe VGA text buffer renders as two-dimensional array.\n\nAddressed as a one dimensional array.\nSafe to assume 25 rows and 80 columns.\nEach position is an ASCII (not unicode) character."
  },
  {
    "objectID": "50_text.rjs.html#format",
    "href": "50_text.rjs.html#format",
    "title": "Text",
    "section": "Format",
    "text": "Format\n\nDescribes a single screen character through the following format:\n\n\n\n\nBit(s)\nValue\n\n\n\n\n0-7\nASCII code point\n\n\n8-11\nForeground color\n\n\n12-14\nBackground color\n\n\n15\nBlink\n\n\n\n\nI did not see blinking."
  },
  {
    "objectID": "50_text.rjs.html#first-byte",
    "href": "50_text.rjs.html#first-byte",
    "title": "Text",
    "section": "First Byte",
    "text": "First Byte\n\nThe first byte represents the character that should be printed in the [ASCII encoding].\n\nWe recall we say many mentions of Python in firmware jobs.\n\npython3 -c \"[print(chr(a), ':', a) for a in range(ord('A'), ord('z')+1)]\""
  },
  {
    "objectID": "50_text.rjs.html#except",
    "href": "50_text.rjs.html#except",
    "title": "Text",
    "section": "Except",
    "text": "Except\n\nOkay it isn‚Äôt actually ASCII.\nIt‚Äôs code page 437\nWe think of it as an IBM specific ASCII extension and just use the ASCII subset."
  },
  {
    "objectID": "50_text.rjs.html#second-byte",
    "href": "50_text.rjs.html#second-byte",
    "title": "Text",
    "section": "Second Byte",
    "text": "Second Byte\n\nThe second byte defines how the character is displayed.\n\nThe first four bits define the foreground color.\nThe next three bits the background color\nNominally the last bit whether the character should blink.\n\nI did not see blinking.\nMay be a qemu thing I‚Äôm not sure."
  },
  {
    "objectID": "50_text.rjs.html#colors",
    "href": "50_text.rjs.html#colors",
    "title": "Text",
    "section": "Colors",
    "text": "Colors\n\nUsing octal.\n\n\n\n\nNumber\nColor\nBright\nBright Color\n\n\n\n\n0o00\nBlack\n0o10\nDark Gray\n\n\n0o01\nBlue\n0o11\nLight Blue\n\n\n0o02\nGreen\n0o12\nLight Green\n\n\n0o03\nCyan\n0o13\nLight Cyan\n\n\n0o04\nRed\n0o14\nLight Red\n\n\n0o05\nMagenta\n0o15\nPink\n\n\n0o06\nBrown\n0o16\nYellow\n\n\n0o07\nLight Gray\n0o17\nWhite"
  },
  {
    "objectID": "50_text.rjs.html#brightblink",
    "href": "50_text.rjs.html#brightblink",
    "title": "Text",
    "section": "Bright/Blink",
    "text": "Bright/Blink\n\nBit 4 is the bright bit.\n\nFor example, blue into light blue.\n\nFor the background color, this bit is nominally repurposed as the blink bit."
  },
  {
    "objectID": "50_text.rjs.html#memory-mapped-io",
    "href": "50_text.rjs.html#memory-mapped-io",
    "title": "Text",
    "section": "Memory-mapped I/O",
    "text": "Memory-mapped I/O\n\nOkay so this is cool.\nRecall the bus!\nWe are going to steal some diagrams.\n\nThanks Geeks for Geeks"
  },
  {
    "objectID": "50_text.rjs.html#isolated-io",
    "href": "50_text.rjs.html#isolated-io",
    "title": "Text",
    "section": "Isolated I/O",
    "text": "Isolated I/O\n\nImagine a form of I/O that isn‚Äôt cool.\nIt may have separate address spaces.\n\nSo there may be a 0x64 memory location and also 0x64 device."
  },
  {
    "objectID": "50_text.rjs.html#this-isnt-cool",
    "href": "50_text.rjs.html#this-isnt-cool",
    "title": "Text",
    "section": "This isn‚Äôt cool",
    "text": "This isn‚Äôt cool\n\nWe already discussed Harvard vs.¬†von Neumann architecture.\nHaving two memory spaces is not at all cool.\nSo we don‚Äôt do it.\nThere‚Äôs also port-mapped I/O (similarly not cool."
  },
  {
    "objectID": "50_text.rjs.html#memory-mapped-io-1",
    "href": "50_text.rjs.html#memory-mapped-io-1",
    "title": "Text",
    "section": "Memory-Mapped I/O",
    "text": "Memory-Mapped I/O\n\nImagine the following.\n\nThe bootloader lives at 0x0\nThe OS lives at 0x1\nThe keyboard lives at 0x2\nThe internet (via a network card) at 0x3\nThe monitor at 0x4\n\nThis obviously cool."
  },
  {
    "objectID": "50_text.rjs.html#altogether",
    "href": "50_text.rjs.html#altogether",
    "title": "Text",
    "section": "Altogether",
    "text": "Altogether\n\nOne Big Happy Memory Space"
  },
  {
    "objectID": "50_text.rjs.html#downsides",
    "href": "50_text.rjs.html#downsides",
    "title": "Text",
    "section": "Downsides",
    "text": "Downsides\n\nMMIO is a helpful abstraction - we already know how to think about memory, so we don‚Äôt need to learn much to do I/O.\n\nThere‚Äôs downsides.\nWe shouldn‚Äôt be able to write to keyboard, probably.\nOr read from a monitor.\n\nBut its fast and easy, like BIOS vs.¬†UEFI."
  },
  {
    "objectID": "50_text.rjs.html#in-x86_64",
    "href": "50_text.rjs.html#in-x86_64",
    "title": "Text",
    "section": "In x86_64",
    "text": "In x86_64\n\nOn our emulated device, VGA text buffer lives at address 0xb8000.\n\nAbsolute geniuses will crack open C and get into trouble.\n\nSo any read to this location:\n\nDoesn‚Äôt go to MMU/RAM/SSD\nDoes go to VGA hardware"
  },
  {
    "objectID": "50_text.rjs.html#alert",
    "href": "50_text.rjs.html#alert",
    "title": "Text",
    "section": "Alert!",
    "text": "Alert!\n\nMMIO, especially older devices, might not support all normal operations.\nFor example, a device could only support byte-wise reads and return junk when a u64 is read.\n\nBlock-write ‚ÄúHello world!‚Äù is a homework extension.\n\nRead more"
  },
  {
    "objectID": "50_text.rjs.html#a-rust-module",
    "href": "50_text.rjs.html#a-rust-module",
    "title": "Text",
    "section": "A Rust Module",
    "text": "A Rust Module\n\nNow we ‚Äúknow‚Äù how the VGA buffer works.\nWe can create a Rust module to handle print and standard out:\n\n\n\nsrc/main.rs\n\nmod vga;\n\n\nWe also must create a new src/vga.rs file."
  },
  {
    "objectID": "50_text.rjs.html#standard-out",
    "href": "50_text.rjs.html#standard-out",
    "title": "Text",
    "section": "Standard Out",
    "text": "Standard Out\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;"
  },
  {
    "objectID": "50_text.rjs.html#location",
    "href": "50_text.rjs.html#location",
    "title": "Text",
    "section": "Location",
    "text": "Location\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\nHave a constant referring to to the VGA buffer address.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;\nconst MMIO: usize = 0xb8000;"
  },
  {
    "objectID": "50_text.rjs.html#color",
    "href": "50_text.rjs.html#color",
    "title": "Text",
    "section": "Color",
    "text": "Color\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nProvide a way to write a character.\n\nI will use a const for color and not worry about.\n\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;\nconst MMIO: usize = 0xb8000;\nconst COLOR: u8 = 0xF;"
  },
  {
    "objectID": "50_text.rjs.html#character-wise",
    "href": "50_text.rjs.html#character-wise",
    "title": "Text",
    "section": "Character-wise",
    "text": "Character-wise\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nProvide a way to write a character.\n\nI will write a function to push one character.\n\n\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    todo!();\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise",
    "href": "50_text.rjs.html#stepwise",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise-1",
    "href": "50_text.rjs.html#stepwise-1",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n    *rel = a;\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise-2",
    "href": "50_text.rjs.html#stepwise-2",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n    *rel = a;\n    *((rel as usize + 1) as *mut u8) = COLOR;\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise-3",
    "href": "50_text.rjs.html#stepwise-3",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\nIncrement the latest.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n    *rel = a;\n    *((rel as usize + 1) as *mut u8) = COLOR;\n    LATEST = LATEST + 1;\n}"
  },
  {
    "objectID": "50_text.rjs.html#test-it",
    "href": "50_text.rjs.html#test-it",
    "title": "Text",
    "section": "Test it",
    "text": "Test it\n\nIt is trivial to test.\n\n\n\nsrc/main.rs\n\n    let hi: &[u8] = b\"Hello World!\";\n    for i in 0..12 {\n        vga::char_to_vga(hi[i]);\n    }\n\n\n‚ÄúWorks on my machine!‚Äù - me\n\nUnless?\nWe‚Äôll come back to this."
  },
  {
    "objectID": "50_text.rjs.html#annoying",
    "href": "50_text.rjs.html#annoying",
    "title": "Text",
    "section": "Annoying",
    "text": "Annoying\n\nSome of you may lack a strong work ethic and want to show entire a whole string rather than just a character at a time.\n\nEspecially since using characters of a string in Rust is ludicrously opaque.\n\nNot to worry."
  },
  {
    "objectID": "50_text.rjs.html#target-str",
    "href": "50_text.rjs.html#target-str",
    "title": "Text",
    "section": "Target &str",
    "text": "Target &str\n\nWe can abstract to loop into src/vga.rs\n\n\n\nsrc/vga.rs\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}"
  },
  {
    "objectID": "50_text.rjs.html#aside",
    "href": "50_text.rjs.html#aside",
    "title": "Text",
    "section": "Aside",
    "text": "Aside\n\nI am opinionated on as_bytes.\nLet‚Äôs check some links.\n\nto_bytes\nas_bytes\nbytes\n\nCan you guess what always works?"
  },
  {
    "objectID": "50_text.rjs.html#aside-1",
    "href": "50_text.rjs.html#aside-1",
    "title": "Text",
    "section": "Aside",
    "text": "Aside\n\nBig Rust doesn‚Äôt want you to know you can use pointers.\n\n\n\nsrc/vga.rs\n\n    let ptr = s.as_ptr() as usize;\n    unsafe {\n        for i in 0..s.len() {\n            char_to_vga(*((ptr + i) as *const u8));\n        }\n    }\n\n\nI could make this even worse but I didn‚Äôt.\nAnyways don‚Äôt do this."
  },
  {
    "objectID": "50_text.rjs.html#update-main",
    "href": "50_text.rjs.html#update-main",
    "title": "Text",
    "section": "Update main",
    "text": "Update main\n\nLook how nice that is!\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Hello, world!\");\n    loop {}\n}"
  },
  {
    "objectID": "50_text.rjs.html#i-bet",
    "href": "50_text.rjs.html#i-bet",
    "title": "Text",
    "section": "I bet‚Ä¶",
    "text": "I bet‚Ä¶\n\nI bet we can print any string.\nLet‚Äôs do like a comically easy string that will definitely print.\nThere‚Äôs no way it will fail.\n\n\n\nsrc/main.rs\n\n    vga::str_to_vga(\"Hello\\nworld!\");\n\n\nIt worked right?"
  },
  {
    "objectID": "50_text.rjs.html#escape-codes",
    "href": "50_text.rjs.html#escape-codes",
    "title": "Text",
    "section": "Escape Codes",
    "text": "Escape Codes\n\nOkay so there‚Äôs some things we need to treat differently.\n\nMinimally \\n.\nAnd therefore also \\\\ to show a single backslash.\nI don‚Äôt even know if we need anything else, but I‚Äôll show the design pattern."
  },
  {
    "objectID": "50_text.rjs.html#revisit-implementation",
    "href": "50_text.rjs.html#revisit-implementation",
    "title": "Text",
    "section": "Revisit Implementation",
    "text": "Revisit Implementation\n\nRecall our naive implementation.\n\n\n\nsrc/vga.rs\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}"
  },
  {
    "objectID": "50_text.rjs.html#case-analysis",
    "href": "50_text.rjs.html#case-analysis",
    "title": "Text",
    "section": "Case analysis",
    "text": "Case analysis\n\nAs far as I know (I didn‚Äôt check) we only have to look for is:\n\n\\n\n10 (I think?)\n0xa\n\nIt will be a u8 within the loop (since we as_bytes first)"
  },
  {
    "objectID": "50_text.rjs.html#trust-but-verify",
    "href": "50_text.rjs.html#trust-but-verify",
    "title": "Text",
    "section": "Trust but verify",
    "text": "Trust but verify\n\nI just checked in a different crate.\n\n\n\n../???/src/main.rs\n\nfn main() {\n    let s = \"Hello\\nworld!\";\n    dbg!(s.as_bytes());\n}\n\n\nLooked like 10 to me."
  },
  {
    "objectID": "50_text.rjs.html#now-it-works",
    "href": "50_text.rjs.html#now-it-works",
    "title": "Text",
    "section": "Now it works!",
    "text": "Now it works!\n\nWe can write vertically!\n\nI guess this could be a helper function or something.\n\n\n\n\nsrc/main.rs\n\n    vga::str_to_vga(\"H\\ne\\nl\\nl\\no\\n\\nw\\no\\nr\\nl\\nd\\n!\");"
  },
  {
    "objectID": "50_text.rjs.html#good-thing",
    "href": "50_text.rjs.html#good-thing",
    "title": "Text",
    "section": "Good thing‚Ä¶",
    "text": "Good thing‚Ä¶\n\nI can print that more than once!\n\n\n\nsrc/main.rs\n\n    for _i in 0..3 {\n        vga::str_to_vga(\"H\\ne\\nl\\nl\\no\\n\\nw\\no\\nr\\nl\\nd\\n!\");\n    }\n\n\nWait a minute!"
  },
  {
    "objectID": "50_text.rjs.html#were-doomed",
    "href": "50_text.rjs.html#were-doomed",
    "title": "Text",
    "section": "We‚Äôre doomed",
    "text": "We‚Äôre doomed\n\nWe didn‚Äôt save what was written to the previous lines.\nReal ones know."
  },
  {
    "objectID": "50_text.rjs.html#unless",
    "href": "50_text.rjs.html#unless",
    "title": "Text",
    "section": "Unless?",
    "text": "Unless?\n\nNo way can we read from the VGA text buffer right.\nThat would be‚Ä¶ extraordinary.\nYou can do whatever you want, I just want to show you one possible design choice.\n\nMostly as a proof of concept."
  },
  {
    "objectID": "50_text.rjs.html#scroll",
    "href": "50_text.rjs.html#scroll",
    "title": "Text",
    "section": "Scroll",
    "text": "Scroll\n\nI‚Äôll add some consts and write a helper.\n\n\n\nsrc/vga.rs\n\nconst ROWS: usize = 80;\nconst COLS: usize = 25;\nconst MAX: usize = ROWS * COLS;\n\nfn scroll() {\n    todo!();\n}"
  },
  {
    "objectID": "50_text.rjs.html#execution",
    "href": "50_text.rjs.html#execution",
    "title": "Text",
    "section": "Execution",
    "text": "Execution\n\nStart at the first character that will remain visible.\nCopy it to the earliest visible slot (start of buffer).\nIterate until the full buffer is moved.\nWe note this could be executed in a single memmove\n\nRead more"
  },
  {
    "objectID": "50_text.rjs.html#my-code",
    "href": "50_text.rjs.html#my-code",
    "title": "Text",
    "section": "My Code",
    "text": "My Code\n\nPublic just to test.\n\n\n\nsrc/vga.rs\n\npub fn scroll() {\n    for i in 80..MAX {\n        unsafe {\n            let src: *mut u8 = ((MMIO as usize) + (i * 2)) as *mut u8;\n            let dst: *mut u8 = ((MMIO as usize) + ((i - 80) * 2)) as *mut u8;\n            *dst = *src;\n        }\n    }\n}"
  },
  {
    "objectID": "50_text.rjs.html#my-test",
    "href": "50_text.rjs.html#my-test",
    "title": "Text",
    "section": "My Test",
    "text": "My Test\n\nI just sent line numbers then manually scrolled.\n\n\n\nsrc/main.rs\n\n    vga::str_to_vga(\"0\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\nA\\nB\");\n    vga::scroll();"
  },
  {
    "objectID": "50_text.rjs.html#a-better-test",
    "href": "50_text.rjs.html#a-better-test",
    "title": "Text",
    "section": "A better test",
    "text": "A better test\n\nHere is a copy of the Project Gutenburg ebook of Pride and Prejudice.\nIt contains some quotes which might be a problem.\nLink\n\nhttps://raw.githubusercontent.com/cd-public/books/main/pg1342.txt"
  },
  {
    "objectID": "50_text.rjs.html#does-it-work",
    "href": "50_text.rjs.html#does-it-work",
    "title": "Text",
    "section": "Does it work?",
    "text": "Does it work?\n\nWhat do we have to do?\n\n\n\nAdd scroll to str_to_vga\nUpdate LATEST in scroll\nBlank out the last line, I used space (0x20 or 32)\nMake sure all color bytes are set."
  },
  {
    "objectID": "50_text.rjs.html#why-do-we-blank-out",
    "href": "50_text.rjs.html#why-do-we-blank-out",
    "title": "Text",
    "section": "Why do we blank out?",
    "text": "Why do we blank out?\n\nRecall we are writing to MMIO.\nAs soon as we exceed the MMIO range, we can make no claims about what memory we are vviewing.\nSo if we copy in data past the buffer, we could get anything.\nSo if we don‚Äôt overwrite the buffer, we could get anything."
  },
  {
    "objectID": "50_text.rjs.html#we-set-color-bytes",
    "href": "50_text.rjs.html#we-set-color-bytes",
    "title": "Text",
    "section": "We set color bytes?",
    "text": "We set color bytes?\n\nLike lines off the MMIO range, the color bytes have no known value.\nSo if we e.g.¬†have a newline anywhere and end up not initially setting colors‚Ä¶\nThen copy text up to that line‚Ä¶\nWe will be showing text in an unset color.\n\nJust whatever bits happened to be there!"
  },
  {
    "objectID": "50_text.rjs.html#this-is-unsafe",
    "href": "50_text.rjs.html#this-is-unsafe",
    "title": "Text",
    "section": "This is unsafe!",
    "text": "This is unsafe!\n\nAstute learners will notice this is all very unsafe."
  },
  {
    "objectID": "50_text.rjs.html#im-loopy",
    "href": "50_text.rjs.html#im-loopy",
    "title": "Text",
    "section": "I‚Äôm loopy",
    "text": "I‚Äôm loopy\n\nI should not I do everything with for loops and ‚Äúsingle-equals-assignment‚Äù\n\nI mostly am teaching you how to code\nThis is NOT teaching you how to Rust (or C)\n\nWho needs memmove (a C function) when we have the humble for loop.\nRead more: core::ptr::copy"
  },
  {
    "objectID": "50_text.rjs.html#caution",
    "href": "50_text.rjs.html#caution",
    "title": "Text",
    "section": "Caution!",
    "text": "Caution!\n\nI am building my crate without access to memmove.\nYou may need to go back and add some configuration.\nThis was covered in the ‚ÄúKernel‚Äù lecture.\n\nHere"
  },
  {
    "objectID": "50_text.rjs.html#my-solution",
    "href": "50_text.rjs.html#my-solution",
    "title": "Text",
    "section": "My solution",
    "text": "My solution\n\n\n\nsrc/vga.rs\n\nconst ROWS: usize = 80;\nconst COLS: usize = 25;\nconst MAX: usize = ROWS * COLS;\n\nfn scroll() {\n    unsafe {\n        for i in 80..MAX {\n            let src: *mut u8 = (MMIO + i * 2) as *mut u8;\n            let dst: *mut u8 = (MMIO + (i - 80) * 2)) as *mut u8;\n            *dst = *src;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        for i in (MAX-80)..MAX {\n            let dst: *mut u8 = (MMIO + i * 2) as *mut u8;\n            *dst = 32;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        LATEST = LATEST - 80;\n    }\n}\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    unsafe {\n        for i in 0..v.len() {\n            if LATEST &gt; MAX {\n                scroll();\n            }\n            match v[i] {\n                10 =&gt; LATEST = ((LATEST / 80) + 1) * 80,\n                _ =&gt; char_to_vga(v[i]),\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "50_text.rjs.html#best-practice",
    "href": "50_text.rjs.html#best-practice",
    "title": "Text",
    "section": "Best Practice",
    "text": "Best Practice\n\nThis works on my machine.\nIt may not always work.\nWhy? rustc is a bit too smart.\n\nThere is no obvious externally observable reason to write to fixed memory location.\nThe compiler may optimize out such writes.\nI say ‚Äúsure it will.‚Äù"
  },
  {
    "objectID": "50_text.rjs.html#quote-blog",
    "href": "50_text.rjs.html#quote-blog",
    "title": "Text",
    "section": "Quote Blog",
    "text": "Quote Blog\n\nThe problem is that we only write to the buffer and never read from it again.\n\n\nOkay so but here me out.\nOur implementation does read from the buffer again.\n\nSometimes the best way to do things is also the simplest.\nFor some reason blog kept a local copy and only used that?"
  },
  {
    "objectID": "50_text.rjs.html#volatile-1",
    "href": "50_text.rjs.html#volatile-1",
    "title": "Text",
    "section": "Volatile",
    "text": "Volatile\n\nIf we lacked the skill and bravery of the instructor of this course, we may have a problem.\nTo avoid an erroneous optimization omitting all writes, we need to specify writes as volatile.\nThis tells the compiler that the write has side effects and should not be optimized away.\nRead more"
  },
  {
    "objectID": "50_text.rjs.html#interested-students",
    "href": "50_text.rjs.html#interested-students",
    "title": "Text",
    "section": "Interested Students",
    "text": "Interested Students\n\nThere‚Äôs a read_volatile and write_volatile in std::ptr and another in core::ptr, we might be able to use those."
  },
  {
    "objectID": "50_text.html",
    "href": "50_text.html",
    "title": "Text",
    "section": "",
    "text": "Action Items:\n\nDo you text output yet?\n\nThe coolest assignment ever for a third week in a row.\nHow do I keep getting away with it.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#announcements",
    "href": "50_text.html#announcements",
    "title": "Text",
    "section": "",
    "text": "Action Items:\n\nDo you text output yet?\n\nThe coolest assignment ever for a third week in a row.\nHow do I keep getting away with it.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#citations",
    "href": "50_text.html#citations",
    "title": "Text",
    "section": "Citations",
    "text": "Citations\n\nI tried to steal this but I thought it was too bad and changed everything.\n\nVGA Text Mode",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#vga-text-mode",
    "href": "50_text.html#vga-text-mode",
    "title": "Text",
    "section": "VGA Text Mode",
    "text": "VGA Text Mode\n\nWe recall VGA text mode from the homework.\n\nA simple way to print text to the screen.\n\nWe recall that Rust prints via a ‚Äúmacro‚Äù\nNow we:\n\nCreate an interface to encapsulating all unsafety in a separate module.\nWe also implement support for Rust‚Äôs formatting macros",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#the-buffer",
    "href": "50_text.html#the-buffer",
    "title": "Text",
    "section": "The Buffer",
    "text": "The Buffer\n\nTo print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware.\n\nA byte passing over a bus to fixed location will render as ASCII on a screen.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#d-or-2d",
    "href": "50_text.html#d-or-2d",
    "title": "Text",
    "section": "1d or 2d",
    "text": "1d or 2d\n\nThe VGA text buffer renders as two-dimensional array.\n\nAddressed as a one dimensional array.\nSafe to assume 25 rows and 80 columns.\nEach position is an ASCII (not unicode) character.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#format",
    "href": "50_text.html#format",
    "title": "Text",
    "section": "Format",
    "text": "Format\n\nDescribes a single screen character through the following format:\n\n\n\n\nBit(s)\nValue\n\n\n\n\n0-7\nASCII code point\n\n\n8-11\nForeground color\n\n\n12-14\nBackground color\n\n\n15\nBlink\n\n\n\n\nI did not see blinking.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#first-byte",
    "href": "50_text.html#first-byte",
    "title": "Text",
    "section": "First Byte",
    "text": "First Byte\n\nThe first byte represents the character that should be printed in the [ASCII encoding].\n\nWe recall we say many mentions of Python in firmware jobs.\n\npython3 -c \"[print(chr(a), ':', a) for a in range(ord('A'), ord('z')+1)]\"",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#except",
    "href": "50_text.html#except",
    "title": "Text",
    "section": "Except",
    "text": "Except\n\nOkay it isn‚Äôt actually ASCII.\nIt‚Äôs code page 437\nWe think of it as an IBM specific ASCII extension and just use the ASCII subset.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#second-byte",
    "href": "50_text.html#second-byte",
    "title": "Text",
    "section": "Second Byte",
    "text": "Second Byte\n\nThe second byte defines how the character is displayed.\n\nThe first four bits define the foreground color.\nThe next three bits the background color\nNominally the last bit whether the character should blink.\n\nI did not see blinking.\nMay be a qemu thing I‚Äôm not sure.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#colors",
    "href": "50_text.html#colors",
    "title": "Text",
    "section": "Colors",
    "text": "Colors\n\nUsing octal.\n\n\n\n\nNumber\nColor\nBright\nBright Color\n\n\n\n\n0o00\nBlack\n0o10\nDark Gray\n\n\n0o01\nBlue\n0o11\nLight Blue\n\n\n0o02\nGreen\n0o12\nLight Green\n\n\n0o03\nCyan\n0o13\nLight Cyan\n\n\n0o04\nRed\n0o14\nLight Red\n\n\n0o05\nMagenta\n0o15\nPink\n\n\n0o06\nBrown\n0o16\nYellow\n\n\n0o07\nLight Gray\n0o17\nWhite",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#brightblink",
    "href": "50_text.html#brightblink",
    "title": "Text",
    "section": "Bright/Blink",
    "text": "Bright/Blink\n\nBit 4 is the bright bit.\n\nFor example, blue into light blue.\n\nFor the background color, this bit is nominally repurposed as the blink bit.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#memory-mapped-io",
    "href": "50_text.html#memory-mapped-io",
    "title": "Text",
    "section": "Memory-mapped I/O",
    "text": "Memory-mapped I/O\n\nOkay so this is cool.\nRecall the bus!\nWe are going to steal some diagrams.\n\nThanks Geeks for Geeks",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#isolated-io",
    "href": "50_text.html#isolated-io",
    "title": "Text",
    "section": "Isolated I/O",
    "text": "Isolated I/O\n\nImagine a form of I/O that isn‚Äôt cool.\nIt may have separate address spaces.\n\nSo there may be a 0x64 memory location and also 0x64 device.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#this-isnt-cool",
    "href": "50_text.html#this-isnt-cool",
    "title": "Text",
    "section": "This isn‚Äôt cool",
    "text": "This isn‚Äôt cool\n\nWe already discussed Harvard vs.¬†von Neumann architecture.\nHaving two memory spaces is not at all cool.\nSo we don‚Äôt do it.\nThere‚Äôs also port-mapped I/O (similarly not cool.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#memory-mapped-io-1",
    "href": "50_text.html#memory-mapped-io-1",
    "title": "Text",
    "section": "Memory-Mapped I/O",
    "text": "Memory-Mapped I/O\n\nImagine the following.\n\nThe bootloader lives at 0x0\nThe OS lives at 0x1\nThe keyboard lives at 0x2\nThe internet (via a network card) at 0x3\nThe monitor at 0x4\n\nThis obviously cool.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#altogether",
    "href": "50_text.html#altogether",
    "title": "Text",
    "section": "Altogether",
    "text": "Altogether\n\nOne Big Happy Memory Space",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#downsides",
    "href": "50_text.html#downsides",
    "title": "Text",
    "section": "Downsides",
    "text": "Downsides\n\nMMIO is a helpful abstraction - we already know how to think about memory, so we don‚Äôt need to learn much to do I/O.\n\nThere‚Äôs downsides.\nWe shouldn‚Äôt be able to write to keyboard, probably.\nOr read from a monitor.\n\nBut its fast and easy, like BIOS vs.¬†UEFI.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#in-x86_64",
    "href": "50_text.html#in-x86_64",
    "title": "Text",
    "section": "In x86_64",
    "text": "In x86_64\n\nOn our emulated device, VGA text buffer lives at address 0xb8000.\n\nAbsolute geniuses will crack open C and get into trouble.\n\nSo any read to this location:\n\nDoesn‚Äôt go to MMU/RAM/SSD\nDoes go to VGA hardware",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#alert",
    "href": "50_text.html#alert",
    "title": "Text",
    "section": "Alert!",
    "text": "Alert!\n\nMMIO, especially older devices, might not support all normal operations.\nFor example, a device could only support byte-wise reads and return junk when a u64 is read.\n\nBlock-write ‚ÄúHello world!‚Äù is a homework extension.\n\nRead more",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#a-rust-module",
    "href": "50_text.html#a-rust-module",
    "title": "Text",
    "section": "A Rust Module",
    "text": "A Rust Module\n\nNow we ‚Äúknow‚Äù how the VGA buffer works.\nWe can create a Rust module to handle print and standard out:\n\n\n\nsrc/main.rs\n\nmod vga;\n\n\nWe also must create a new src/vga.rs file.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#standard-out",
    "href": "50_text.html#standard-out",
    "title": "Text",
    "section": "Standard Out",
    "text": "Standard Out\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#location",
    "href": "50_text.html#location",
    "title": "Text",
    "section": "Location",
    "text": "Location\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\nHave a constant referring to to the VGA buffer address.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;\nconst MMIO: usize = 0xb8000;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#color",
    "href": "50_text.html#color",
    "title": "Text",
    "section": "Color",
    "text": "Color\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nProvide a way to write a character.\n\nI will use a const for color and not worry about.\n\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;\nconst MMIO: usize = 0xb8000;\nconst COLOR: u8 = 0xF;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#character-wise",
    "href": "50_text.html#character-wise",
    "title": "Text",
    "section": "Character-wise",
    "text": "Character-wise\n\nTo provide ‚Äústandard out‚Äù like functionality, I will:\n\nProvide a way to write a character.\n\nI will write a function to push one character.\n\n\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    todo!();\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise",
    "href": "50_text.html#stepwise",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise-1",
    "href": "50_text.html#stepwise-1",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n    *rel = a;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise-2",
    "href": "50_text.html#stepwise-2",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n    *rel = a;\n    *((rel as usize + 1) as *mut u8) = COLOR;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise-3",
    "href": "50_text.html#stepwise-3",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\nIncrement the latest.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = (MMIO + (latest * 2)) as *mut u8;\n    *rel = a;\n    *((rel as usize + 1) as *mut u8) = COLOR;\n    LATEST = LATEST + 1;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#test-it",
    "href": "50_text.html#test-it",
    "title": "Text",
    "section": "Test it",
    "text": "Test it\n\nIt is trivial to test.\n\n\n\nsrc/main.rs\n\n    let hi: &[u8] = b\"Hello World!\";\n    for i in 0..12 {\n        vga::char_to_vga(hi[i]);\n    }\n\n\n‚ÄúWorks on my machine!‚Äù - me\n\nUnless?\nWe‚Äôll come back to this.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#annoying",
    "href": "50_text.html#annoying",
    "title": "Text",
    "section": "Annoying",
    "text": "Annoying\n\nSome of you may lack a strong work ethic and want to show entire a whole string rather than just a character at a time.\n\nEspecially since using characters of a string in Rust is ludicrously opaque.\n\nNot to worry.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#target-str",
    "href": "50_text.html#target-str",
    "title": "Text",
    "section": "Target &str",
    "text": "Target &str\n\nWe can abstract to loop into src/vga.rs\n\n\n\nsrc/vga.rs\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#aside",
    "href": "50_text.html#aside",
    "title": "Text",
    "section": "Aside",
    "text": "Aside\n\nI am opinionated on as_bytes.\nLet‚Äôs check some links.\n\nto_bytes\nas_bytes\nbytes\n\nCan you guess what always works?",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#aside-1",
    "href": "50_text.html#aside-1",
    "title": "Text",
    "section": "Aside",
    "text": "Aside\n\nBig Rust doesn‚Äôt want you to know you can use pointers.\n\n\n\nsrc/vga.rs\n\n    let ptr = s.as_ptr() as usize;\n    unsafe {\n        for i in 0..s.len() {\n            char_to_vga(*((ptr + i) as *const u8));\n        }\n    }\n\n\nI could make this even worse but I didn‚Äôt.\nAnyways don‚Äôt do this.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#update-main",
    "href": "50_text.html#update-main",
    "title": "Text",
    "section": "Update main",
    "text": "Update main\n\nLook how nice that is!\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Hello, world!\");\n    loop {}\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#i-bet",
    "href": "50_text.html#i-bet",
    "title": "Text",
    "section": "I bet‚Ä¶",
    "text": "I bet‚Ä¶\n\nI bet we can print any string.\nLet‚Äôs do like a comically easy string that will definitely print.\nThere‚Äôs no way it will fail.\n\n\n\nsrc/main.rs\n\n    vga::str_to_vga(\"Hello\\nworld!\");\n\n\nIt worked right?",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#escape-codes",
    "href": "50_text.html#escape-codes",
    "title": "Text",
    "section": "Escape Codes",
    "text": "Escape Codes\n\nOkay so there‚Äôs some things we need to treat differently.\n\nMinimally \\n.\nAnd therefore also \\\\ to show a single backslash.\nI don‚Äôt even know if we need anything else, but I‚Äôll show the design pattern.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#revisit-implementation",
    "href": "50_text.html#revisit-implementation",
    "title": "Text",
    "section": "Revisit Implementation",
    "text": "Revisit Implementation\n\nRecall our naive implementation.\n\n\n\nsrc/vga.rs\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#case-analysis",
    "href": "50_text.html#case-analysis",
    "title": "Text",
    "section": "Case analysis",
    "text": "Case analysis\n\nAs far as I know (I didn‚Äôt check) we only have to look for is:\n\n\\n\n10 (I think?)\n0xa\n\nIt will be a u8 within the loop (since we as_bytes first)",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#trust-but-verify",
    "href": "50_text.html#trust-but-verify",
    "title": "Text",
    "section": "Trust but verify",
    "text": "Trust but verify\n\nI just checked in a different crate.\n\n\n\n../???/src/main.rs\n\nfn main() {\n    let s = \"Hello\\nworld!\";\n    dbg!(s.as_bytes());\n}\n\n\nLooked like 10 to me.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#now-it-works",
    "href": "50_text.html#now-it-works",
    "title": "Text",
    "section": "Now it works!",
    "text": "Now it works!\n\nWe can write vertically!\n\nI guess this could be a helper function or something.\n\n\n\n\nsrc/main.rs\n\n    vga::str_to_vga(\"H\\ne\\nl\\nl\\no\\n\\nw\\no\\nr\\nl\\nd\\n!\");",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#good-thing",
    "href": "50_text.html#good-thing",
    "title": "Text",
    "section": "Good thing‚Ä¶",
    "text": "Good thing‚Ä¶\n\nI can print that more than once!\n\n\n\nsrc/main.rs\n\n    for _i in 0..3 {\n        vga::str_to_vga(\"H\\ne\\nl\\nl\\no\\n\\nw\\no\\nr\\nl\\nd\\n!\");\n    }\n\n\nWait a minute!",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#were-doomed",
    "href": "50_text.html#were-doomed",
    "title": "Text",
    "section": "We‚Äôre doomed",
    "text": "We‚Äôre doomed\n\nWe didn‚Äôt save what was written to the previous lines.\nReal ones know.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#unless",
    "href": "50_text.html#unless",
    "title": "Text",
    "section": "Unless?",
    "text": "Unless?\n\nNo way can we read from the VGA text buffer right.\nThat would be‚Ä¶ extraordinary.\nYou can do whatever you want, I just want to show you one possible design choice.\n\nMostly as a proof of concept.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#scroll",
    "href": "50_text.html#scroll",
    "title": "Text",
    "section": "Scroll",
    "text": "Scroll\n\nI‚Äôll add some consts and write a helper.\n\n\n\nsrc/vga.rs\n\nconst ROWS: usize = 80;\nconst COLS: usize = 25;\nconst MAX: usize = ROWS * COLS;\n\nfn scroll() {\n    todo!();\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#execution",
    "href": "50_text.html#execution",
    "title": "Text",
    "section": "Execution",
    "text": "Execution\n\nStart at the first character that will remain visible.\nCopy it to the earliest visible slot (start of buffer).\nIterate until the full buffer is moved.\nWe note this could be executed in a single memmove\n\nRead more",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#my-code",
    "href": "50_text.html#my-code",
    "title": "Text",
    "section": "My Code",
    "text": "My Code\n\nPublic just to test.\n\n\n\nsrc/vga.rs\n\npub fn scroll() {\n    for i in 80..MAX {\n        unsafe {\n            let src: *mut u8 = ((MMIO as usize) + (i * 2)) as *mut u8;\n            let dst: *mut u8 = ((MMIO as usize) + ((i - 80) * 2)) as *mut u8;\n            *dst = *src;\n        }\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#my-test",
    "href": "50_text.html#my-test",
    "title": "Text",
    "section": "My Test",
    "text": "My Test\n\nI just sent line numbers then manually scrolled.\n\n\n\nsrc/main.rs\n\n    vga::str_to_vga(\"0\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\nA\\nB\");\n    vga::scroll();",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#a-better-test",
    "href": "50_text.html#a-better-test",
    "title": "Text",
    "section": "A better test",
    "text": "A better test\n\nHere is a copy of the Project Gutenburg ebook of Pride and Prejudice.\nIt contains some quotes which might be a problem.\nLink\n\nhttps://raw.githubusercontent.com/cd-public/books/main/pg1342.txt",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#does-it-work",
    "href": "50_text.html#does-it-work",
    "title": "Text",
    "section": "Does it work?",
    "text": "Does it work?\n\nWhat do we have to do?\n\n\n\nAdd scroll to str_to_vga\nUpdate LATEST in scroll\nBlank out the last line, I used space (0x20 or 32)\nMake sure all color bytes are set.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#why-do-we-blank-out",
    "href": "50_text.html#why-do-we-blank-out",
    "title": "Text",
    "section": "Why do we blank out?",
    "text": "Why do we blank out?\n\nRecall we are writing to MMIO.\nAs soon as we exceed the MMIO range, we can make no claims about what memory we are vviewing.\nSo if we copy in data past the buffer, we could get anything.\nSo if we don‚Äôt overwrite the buffer, we could get anything.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#we-set-color-bytes",
    "href": "50_text.html#we-set-color-bytes",
    "title": "Text",
    "section": "We set color bytes?",
    "text": "We set color bytes?\n\nLike lines off the MMIO range, the color bytes have no known value.\nSo if we e.g.¬†have a newline anywhere and end up not initially setting colors‚Ä¶\nThen copy text up to that line‚Ä¶\nWe will be showing text in an unset color.\n\nJust whatever bits happened to be there!",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#this-is-unsafe",
    "href": "50_text.html#this-is-unsafe",
    "title": "Text",
    "section": "This is unsafe!",
    "text": "This is unsafe!\n\nAstute learners will notice this is all very unsafe.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#im-loopy",
    "href": "50_text.html#im-loopy",
    "title": "Text",
    "section": "I‚Äôm loopy",
    "text": "I‚Äôm loopy\n\nI should not I do everything with for loops and ‚Äúsingle-equals-assignment‚Äù\n\nI mostly am teaching you how to code\nThis is NOT teaching you how to Rust (or C)\n\nWho needs memmove (a C function) when we have the humble for loop.\nRead more: core::ptr::copy",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#caution",
    "href": "50_text.html#caution",
    "title": "Text",
    "section": "Caution!",
    "text": "Caution!\n\nI am building my crate without access to memmove.\nYou may need to go back and add some configuration.\nThis was covered in the ‚ÄúKernel‚Äù lecture.\n\nHere",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#my-solution",
    "href": "50_text.html#my-solution",
    "title": "Text",
    "section": "My solution",
    "text": "My solution\n\n\n\nsrc/vga.rs\n\nconst ROWS: usize = 80;\nconst COLS: usize = 25;\nconst MAX: usize = ROWS * COLS;\n\nfn scroll() {\n    unsafe {\n        for i in 80..MAX {\n            let src: *mut u8 = (MMIO + i * 2) as *mut u8;\n            let dst: *mut u8 = (MMIO + (i - 80) * 2)) as *mut u8;\n            *dst = *src;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        for i in (MAX-80)..MAX {\n            let dst: *mut u8 = (MMIO + i * 2) as *mut u8;\n            *dst = 32;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        LATEST = LATEST - 80;\n    }\n}\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    unsafe {\n        for i in 0..v.len() {\n            if LATEST &gt; MAX {\n                scroll();\n            }\n            match v[i] {\n                10 =&gt; LATEST = ((LATEST / 80) + 1) * 80,\n                _ =&gt; char_to_vga(v[i]),\n            }\n        }\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#best-practice",
    "href": "50_text.html#best-practice",
    "title": "Text",
    "section": "Best Practice",
    "text": "Best Practice\n\nThis works on my machine.\nIt may not always work.\nWhy? rustc is a bit too smart.\n\nThere is no obvious externally observable reason to write to fixed memory location.\nThe compiler may optimize out such writes.\nI say ‚Äúsure it will.‚Äù",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#quote-blog",
    "href": "50_text.html#quote-blog",
    "title": "Text",
    "section": "Quote Blog",
    "text": "Quote Blog\n\nThe problem is that we only write to the buffer and never read from it again.\n\n\nOkay so but here me out.\nOur implementation does read from the buffer again.\n\nSometimes the best way to do things is also the simplest.\nFor some reason blog kept a local copy and only used that?",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#volatile-1",
    "href": "50_text.html#volatile-1",
    "title": "Text",
    "section": "Volatile",
    "text": "Volatile\n\nIf we lacked the skill and bravery of the instructor of this course, we may have a problem.\nTo avoid an erroneous optimization omitting all writes, we need to specify writes as volatile.\nThis tells the compiler that the write has side effects and should not be optimized away.\nRead more",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#interested-students",
    "href": "50_text.html#interested-students",
    "title": "Text",
    "section": "Interested Students",
    "text": "Interested Students\n\nThere‚Äôs a read_volatile and write_volatile in std::ptr and another in core::ptr, we might be able to use those.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "60_test.rjs.html#announcements",
    "href": "60_test.rjs.html#announcements",
    "title": "Test",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nHow is graphics?\n\nAre you learning NumPy?\nAnyone using CUDA?"
  },
  {
    "objectID": "60_test.rjs.html#citations",
    "href": "60_test.rjs.html#citations",
    "title": "Test",
    "section": "Citations",
    "text": "Citations\n\nI am geniunely convinced of the usefulness of automated testing when developing a system.\nThe most high profile case of this is the testing framework for 4096_t.c\nHard to persuade students of the usefulness of this on small class assignments.\n\\(\\therefore\\) I‚Äôve never written anything of any reasonable size in Rust, so\nTesting"
  },
  {
    "objectID": "60_test.rjs.html#today",
    "href": "60_test.rjs.html#today",
    "title": "Test",
    "section": "Today",
    "text": "Today\n\nTesting under no_std\nQEMU\nbootimage\n\nStill not in love with this dependency, but we do what we can."
  },
  {
    "objectID": "60_test.rjs.html#pre-work",
    "href": "60_test.rjs.html#pre-work",
    "title": "Test",
    "section": "Pre-work",
    "text": "Pre-work\n\nMake sure you have a .cargo/config.toml\nNo idea how you wouldn‚Äôt have one of these yet!\nJust make sure you have it."
  },
  {
    "objectID": "60_test.rjs.html#modern-language",
    "href": "60_test.rjs.html#modern-language",
    "title": "Test",
    "section": "Modern Language",
    "text": "Modern Language\n\nLike Python with Pytest, and unlike the only other systems language, Rust has a testing framework.\nIt‚Äôs covered in Rust book\nNaturally I skipped this chapter."
  },
  {
    "objectID": "60_test.rjs.html#framework",
    "href": "60_test.rjs.html#framework",
    "title": "Test",
    "section": "Framework",
    "text": "Framework\n\nUse the #[test] attribute on some functions.\nIncluding assertions within those functions.\ncargo test or, if you see someone around, cargo t, will check the assertions.\nThe crate will otherwise be non-impacted."
  },
  {
    "objectID": "60_test.rjs.html#review",
    "href": "60_test.rjs.html#review",
    "title": "Test",
    "section": "Review",
    "text": "Review\n\nTo enable testing for our kernel binary, we can set the test flag in the Cargo.toml to true.\nWe recall our Cargo.toml - mine no longer has an allusions to panic with the introduction of a JSON target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbootloader = \"0.9\""
  },
  {
    "objectID": "60_test.rjs.html#enable",
    "href": "60_test.rjs.html#enable",
    "title": "Test",
    "section": "Enable",
    "text": "Enable\n\nThis is necessary but not sufficient.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbootloader = \"0.9\"\n\n[[bin]]\nname = \"osirs\"\ntest = true\nbench = false"
  },
  {
    "objectID": "60_test.rjs.html#on-bin",
    "href": "60_test.rjs.html#on-bin",
    "title": "Test",
    "section": "On [[bin]]",
    "text": "On [[bin]]\n\nThe double-bracket sections like [[bin]] are array-of-table of TOML, which means you can write more than one [[bin]] section to make several executables in your crate.\n\n\nJust one for us for now."
  },
  {
    "objectID": "60_test.rjs.html#working-within-no_std",
    "href": "60_test.rjs.html#working-within-no_std",
    "title": "Test",
    "section": "Working within no_std",
    "text": "Working within no_std\n\nTesting is complicated by no_std.\nRust implicitly uses the test library, which depends on std\n\nMore on test\n\n\n$ cargo t\n   Compiling bootloader v0.9.34\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `bootloader` (lib) due to 1 previous error"
  },
  {
    "objectID": "60_test.rjs.html#what-we-lose",
    "href": "60_test.rjs.html#what-we-lose",
    "title": "Test",
    "section": "What We Lose",
    "text": "What We Lose\n\nVs. std, we lose e.g.¬†should_panic tests.\n\nOn those\n\nThat‚Äôs okay, we are crafty (and wrote our own panic handler anyway)."
  },
  {
    "objectID": "60_test.rjs.html#to-main",
    "href": "60_test.rjs.html#to-main",
    "title": "Test",
    "section": "To Main",
    "text": "To Main\n\nMy main looks like this:\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\nmod colors;\nmod vga;\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    colors::colors();\n    colors::image();\n    loop {}\n}"
  },
  {
    "objectID": "60_test.rjs.html#just-a-note",
    "href": "60_test.rjs.html#just-a-note",
    "title": "Test",
    "section": "Just a note",
    "text": "Just a note\n\nWhen you make a new version for today (60)\n\nProbably leave out colors (52) and\nInstead start with something with println! (likely 51)"
  },
  {
    "objectID": "60_test.rjs.html#todays-starting-point",
    "href": "60_test.rjs.html#todays-starting-point",
    "title": "Test",
    "section": "Today‚Äôs Starting Point",
    "text": "Today‚Äôs Starting Point\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\nmod vga;\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello world!\");\n    loop {}\n}"
  },
  {
    "objectID": "60_test.rjs.html#adding-to-main",
    "href": "60_test.rjs.html#adding-to-main",
    "title": "Test",
    "section": "Adding to Main",
    "text": "Adding to Main\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n#![feature(custom_test_frameworks)]\n#![test_runner(crate::test_runner)]\n\nmod vga;\n\n#[cfg(test)]\npub fn test_runner(tests: &[&dyn Fn()]) {\n    println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test();\n    }\n}\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello world!\");\n    loop {}\n}"
  },
  {
    "objectID": "60_test.rjs.html#wait-a-minute",
    "href": "60_test.rjs.html#wait-a-minute",
    "title": "Test",
    "section": "Wait a minute",
    "text": "Wait a minute\n\nWhat is &dyn?\n‚ÄúKeyword dyn\n\n\nThe dyn keyword is used to highlight that calls to methods on the associated Trait are dynamically dispatched."
  },
  {
    "objectID": "60_test.rjs.html#dynamic-dispatch",
    "href": "60_test.rjs.html#dynamic-dispatch",
    "title": "Test",
    "section": "Dynamic Dispatch",
    "text": "Dynamic Dispatch\n\nIn computer science, dynamic dispatch is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time. It is commonly employed in, and considered a prime characteristic of, object-oriented programming (OOP) languages and systems."
  },
  {
    "objectID": "60_test.rjs.html#oop",
    "href": "60_test.rjs.html#oop",
    "title": "Test",
    "section": "OOP",
    "text": "OOP\n\nYeah I‚Äôm not doing that.\nWe‚Äôll maintain a list of functions.\nIf you want to learn about OOP, here is a tutorial on writing a Java app for Android.\n\nCreate your first Android app\nWhoops its Kotlin (multi-paradigm).\nYet more evidence of the correctness of OOP."
  },
  {
    "objectID": "60_test.rjs.html#write-two-functions",
    "href": "60_test.rjs.html#write-two-functions",
    "title": "Test",
    "section": "Write Two Functions",
    "text": "Write Two Functions\n\nDoesn‚Äôt matter but nice to have externally observable functions.\n\n\n\nsrc/main.rs\n\nfn hi() {\n    println!(\"Hello world!\");\n    return;\n}\n\nfn bye() {\n    println!(\"Goodbye space!\");\n    return;\n}"
  },
  {
    "objectID": "60_test.rjs.html#make-an-array",
    "href": "60_test.rjs.html#make-an-array",
    "title": "Test",
    "section": "Make an array",
    "text": "Make an array\n\nJust in _start for now.\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    let fs = [hi, bye];"
  },
  {
    "objectID": "60_test.rjs.html#loop-over-the-array",
    "href": "60_test.rjs.html#loop-over-the-array",
    "title": "Test",
    "section": "Loop over the array",
    "text": "Loop over the array\n\nSame as any other for each loop.\n\nI am willing to use the for each loop, but still regard it with suspicion.\n\n\n\n\nsrc/main.rs\n\n    let fs = [hi, bye];\n    for f in fs {\n        todo!();\n    }"
  },
  {
    "objectID": "60_test.rjs.html#call-each-function",
    "href": "60_test.rjs.html#call-each-function",
    "title": "Test",
    "section": "Call each function",
    "text": "Call each function\n\nWhat do you see?\n\n\n\nsrc/main.rs\n\n    let fs = [hi, bye];\n    for f in fs {\n        f();\n    }"
  },
  {
    "objectID": "60_test.rjs.html#sample-out",
    "href": "60_test.rjs.html#sample-out",
    "title": "Test",
    "section": "Sample out",
    "text": "Sample out"
  },
  {
    "objectID": "60_test.rjs.html#pulling-back-the-curtain",
    "href": "60_test.rjs.html#pulling-back-the-curtain",
    "title": "Test",
    "section": "Pulling back the curtain",
    "text": "Pulling back the curtain\n\nI‚Äôm insane.\nI ran this then screendumped (in QEMU) to fs.ppm\nI converted to .png\n\npython3 -c \"from PIL import Image; Image.open('fs.ppm').save('fs.png')\"\n\nI base64 the PNG.\n\nSee next slide."
  },
  {
    "objectID": "60_test.rjs.html#its-tiny",
    "href": "60_test.rjs.html#its-tiny",
    "title": "Test",
    "section": "It‚Äôs tiny!",
    "text": "It‚Äôs tiny!\n$ base64 fs.png | wc\n     25      25    1861\n$ base64 fs.png\niVBORw0KGgoAAAANSUhEUgAAAtAAAAGQCAIAAAAIhcA6AAAFJ0lEQVR4nO3dyXaDIBQAUMzp//9y\nujAlVgw+p4TovasaFKEb8DGlBAAAAPDtuvv9nlLquq6/Hl3W9TdP3l9JakS9hLNVa7ZeANCg25aH\nK41u++1xvYSvUnNHJP8BAMza1OEAAIj4qSePvuO3xy1WZFgOYQx/eZVhvmfF4I7oBQDs6xHhuP8Z\npuU2u5c2t8TvzHB4uehd9Ska+ff2x4wAoB2PCMcoMDD07Z/7i3oGJoQCwBFmhlRSS63vlt5AO7UA\ngAua73Awou8CAEstWKVSTvJ4p3bWo372/wAA32hm46/6opJhajBp3bKXcu7nbAkrZQuWMK9wmaya\nOAcAAAA0pKuMDviIBwB2YadRAAAAAAAAAIDPiy4iXaE8NW3FOWqnYTEtAFd2S/+PQEv77axVNq6X\nbW7b2bUMAD7iNvryvmyfAAA4zsRZKsGNQeObkJbK8YUtG57W31I+lTOfHOIJbp9aeSpeQgC4iNo+\nHMOhltFoSyUpBeYrLBq7qb9rxVP5cjLD2Uot/W8kASQALu8Z4dhr3mhwdmQfYOhb/Xi2caP84zUK\nvqjM0PwMAHjl2eHYd8bo7lb0gXKfI/54eUrcoSUEgIs4+dbmuy+92V4SALigWyPtcVwOWsRvO6KO\nlWJMJgWLDQCnNLEl13Bexbp1GaPchqnxDINPVXyw8K9meAhyAEBDjo4HiDcAwDu1OIdDMAAATqaV\nRv2dG2cdcXAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ/ULzGetS97yp6YAAAAA\nSUVORK5CYII="
  },
  {
    "objectID": "60_test.rjs.html#to-html",
    "href": "60_test.rjs.html#to-html",
    "title": "Test",
    "section": "To HTML",
    "text": "To HTML\n\nI read this stackoverflow answer\nIt contains this snippet\n\n&lt;div&gt;\n  &lt;p&gt;Taken from wikpedia&lt;/p&gt;\n  &lt;img src=\"data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAUA\n    AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n        9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" /&gt;\n&lt;/div&gt;\n\nI only need this:\n\n&lt;img src=\"data:image/png;base64, \"&gt;"
  },
  {
    "objectID": "60_test.rjs.html#here-it-is",
    "href": "60_test.rjs.html#here-it-is",
    "title": "Test",
    "section": "Here it is",
    "text": "Here it is\n\nAnd then I placed that exact HTML within my Markdown.\n\nWith the base64 PNG data within."
  },
  {
    "objectID": "60_test.rjs.html#by-the-way",
    "href": "60_test.rjs.html#by-the-way",
    "title": "Test",
    "section": "By the way",
    "text": "By the way\n\nYou can use that as a URL.\nClick me\nOkay back to work."
  },
  {
    "objectID": "60_test.rjs.html#wait-just-kidding",
    "href": "60_test.rjs.html#wait-just-kidding",
    "title": "Test",
    "section": "Wait Just Kidding",
    "text": "Wait Just Kidding\n\nManually edit the data.\nDelete exactly 24 A values in the big block.\n\n24 values at 6 bits of information each yields 144 bits or 18 bytes.\nWhat do you see?\nWhat if you delete not a multiple of 24?\nWhat if you delete a different 24?"
  },
  {
    "objectID": "60_test.rjs.html#quote-me",
    "href": "60_test.rjs.html#quote-me",
    "title": "Test",
    "section": "Quote Me",
    "text": "Quote Me\n\n‚ÄúThey‚Äôre my bits, in my computer - let me use them!‚Äù"
  },
  {
    "objectID": "60_test.rjs.html#recall",
    "href": "60_test.rjs.html#recall",
    "title": "Test",
    "section": "Recall",
    "text": "Recall\n\nRust is trying to get us to write Java instead of C.\n\n\n\nsrc/main.rs\n\n#[cfg(test)]\npub fn test_runner(tests: &[&dyn Fn()]) {\n    println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test();\n    }\n}"
  },
  {
    "objectID": "60_test.rjs.html#outsmart-rust",
    "href": "60_test.rjs.html#outsmart-rust",
    "title": "Test",
    "section": "Outsmart Rust",
    "text": "Outsmart Rust\n\nIgnore the argument via _\nInclude the stuff from inside _start.\n\n\n\nsrc/main.rs\n\n#[cfg(test)]\npub fn test_runner(_tests: &[&dyn Fn()]) {\n    let fs = [hi, bye];\n    println!(\"Running {} tests\", fs.len());\n    for f in fs {\n        f();\n    }\n}\n\n\nProbably change main too so you know what is running, mine says ‚ÄúI‚Äôm main‚Äù."
  },
  {
    "objectID": "60_test.rjs.html#check-it",
    "href": "60_test.rjs.html#check-it",
    "title": "Test",
    "section": "Check it",
    "text": "Check it\n\nYou can run the tests via:\n\ncargo +nightly t\n\nWow that +nightly is getting annoying.\n\nTime for an aside."
  },
  {
    "objectID": "60_test.rjs.html#back-to-stack",
    "href": "60_test.rjs.html#back-to-stack",
    "title": "Test",
    "section": "Back to Stack",
    "text": "Back to Stack\n\nI love stackoverflow.\n\nToo bad it is slowly being incinerated by generative AI\nSurely this will lead to no long-term problems.\n\nCheck out this answer"
  },
  {
    "objectID": "60_test.rjs.html#it-states",
    "href": "60_test.rjs.html#it-states",
    "title": "Test",
    "section": "It states",
    "text": "It states\n\nyou can add a rust-toolchain.toml file, for example\n\n\n\nrust-toolchain.toml\n\n[toolchain]\nchannel = \"nightly\"\n\n\nI am doing this now."
  },
  {
    "objectID": "60_test.rjs.html#what-i-see",
    "href": "60_test.rjs.html#what-i-see",
    "title": "Test",
    "section": "What I see",
    "text": "What I see\n\nI removed my target for clarity.\n\n$ rm -rf target/\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ rust-toolchain.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.rs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vga.rs\n‚îî‚îÄ‚îÄ x86_64-osirs.json\n\n1 directory, 6 files"
  },
  {
    "objectID": "60_test.rjs.html#the-other-way",
    "href": "60_test.rjs.html#the-other-way",
    "title": "Test",
    "section": "The other way",
    "text": "The other way\n\nIf you wish to use nightly in all projects, you can check this answer.\nThere are a variety of intermediate ways, of course.\nOkay back to work."
  },
  {
    "objectID": "60_test.rjs.html#recall-1",
    "href": "60_test.rjs.html#recall-1",
    "title": "Test",
    "section": "Recall",
    "text": "Recall\n\nWe were trying to run tests.\n\ncargo t # FINALLY\n\nYou may notice this is just running _start.\nThat is because src/main.rs is a fan of the Black Eyed Peas.\n\nLearn more\nNote to Calvin - do not click that in class."
  },
  {
    "objectID": "60_test.rjs.html#surprise",
    "href": "60_test.rjs.html#surprise",
    "title": "Test",
    "section": "Surprise!",
    "text": "Surprise!\n\nSomething not going as planned on the first try?\nOur _start function is still used as entry point.\n\nIt is, after all, the _start function."
  },
  {
    "objectID": "60_test.rjs.html#the-problem",
    "href": "60_test.rjs.html#the-problem",
    "title": "Test",
    "section": "The Problem",
    "text": "The Problem\n\nThe custom test frameworks feature generates a main function that calls test_runner\n\nWhat is it for? Software?\nMight as well use Kotlin!\n\nOur OS, of course, never calls main."
  },
  {
    "objectID": "60_test.rjs.html#maybe-problem",
    "href": "60_test.rjs.html#maybe-problem",
    "title": "Test",
    "section": "Maybe problem",
    "text": "Maybe problem\n\nIf you see ‚Äúduplicate lang item‚Äù expand:\n\n\nNote: There is currently a bug in cargo that leads to ‚Äúduplicate lang item‚Äù errors on cargo test in some cases. It occurs when you have set panic = \"abort\" for a profile in your Cargo.toml. Try removing it, then cargo test should work. Alternatively, if that doesn‚Äôt work, then add panic-abort-tests = true to the [unstable] section of your .cargo/config.toml file. See the cargo issue for more information on this."
  },
  {
    "objectID": "60_test.rjs.html#fine-ill-do-it-myself",
    "href": "60_test.rjs.html#fine-ill-do-it-myself",
    "title": "Test",
    "section": "Fine, I‚Äôll do it myself",
    "text": "Fine, I‚Äôll do it myself\n\nSimply call test_runner from _start\n\nIt needs a borrowed array of whatevers, so give it one.\n\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"I'm main.\");\n    test_runner(&[]);\n    loop {}\n}"
  },
  {
    "objectID": "60_test.rjs.html#only-problem",
    "href": "60_test.rjs.html#only-problem",
    "title": "Test",
    "section": "Only problem",
    "text": "Only problem\n\nWhat if we run instead of test?\n\n$ cargo r\n   Compiling osirs v0.1.0 (/home/user/tmp/work)\nerror[E0423]: expected function, found built-in attribute `test_runner`\n  --&gt; src/main.rs:26:5\n   |\n26 |     test_runner(&[]);\n   |     ^^^^^^^^^^^ not a function\n   |\nnote: found an item that was configured out\n  --&gt; src/main.rs:9:4\n   |\n 8 | #[cfg(test)]\n   |       ---- the item is gated here\n 9 | fn test_runner(_tests: &[&dyn Fn()]) {\n   |    ^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "60_test.rjs.html#conditional-compilation",
    "href": "60_test.rjs.html#conditional-compilation",
    "title": "Test",
    "section": "Conditional Compilation",
    "text": "Conditional Compilation\n\nWe need to conditionally compile _start to either call test_runner or not.\nNo problem, we already know how to do this!\n#[cfg(test)]\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"I'm main{}\", \".\");\n\n    #[cfg(test)]\n    test_runner(&[]);\n\n    loop {}\n}"
  },
  {
    "objectID": "60_test.rjs.html#only-problem-1",
    "href": "60_test.rjs.html#only-problem-1",
    "title": "Test",
    "section": "Only problem",
    "text": "Only problem\n\nWhat if we run instead of test?\n\n$ cargo r\n   Compiling osirs v0.1.0 (/home/user/tmp/work)\nwarning: function `hi` is never used\n  --&gt; src/main.rs:32:4\n   |\n32 | fn hi() {\n   |    ^^\n   |\n   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\nwarning: function `bye` is never used\n  --&gt; src/main.rs:37:4\n   |\n37 | fn bye() {\n   |    ^^^"
  },
  {
    "objectID": "60_test.rjs.html#correct-way",
    "href": "60_test.rjs.html#correct-way",
    "title": "Test",
    "section": "Correct Way",
    "text": "Correct Way\n\nThere is a correct way to solve this.\nSeparately, there is the opposite: my way.\nI renamed them with a _ prefix.\n\n    for f in [_hi, _bye] {\n        f();\n    }\n\nThe correct way is left as an exercise to the interested student."
  },
  {
    "objectID": "60_test.rjs.html#writing-tests",
    "href": "60_test.rjs.html#writing-tests",
    "title": "Test",
    "section": "Writing Tests",
    "text": "Writing Tests\n\nBy convention, we don‚Äôt simply print nonsense as a test.\n\nIt so happens in our OS, printing was a whole thing, but this is atypical for non-OS applications.\n\nA much more common thing to test is an assertion.\n\nAn expression we claim to evaluate to true"
  },
  {
    "objectID": "60_test.rjs.html#a-test",
    "href": "60_test.rjs.html#a-test",
    "title": "Test",
    "section": "A Test",
    "text": "A Test\n\nLet‚Äôs just make a sample assertion.\n\nI will take expression that will evaluate to true\nI will apply the assert! macro to the expression\nI will invoke this macro within a function.\nI will include the function in the test_runner array of functions."
  },
  {
    "objectID": "60_test.rjs.html#example",
    "href": "60_test.rjs.html#example",
    "title": "Test",
    "section": "Example",
    "text": "Example\n\n\nsrc/main.rs\n\nfn _ex() {\n    assert(true);\n}\n\n\nThere‚Äôs a minor annoyance here.\n\nWe can‚Äôt tell if it‚Äôs running at all."
  },
  {
    "objectID": "60_test.rjs.html#update-test_runner",
    "href": "60_test.rjs.html#update-test_runner",
    "title": "Test",
    "section": "Update test_runner",
    "text": "Update test_runner\n\nBy the way, I remove _hi and _bye at this time.\nI then just enumerate my tests in an array.\nLoop over the range of the length of the array.\n\nSay I‚Äôm running test \\(i\\)\nRun test \\(i\\)\nSay it‚Äôs gucci"
  },
  {
    "objectID": "60_test.rjs.html#my-test_runner",
    "href": "60_test.rjs.html#my-test_runner",
    "title": "Test",
    "section": "My test_runner",
    "text": "My test_runner\n\nFor each could never.\n\n\n\nsrc/main.rs\n\n#[cfg(test)]\nfn test_runner(_tests: &[&dyn Fn()]) {\n    let fs = [_ex];\n    for i in 0..fs.len() {\n        print!(\"Running test case {:0x}\", i);\n        fs[i]();\n        println!(\"Success.\");\n    }\n}"
  },
  {
    "objectID": "60_test.rjs.html#now-what",
    "href": "60_test.rjs.html#now-what",
    "title": "Test",
    "section": "Now what?",
    "text": "Now what?\n\ntest_runner returns to _start function\n_start contains an infinite loop\n\nWe recall the entry point function is not allowed to return.\n\nWe probably want cargo t to exit after running all tests."
  },
  {
    "objectID": "60_test.rjs.html#winners-never",
    "href": "60_test.rjs.html#winners-never",
    "title": "Test",
    "section": "Winners Never",
    "text": "Winners Never\n\nWe want to quit QEMU.\n\nYes, quitting, the thing winners never do.\n\nThis is extremely helpful if both:\n\n\nHave code you want to test, and\nHave a finite life expectancy."
  },
  {
    "objectID": "60_test.rjs.html#os-shutdown",
    "href": "60_test.rjs.html#os-shutdown",
    "title": "Test",
    "section": "OS Shutdown",
    "text": "OS Shutdown\n\nFolks, its hard.\nBig Blog references these two power management standards.\n\nBoth are good uses of your time outside of class.\n\nAPM\nACPI"
  },
  {
    "objectID": "60_test.rjs.html#qemu-to-the-resq",
    "href": "60_test.rjs.html#qemu-to-the-resq",
    "title": "Test",
    "section": "QEMU to the RESQ",
    "text": "QEMU to the RESQ\n\nQEMU includes a debug exit!\nisa-debug-exit.\n\nWe pass a -device argument to qemu\nWe pass via the bootimage crate.\nWe specify in Cargo.toml\n\nThis only occurs while testing!\n\n\n\nCargo.toml\n\n[package.metadata.bootimage]\ntest-args = [\"-device\", \"isa-debug-exit,iobase=0xf4,iosize=0x04\"]"
  },
  {
    "objectID": "60_test.rjs.html#make-sure-this-works",
    "href": "60_test.rjs.html#make-sure-this-works",
    "title": "Test",
    "section": "Make Sure This Works",
    "text": "Make Sure This Works\n\nYou can just cargo t (and also cargo r) and verify the qemu command differs.\n(Scroll)\n\n\n\n$ cargo t\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.06s\n     Running unittests src/main.rs (target/x86_64-osirs/debug/deps/osirs-577ad3ee7fc7cc13)\nBuilding bootloader\n   Compiling bootloader v0.9.34 (/home/calvin/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bootloader-0.9.34)\n    Finished `release` profile [optimized + debuginfo] target(s) in 0.83s\nRunning: `qemu-system-x86_64 -drive format=raw,file=/home/calvin/tmp/work/target/x86_64-osirs/debug/deps/bootimage-osirs-577ad3ee7fc7cc13.bin -no-reboot -device isa-debug-exit,iobase=0xf4,iosize=0x04`\n\n$ cargo r\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s\n     Running `bootimage runner target/x86_64-osirs/debug/osirs`\nBuilding bootloader\n   Compiling bootloader v0.9.34 (/home/calvin/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bootloader-0.9.34)\n    Finished `release` profile [optimized + debuginfo] target(s) in 0.84s\nRunning: `qemu-system-x86_64 -drive format=raw,file=target/x86_64-osirs/debug/bootimage-osirs.bin`"
  },
  {
    "objectID": "60_test.rjs.html#io-ports",
    "href": "60_test.rjs.html#io-ports",
    "title": "Test",
    "section": "I/O Ports",
    "text": "I/O Ports\n\nRecall memory-mapped I/O.\nThere is also port-mapped I/O.\nThis uses a separate I/O bus for communication.\n\nIt makes sense QEMU uses this as it is not actual physical hardware!"
  },
  {
    "objectID": "60_test.rjs.html#imagine",
    "href": "60_test.rjs.html#imagine",
    "title": "Test",
    "section": "Imagine",
    "text": "Imagine\n\nEach connected peripheral (mouse, monitor, power supply) has one or more port numbers.\nTo communicate with such an I/O port, use special hardware level instructions.\n\nin and out\n\nThese take a port number and a data byte"
  },
  {
    "objectID": "60_test.rjs.html#usage",
    "href": "60_test.rjs.html#usage",
    "title": "Test",
    "section": "Usage",
    "text": "Usage\n\nThe isa-debug-exit device uses port-mapped I/O.\n\nisa = instruction set architecture\nAn example instruction is in or out\n\nThe iobase parameter specifies the port address of the (imaginary) device\n0xf4 is a generally unused port\nThe iosize specifies the port size (0x04 means four bytes)."
  },
  {
    "objectID": "60_test.rjs.html#the-device",
    "href": "60_test.rjs.html#the-device",
    "title": "Test",
    "section": "The Device",
    "text": "The Device\n\nisa-debug-exit is simple.\nWhen a value v is written to the I/O port specified by iobase, QEMU to exits with exit status (v &lt;&lt; 1) | 1.\nSo when we write 0 to the port, QEMU will exit with (0 &lt;&lt; 1) | 1 = 1,\nExit status is more interesting to C coders, and not used much anymore."
  },
  {
    "objectID": "60_test.rjs.html#handwave-assembly",
    "href": "60_test.rjs.html#handwave-assembly",
    "title": "Test",
    "section": "Handwave assembly",
    "text": "Handwave assembly\n\nVs. manually invoking in and out\n\nThat is for the compilers class\nLive on YT Sp27 unless I get fired for not liking AI.\n\nWe use the x86_64 crate.\nAdd to [dependencies] in Cargo.toml:\n\n\n\nCargo.toml\n\n[dependencies]\nbootloader = \"0.9\"\nx86_64 = \"0.14.2\""
  },
  {
    "objectID": "60_test.rjs.html#port",
    "href": "60_test.rjs.html#port",
    "title": "Test",
    "section": "Port",
    "text": "Port\n\nNot just a type of land!\nWe will use ‚ÄúPort‚Äù to gracefully exit.\nMake one:\n\n    unsafe {\n        let mut port = x86_64::instructions::port::Port::new(0xf4);\n    }"
  },
  {
    "objectID": "60_test.rjs.html#write-to-it",
    "href": "60_test.rjs.html#write-to-it",
    "title": "Test",
    "section": "Write to it",
    "text": "Write to it\n\nI use 0xA, you can use anything.\n\nCould e.g.¬†return number of failed test.\nZero will collide with a general QEMU error.\nDoes need to be a u32 because we said we would.\n\n\n    unsafe {\n        x86_64::instructions::port::Port::new(0xf4).write(0xAu32);\n    }"
  },
  {
    "objectID": "60_test.rjs.html#test-exit",
    "href": "60_test.rjs.html#test-exit",
    "title": "Test",
    "section": "Test Exit",
    "text": "Test Exit\n\nJust add those lines to the end of test_runner and you should be good to go!\n\n$ cargo t\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.07s\n     Running unittests src/main.rs (target/x86_64-osirs/debug/deps/osirs-429ccf0d82ba9f9c)\nBuilding bootloader\n    Finished `release` profile [optimized + debuginfo] target(s) in 0.07s\nRunning: `qemu-system-x86_64 -drive format=raw,file=/home/calvin/tmp/work/target/x86_64-osirs/debug/deps/bootimage-osirs-429ccf0d82ba9f9c.bin -no-reboot -device isa-debug-exit,iobase=0xf4,iosize=0x04`\nerror: test failed, to rerun pass `--bin osirs`\n\nCaused by:\n  process didn't exit successfully: `bootimage runner /home/calvin/tmp/work/target/x86_64-osirs/debug/deps/osirs-429ccf0d82ba9f9c` (exit status: 21)\nnote: test exited abnormally; to see the full output pass --no-capture to the harness.\n$"
  },
  {
    "objectID": "60_test.rjs.html#exit-status",
    "href": "60_test.rjs.html#exit-status",
    "title": "Test",
    "section": "Exit Status",
    "text": "Exit Status\n\nWe are providing an exit status other than cargo t expects and being admonished.\n\nThe audacity.\n\nWe just specify the expected exit status in Cargo.toml\n\n\n\nCargo.toml\n\n[package.metadata.bootimage]\ntest-args = [\"-device\", \"isa-debug-exit,iobase=0xf4,iosize=0x04\"]\ntest-success-exit-code = 21\n\n\nAbsolute geniuses note ((0xA&lt;&lt;1)|1)==21"
  },
  {
    "objectID": "60_test.rjs.html#annoyance",
    "href": "60_test.rjs.html#annoyance",
    "title": "Test",
    "section": "Annoyance",
    "text": "Annoyance\n\nThere remains two annoying things here:\n\nThe QEMU window opens and then closes before we can see it, so we can‚Äôt see results.\nThe QEMU window opens so we are opening a graphics window unnecessarily, which inhibits automation."
  },
  {
    "objectID": "60_test.rjs.html#printing-to-the-console",
    "href": "60_test.rjs.html#printing-to-the-console",
    "title": "Test",
    "section": "Printing to the Console",
    "text": "Printing to the Console\n\nTo see the test output on the console, we need to send the data from our kernel to the host system somehow.\nThere are various ways to achieve this, for example, by sending the data over a TCP network interface.\n\nNetworks, live on YouTube Spring 2028."
  },
  {
    "objectID": "60_test.rjs.html#serial-ports",
    "href": "60_test.rjs.html#serial-ports",
    "title": "Test",
    "section": "Serial Ports",
    "text": "Serial Ports\n\nI expect we will be out of time by here.\nWe continue these efforts in the lab: Serial."
  },
  {
    "objectID": "60_test.html",
    "href": "60_test.html",
    "title": "Test",
    "section": "",
    "text": "Action Items:\n\nHow is graphics?\n\nAre you learning NumPy?\nAnyone using CUDA?",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#announcements",
    "href": "60_test.html#announcements",
    "title": "Test",
    "section": "",
    "text": "Action Items:\n\nHow is graphics?\n\nAre you learning NumPy?\nAnyone using CUDA?",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#citations",
    "href": "60_test.html#citations",
    "title": "Test",
    "section": "Citations",
    "text": "Citations\n\nI am geniunely convinced of the usefulness of automated testing when developing a system.\nThe most high profile case of this is the testing framework for 4096_t.c\nHard to persuade students of the usefulness of this on small class assignments.\n\\(\\therefore\\) I‚Äôve never written anything of any reasonable size in Rust, so\nTesting",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#today",
    "href": "60_test.html#today",
    "title": "Test",
    "section": "Today",
    "text": "Today\n\nTesting under no_std\nQEMU\nbootimage\n\nStill not in love with this dependency, but we do what we can.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#pre-work",
    "href": "60_test.html#pre-work",
    "title": "Test",
    "section": "Pre-work",
    "text": "Pre-work\n\nMake sure you have a .cargo/config.toml\nNo idea how you wouldn‚Äôt have one of these yet!\nJust make sure you have it.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#modern-language",
    "href": "60_test.html#modern-language",
    "title": "Test",
    "section": "Modern Language",
    "text": "Modern Language\n\nLike Python with Pytest, and unlike the only other systems language, Rust has a testing framework.\nIt‚Äôs covered in Rust book\nNaturally I skipped this chapter.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#framework",
    "href": "60_test.html#framework",
    "title": "Test",
    "section": "Framework",
    "text": "Framework\n\nUse the #[test] attribute on some functions.\nIncluding assertions within those functions.\ncargo test or, if you see someone around, cargo t, will check the assertions.\nThe crate will otherwise be non-impacted.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#review",
    "href": "60_test.html#review",
    "title": "Test",
    "section": "Review",
    "text": "Review\n\nTo enable testing for our kernel binary, we can set the test flag in the Cargo.toml to true.\nWe recall our Cargo.toml - mine no longer has an allusions to panic with the introduction of a JSON target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbootloader = \"0.9\"",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#enable",
    "href": "60_test.html#enable",
    "title": "Test",
    "section": "Enable",
    "text": "Enable\n\nThis is necessary but not sufficient.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbootloader = \"0.9\"\n\n[[bin]]\nname = \"osirs\"\ntest = true\nbench = false",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#on-bin",
    "href": "60_test.html#on-bin",
    "title": "Test",
    "section": "On [[bin]]",
    "text": "On [[bin]]\n\nThe double-bracket sections like [[bin]] are array-of-table of TOML, which means you can write more than one [[bin]] section to make several executables in your crate.\n\n\nJust one for us for now.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#working-within-no_std",
    "href": "60_test.html#working-within-no_std",
    "title": "Test",
    "section": "Working within no_std",
    "text": "Working within no_std\n\nTesting is complicated by no_std.\nRust implicitly uses the test library, which depends on std\n\nMore on test\n\n\n$ cargo t\n   Compiling bootloader v0.9.34\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `bootloader` (lib) due to 1 previous error",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#what-we-lose",
    "href": "60_test.html#what-we-lose",
    "title": "Test",
    "section": "What We Lose",
    "text": "What We Lose\n\nVs. std, we lose e.g.¬†should_panic tests.\n\nOn those\n\nThat‚Äôs okay, we are crafty (and wrote our own panic handler anyway).",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#to-main",
    "href": "60_test.html#to-main",
    "title": "Test",
    "section": "To Main",
    "text": "To Main\n\nMy main looks like this:\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\nmod colors;\nmod vga;\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    colors::colors();\n    colors::image();\n    loop {}\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#just-a-note",
    "href": "60_test.html#just-a-note",
    "title": "Test",
    "section": "Just a note",
    "text": "Just a note\n\nWhen you make a new version for today (60)\n\nProbably leave out colors (52) and\nInstead start with something with println! (likely 51)",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#todays-starting-point",
    "href": "60_test.html#todays-starting-point",
    "title": "Test",
    "section": "Today‚Äôs Starting Point",
    "text": "Today‚Äôs Starting Point\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\nmod vga;\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello world!\");\n    loop {}\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#adding-to-main",
    "href": "60_test.html#adding-to-main",
    "title": "Test",
    "section": "Adding to Main",
    "text": "Adding to Main\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n#![feature(custom_test_frameworks)]\n#![test_runner(crate::test_runner)]\n\nmod vga;\n\n#[cfg(test)]\npub fn test_runner(tests: &[&dyn Fn()]) {\n    println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test();\n    }\n}\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello world!\");\n    loop {}\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#wait-a-minute",
    "href": "60_test.html#wait-a-minute",
    "title": "Test",
    "section": "Wait a minute",
    "text": "Wait a minute\n\nWhat is &dyn?\n‚ÄúKeyword dyn\n\n\nThe dyn keyword is used to highlight that calls to methods on the associated Trait are dynamically dispatched.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#dynamic-dispatch",
    "href": "60_test.html#dynamic-dispatch",
    "title": "Test",
    "section": "Dynamic Dispatch",
    "text": "Dynamic Dispatch\n\nIn computer science, dynamic dispatch is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time. It is commonly employed in, and considered a prime characteristic of, object-oriented programming (OOP) languages and systems.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#oop",
    "href": "60_test.html#oop",
    "title": "Test",
    "section": "OOP",
    "text": "OOP\n\nYeah I‚Äôm not doing that.\nWe‚Äôll maintain a list of functions.\nIf you want to learn about OOP, here is a tutorial on writing a Java app for Android.\n\nCreate your first Android app\nWhoops its Kotlin (multi-paradigm).\nYet more evidence of the correctness of OOP.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#write-two-functions",
    "href": "60_test.html#write-two-functions",
    "title": "Test",
    "section": "Write Two Functions",
    "text": "Write Two Functions\n\nDoesn‚Äôt matter but nice to have externally observable functions.\n\n\n\nsrc/main.rs\n\nfn hi() {\n    println!(\"Hello world!\");\n    return;\n}\n\nfn bye() {\n    println!(\"Goodbye space!\");\n    return;\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#make-an-array",
    "href": "60_test.html#make-an-array",
    "title": "Test",
    "section": "Make an array",
    "text": "Make an array\n\nJust in _start for now.\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    let fs = [hi, bye];",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#loop-over-the-array",
    "href": "60_test.html#loop-over-the-array",
    "title": "Test",
    "section": "Loop over the array",
    "text": "Loop over the array\n\nSame as any other for each loop.\n\nI am willing to use the for each loop, but still regard it with suspicion.\n\n\n\n\nsrc/main.rs\n\n    let fs = [hi, bye];\n    for f in fs {\n        todo!();\n    }",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#call-each-function",
    "href": "60_test.html#call-each-function",
    "title": "Test",
    "section": "Call each function",
    "text": "Call each function\n\nWhat do you see?\n\n\n\nsrc/main.rs\n\n    let fs = [hi, bye];\n    for f in fs {\n        f();\n    }",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#sample-out",
    "href": "60_test.html#sample-out",
    "title": "Test",
    "section": "Sample out",
    "text": "Sample out",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#pulling-back-the-curtain",
    "href": "60_test.html#pulling-back-the-curtain",
    "title": "Test",
    "section": "Pulling back the curtain",
    "text": "Pulling back the curtain\n\nI‚Äôm insane.\nI ran this then screendumped (in QEMU) to fs.ppm\nI converted to .png\n\npython3 -c \"from PIL import Image; Image.open('fs.ppm').save('fs.png')\"\n\nI base64 the PNG.\n\nSee next slide.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#its-tiny",
    "href": "60_test.html#its-tiny",
    "title": "Test",
    "section": "It‚Äôs tiny!",
    "text": "It‚Äôs tiny!\n$ base64 fs.png | wc\n     25      25    1861\n$ base64 fs.png\niVBORw0KGgoAAAANSUhEUgAAAtAAAAGQCAIAAAAIhcA6AAAFJ0lEQVR4nO3dyXaDIBQAUMzp//9y\nujAlVgw+p4TovasaFKEb8DGlBAAAAPDtuvv9nlLquq6/Hl3W9TdP3l9JakS9hLNVa7ZeANCg25aH\nK41u++1xvYSvUnNHJP8BAMza1OEAAIj4qSePvuO3xy1WZFgOYQx/eZVhvmfF4I7oBQDs6xHhuP8Z\npuU2u5c2t8TvzHB4uehd9Ska+ff2x4wAoB2PCMcoMDD07Z/7i3oGJoQCwBFmhlRSS63vlt5AO7UA\ngAua73Awou8CAEstWKVSTvJ4p3bWo372/wAA32hm46/6opJhajBp3bKXcu7nbAkrZQuWMK9wmaya\nOAcAAAA0pKuMDviIBwB2YadRAAAAAAAAAIDPiy4iXaE8NW3FOWqnYTEtAFd2S/+PQEv77axVNq6X\nbW7b2bUMAD7iNvryvmyfAAA4zsRZKsGNQeObkJbK8YUtG57W31I+lTOfHOIJbp9aeSpeQgC4iNo+\nHMOhltFoSyUpBeYrLBq7qb9rxVP5cjLD2Uot/W8kASQALu8Z4dhr3mhwdmQfYOhb/Xi2caP84zUK\nvqjM0PwMAHjl2eHYd8bo7lb0gXKfI/54eUrcoSUEgIs4+dbmuy+92V4SALigWyPtcVwOWsRvO6KO\nlWJMJgWLDQCnNLEl13Bexbp1GaPchqnxDINPVXyw8K9meAhyAEBDjo4HiDcAwDu1OIdDMAAATqaV\nRv2dG2cdcXAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ/ULzGetS97yp6YAAAAA\nSUVORK5CYII=",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#to-html",
    "href": "60_test.html#to-html",
    "title": "Test",
    "section": "To HTML",
    "text": "To HTML\n\nI read this stackoverflow answer\nIt contains this snippet\n\n&lt;div&gt;\n  &lt;p&gt;Taken from wikpedia&lt;/p&gt;\n  &lt;img src=\"data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAUA\n    AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n        9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" /&gt;\n&lt;/div&gt;\n\nI only need this:\n\n&lt;img src=\"data:image/png;base64, \"&gt;",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#here-it-is",
    "href": "60_test.html#here-it-is",
    "title": "Test",
    "section": "Here it is",
    "text": "Here it is\n\nAnd then I placed that exact HTML within my Markdown.\n\nWith the base64 PNG data within.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#by-the-way",
    "href": "60_test.html#by-the-way",
    "title": "Test",
    "section": "By the way",
    "text": "By the way\n\nYou can use that as a URL.\nClick me\nOkay back to work.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#wait-just-kidding",
    "href": "60_test.html#wait-just-kidding",
    "title": "Test",
    "section": "Wait Just Kidding",
    "text": "Wait Just Kidding\n\nManually edit the data.\nDelete exactly 24 A values in the big block.\n\n24 values at 6 bits of information each yields 144 bits or 18 bytes.\nWhat do you see?\nWhat if you delete not a multiple of 24?\nWhat if you delete a different 24?",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#quote-me",
    "href": "60_test.html#quote-me",
    "title": "Test",
    "section": "Quote Me",
    "text": "Quote Me\n\n‚ÄúThey‚Äôre my bits, in my computer - let me use them!‚Äù",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#recall",
    "href": "60_test.html#recall",
    "title": "Test",
    "section": "Recall",
    "text": "Recall\n\nRust is trying to get us to write Java instead of C.\n\n\n\nsrc/main.rs\n\n#[cfg(test)]\npub fn test_runner(tests: &[&dyn Fn()]) {\n    println!(\"Running {} tests\", tests.len());\n    for test in tests {\n        test();\n    }\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#outsmart-rust",
    "href": "60_test.html#outsmart-rust",
    "title": "Test",
    "section": "Outsmart Rust",
    "text": "Outsmart Rust\n\nIgnore the argument via _\nInclude the stuff from inside _start.\n\n\n\nsrc/main.rs\n\n#[cfg(test)]\npub fn test_runner(_tests: &[&dyn Fn()]) {\n    let fs = [hi, bye];\n    println!(\"Running {} tests\", fs.len());\n    for f in fs {\n        f();\n    }\n}\n\n\nProbably change main too so you know what is running, mine says ‚ÄúI‚Äôm main‚Äù.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#check-it",
    "href": "60_test.html#check-it",
    "title": "Test",
    "section": "Check it",
    "text": "Check it\n\nYou can run the tests via:\n\ncargo +nightly t\n\nWow that +nightly is getting annoying.\n\nTime for an aside.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#back-to-stack",
    "href": "60_test.html#back-to-stack",
    "title": "Test",
    "section": "Back to Stack",
    "text": "Back to Stack\n\nI love stackoverflow.\n\nToo bad it is slowly being incinerated by generative AI\nSurely this will lead to no long-term problems.\n\nCheck out this answer",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#it-states",
    "href": "60_test.html#it-states",
    "title": "Test",
    "section": "It states",
    "text": "It states\n\nyou can add a rust-toolchain.toml file, for example\n\n\n\nrust-toolchain.toml\n\n[toolchain]\nchannel = \"nightly\"\n\n\nI am doing this now.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#what-i-see",
    "href": "60_test.html#what-i-see",
    "title": "Test",
    "section": "What I see",
    "text": "What I see\n\nI removed my target for clarity.\n\n$ rm -rf target/\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ rust-toolchain.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.rs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vga.rs\n‚îî‚îÄ‚îÄ x86_64-osirs.json\n\n1 directory, 6 files",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#the-other-way",
    "href": "60_test.html#the-other-way",
    "title": "Test",
    "section": "The other way",
    "text": "The other way\n\nIf you wish to use nightly in all projects, you can check this answer.\nThere are a variety of intermediate ways, of course.\nOkay back to work.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#recall-1",
    "href": "60_test.html#recall-1",
    "title": "Test",
    "section": "Recall",
    "text": "Recall\n\nWe were trying to run tests.\n\ncargo t # FINALLY\n\nYou may notice this is just running _start.\nThat is because src/main.rs is a fan of the Black Eyed Peas.\n\nLearn more\nNote to Calvin - do not click that in class.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#surprise",
    "href": "60_test.html#surprise",
    "title": "Test",
    "section": "Surprise!",
    "text": "Surprise!\n\nSomething not going as planned on the first try?\nOur _start function is still used as entry point.\n\nIt is, after all, the _start function.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#the-problem",
    "href": "60_test.html#the-problem",
    "title": "Test",
    "section": "The Problem",
    "text": "The Problem\n\nThe custom test frameworks feature generates a main function that calls test_runner\n\nWhat is it for? Software?\nMight as well use Kotlin!\n\nOur OS, of course, never calls main.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#maybe-problem",
    "href": "60_test.html#maybe-problem",
    "title": "Test",
    "section": "Maybe problem",
    "text": "Maybe problem\n\nIf you see ‚Äúduplicate lang item‚Äù expand:\n\n\nNote: There is currently a bug in cargo that leads to ‚Äúduplicate lang item‚Äù errors on cargo test in some cases. It occurs when you have set panic = \"abort\" for a profile in your Cargo.toml. Try removing it, then cargo test should work. Alternatively, if that doesn‚Äôt work, then add panic-abort-tests = true to the [unstable] section of your .cargo/config.toml file. See the cargo issue for more information on this.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#fine-ill-do-it-myself",
    "href": "60_test.html#fine-ill-do-it-myself",
    "title": "Test",
    "section": "Fine, I‚Äôll do it myself",
    "text": "Fine, I‚Äôll do it myself\n\nSimply call test_runner from _start\n\nIt needs a borrowed array of whatevers, so give it one.\n\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"I'm main.\");\n    test_runner(&[]);\n    loop {}\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#only-problem",
    "href": "60_test.html#only-problem",
    "title": "Test",
    "section": "Only problem",
    "text": "Only problem\n\nWhat if we run instead of test?\n\n$ cargo r\n   Compiling osirs v0.1.0 (/home/user/tmp/work)\nerror[E0423]: expected function, found built-in attribute `test_runner`\n  --&gt; src/main.rs:26:5\n   |\n26 |     test_runner(&[]);\n   |     ^^^^^^^^^^^ not a function\n   |\nnote: found an item that was configured out\n  --&gt; src/main.rs:9:4\n   |\n 8 | #[cfg(test)]\n   |       ---- the item is gated here\n 9 | fn test_runner(_tests: &[&dyn Fn()]) {\n   |    ^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#conditional-compilation",
    "href": "60_test.html#conditional-compilation",
    "title": "Test",
    "section": "Conditional Compilation",
    "text": "Conditional Compilation\n\nWe need to conditionally compile _start to either call test_runner or not.\nNo problem, we already know how to do this!\n#[cfg(test)]\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"I'm main{}\", \".\");\n\n    #[cfg(test)]\n    test_runner(&[]);\n\n    loop {}\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#only-problem-1",
    "href": "60_test.html#only-problem-1",
    "title": "Test",
    "section": "Only problem",
    "text": "Only problem\n\nWhat if we run instead of test?\n\n$ cargo r\n   Compiling osirs v0.1.0 (/home/user/tmp/work)\nwarning: function `hi` is never used\n  --&gt; src/main.rs:32:4\n   |\n32 | fn hi() {\n   |    ^^\n   |\n   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\nwarning: function `bye` is never used\n  --&gt; src/main.rs:37:4\n   |\n37 | fn bye() {\n   |    ^^^",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#correct-way",
    "href": "60_test.html#correct-way",
    "title": "Test",
    "section": "Correct Way",
    "text": "Correct Way\n\nThere is a correct way to solve this.\nSeparately, there is the opposite: my way.\nI renamed them with a _ prefix.\n\n    for f in [_hi, _bye] {\n        f();\n    }\n\nThe correct way is left as an exercise to the interested student.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#writing-tests",
    "href": "60_test.html#writing-tests",
    "title": "Test",
    "section": "Writing Tests",
    "text": "Writing Tests\n\nBy convention, we don‚Äôt simply print nonsense as a test.\n\nIt so happens in our OS, printing was a whole thing, but this is atypical for non-OS applications.\n\nA much more common thing to test is an assertion.\n\nAn expression we claim to evaluate to true",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#a-test",
    "href": "60_test.html#a-test",
    "title": "Test",
    "section": "A Test",
    "text": "A Test\n\nLet‚Äôs just make a sample assertion.\n\nI will take expression that will evaluate to true\nI will apply the assert! macro to the expression\nI will invoke this macro within a function.\nI will include the function in the test_runner array of functions.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#example",
    "href": "60_test.html#example",
    "title": "Test",
    "section": "Example",
    "text": "Example\n\n\nsrc/main.rs\n\nfn _ex() {\n    assert(true);\n}\n\n\nThere‚Äôs a minor annoyance here.\n\nWe can‚Äôt tell if it‚Äôs running at all.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#update-test_runner",
    "href": "60_test.html#update-test_runner",
    "title": "Test",
    "section": "Update test_runner",
    "text": "Update test_runner\n\nBy the way, I remove _hi and _bye at this time.\nI then just enumerate my tests in an array.\nLoop over the range of the length of the array.\n\nSay I‚Äôm running test \\(i\\)\nRun test \\(i\\)\nSay it‚Äôs gucci",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#my-test_runner",
    "href": "60_test.html#my-test_runner",
    "title": "Test",
    "section": "My test_runner",
    "text": "My test_runner\n\nFor each could never.\n\n\n\nsrc/main.rs\n\n#[cfg(test)]\nfn test_runner(_tests: &[&dyn Fn()]) {\n    let fs = [_ex];\n    for i in 0..fs.len() {\n        print!(\"Running test case {:0x}\", i);\n        fs[i]();\n        println!(\"Success.\");\n    }\n}",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#now-what",
    "href": "60_test.html#now-what",
    "title": "Test",
    "section": "Now what?",
    "text": "Now what?\n\ntest_runner returns to _start function\n_start contains an infinite loop\n\nWe recall the entry point function is not allowed to return.\n\nWe probably want cargo t to exit after running all tests.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#winners-never",
    "href": "60_test.html#winners-never",
    "title": "Test",
    "section": "Winners Never",
    "text": "Winners Never\n\nWe want to quit QEMU.\n\nYes, quitting, the thing winners never do.\n\nThis is extremely helpful if both:\n\n\nHave code you want to test, and\nHave a finite life expectancy.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#os-shutdown",
    "href": "60_test.html#os-shutdown",
    "title": "Test",
    "section": "OS Shutdown",
    "text": "OS Shutdown\n\nFolks, its hard.\nBig Blog references these two power management standards.\n\nBoth are good uses of your time outside of class.\n\nAPM\nACPI",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#qemu-to-the-resq",
    "href": "60_test.html#qemu-to-the-resq",
    "title": "Test",
    "section": "QEMU to the RESQ",
    "text": "QEMU to the RESQ\n\nQEMU includes a debug exit!\nisa-debug-exit.\n\nWe pass a -device argument to qemu\nWe pass via the bootimage crate.\nWe specify in Cargo.toml\n\nThis only occurs while testing!\n\n\n\nCargo.toml\n\n[package.metadata.bootimage]\ntest-args = [\"-device\", \"isa-debug-exit,iobase=0xf4,iosize=0x04\"]",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#make-sure-this-works",
    "href": "60_test.html#make-sure-this-works",
    "title": "Test",
    "section": "Make Sure This Works",
    "text": "Make Sure This Works\n\nYou can just cargo t (and also cargo r) and verify the qemu command differs.\n(Scroll)\n\n\n\n$ cargo t\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.06s\n     Running unittests src/main.rs (target/x86_64-osirs/debug/deps/osirs-577ad3ee7fc7cc13)\nBuilding bootloader\n   Compiling bootloader v0.9.34 (/home/calvin/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bootloader-0.9.34)\n    Finished `release` profile [optimized + debuginfo] target(s) in 0.83s\nRunning: `qemu-system-x86_64 -drive format=raw,file=/home/calvin/tmp/work/target/x86_64-osirs/debug/deps/bootimage-osirs-577ad3ee7fc7cc13.bin -no-reboot -device isa-debug-exit,iobase=0xf4,iosize=0x04`\n\n$ cargo r\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s\n     Running `bootimage runner target/x86_64-osirs/debug/osirs`\nBuilding bootloader\n   Compiling bootloader v0.9.34 (/home/calvin/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bootloader-0.9.34)\n    Finished `release` profile [optimized + debuginfo] target(s) in 0.84s\nRunning: `qemu-system-x86_64 -drive format=raw,file=target/x86_64-osirs/debug/bootimage-osirs.bin`",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#io-ports",
    "href": "60_test.html#io-ports",
    "title": "Test",
    "section": "I/O Ports",
    "text": "I/O Ports\n\nRecall memory-mapped I/O.\nThere is also port-mapped I/O.\nThis uses a separate I/O bus for communication.\n\nIt makes sense QEMU uses this as it is not actual physical hardware!",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#imagine",
    "href": "60_test.html#imagine",
    "title": "Test",
    "section": "Imagine",
    "text": "Imagine\n\nEach connected peripheral (mouse, monitor, power supply) has one or more port numbers.\nTo communicate with such an I/O port, use special hardware level instructions.\n\nin and out\n\nThese take a port number and a data byte",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#usage",
    "href": "60_test.html#usage",
    "title": "Test",
    "section": "Usage",
    "text": "Usage\n\nThe isa-debug-exit device uses port-mapped I/O.\n\nisa = instruction set architecture\nAn example instruction is in or out\n\nThe iobase parameter specifies the port address of the (imaginary) device\n0xf4 is a generally unused port\nThe iosize specifies the port size (0x04 means four bytes).",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#the-device",
    "href": "60_test.html#the-device",
    "title": "Test",
    "section": "The Device",
    "text": "The Device\n\nisa-debug-exit is simple.\nWhen a value v is written to the I/O port specified by iobase, QEMU to exits with exit status (v &lt;&lt; 1) | 1.\nSo when we write 0 to the port, QEMU will exit with (0 &lt;&lt; 1) | 1 = 1,\nExit status is more interesting to C coders, and not used much anymore.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#handwave-assembly",
    "href": "60_test.html#handwave-assembly",
    "title": "Test",
    "section": "Handwave assembly",
    "text": "Handwave assembly\n\nVs. manually invoking in and out\n\nThat is for the compilers class\nLive on YT Sp27 unless I get fired for not liking AI.\n\nWe use the x86_64 crate.\nAdd to [dependencies] in Cargo.toml:\n\n\n\nCargo.toml\n\n[dependencies]\nbootloader = \"0.9\"\nx86_64 = \"0.14.2\"",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#port",
    "href": "60_test.html#port",
    "title": "Test",
    "section": "Port",
    "text": "Port\n\nNot just a type of land!\nWe will use ‚ÄúPort‚Äù to gracefully exit.\nMake one:\n\n    unsafe {\n        let mut port = x86_64::instructions::port::Port::new(0xf4);\n    }",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#write-to-it",
    "href": "60_test.html#write-to-it",
    "title": "Test",
    "section": "Write to it",
    "text": "Write to it\n\nI use 0xA, you can use anything.\n\nCould e.g.¬†return number of failed test.\nZero will collide with a general QEMU error.\nDoes need to be a u32 because we said we would.\n\n\n    unsafe {\n        x86_64::instructions::port::Port::new(0xf4).write(0xAu32);\n    }",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#test-exit",
    "href": "60_test.html#test-exit",
    "title": "Test",
    "section": "Test Exit",
    "text": "Test Exit\n\nJust add those lines to the end of test_runner and you should be good to go!\n\n$ cargo t\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.07s\n     Running unittests src/main.rs (target/x86_64-osirs/debug/deps/osirs-429ccf0d82ba9f9c)\nBuilding bootloader\n    Finished `release` profile [optimized + debuginfo] target(s) in 0.07s\nRunning: `qemu-system-x86_64 -drive format=raw,file=/home/calvin/tmp/work/target/x86_64-osirs/debug/deps/bootimage-osirs-429ccf0d82ba9f9c.bin -no-reboot -device isa-debug-exit,iobase=0xf4,iosize=0x04`\nerror: test failed, to rerun pass `--bin osirs`\n\nCaused by:\n  process didn't exit successfully: `bootimage runner /home/calvin/tmp/work/target/x86_64-osirs/debug/deps/osirs-429ccf0d82ba9f9c` (exit status: 21)\nnote: test exited abnormally; to see the full output pass --no-capture to the harness.\n$",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#exit-status",
    "href": "60_test.html#exit-status",
    "title": "Test",
    "section": "Exit Status",
    "text": "Exit Status\n\nWe are providing an exit status other than cargo t expects and being admonished.\n\nThe audacity.\n\nWe just specify the expected exit status in Cargo.toml\n\n\n\nCargo.toml\n\n[package.metadata.bootimage]\ntest-args = [\"-device\", \"isa-debug-exit,iobase=0xf4,iosize=0x04\"]\ntest-success-exit-code = 21\n\n\nAbsolute geniuses note ((0xA&lt;&lt;1)|1)==21",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#annoyance",
    "href": "60_test.html#annoyance",
    "title": "Test",
    "section": "Annoyance",
    "text": "Annoyance\n\nThere remains two annoying things here:\n\nThe QEMU window opens and then closes before we can see it, so we can‚Äôt see results.\nThe QEMU window opens so we are opening a graphics window unnecessarily, which inhibits automation.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#printing-to-the-console",
    "href": "60_test.html#printing-to-the-console",
    "title": "Test",
    "section": "Printing to the Console",
    "text": "Printing to the Console\n\nTo see the test output on the console, we need to send the data from our kernel to the host system somehow.\nThere are various ways to achieve this, for example, by sending the data over a TCP network interface.\n\nNetworks, live on YouTube Spring 2028.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "60_test.html#serial-ports",
    "href": "60_test.html#serial-ports",
    "title": "Test",
    "section": "Serial Ports",
    "text": "Serial Ports\n\nI expect we will be out of time by here.\nWe continue these efforts in the lab: Serial.",
    "crumbs": [
      "Test"
    ]
  },
  {
    "objectID": "32_r5.html",
    "href": "32_r5.html",
    "title": "RISC-V",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#homework",
    "href": "32_r5.html#homework",
    "title": "RISC-V",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#requirements",
    "href": "32_r5.html#requirements",
    "title": "RISC-V",
    "section": "Requirements",
    "text": "Requirements\n\n371rs/32 crate; I named mine ‚Äúosirs‚Äù\nUse the src/main.rs from the linker lab.\nRun on emulated RISC-V in QEMU.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#code",
    "href": "32_r5.html#code",
    "title": "RISC-V",
    "section": "Code",
    "text": "Code\n\n\n\n\n\n\nNoteDon‚Äôt be like me\n\n\n\nLoops are more stable than recursion I guess.\n\n\n\n\nsrc/main.rs\n\n#![no_main]\n#![no_std]\n\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#other-stuff",
    "href": "32_r5.html#other-stuff",
    "title": "RISC-V",
    "section": "Other stuff",
    "text": "Other stuff\n\nI graciously borrrowed some code from this repository.\nhelloworld_in_riscv_and_rust_baremetal\n\ngit clone https://github.com/Alignof/helloworld_in_riscv_and_rust_baremetal.git\n\nJust kidding don‚Äôt use that, use this instead.\n\ngit clone https://github.com/cd-rs/hwr5.git\n\nI made a cool version.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#the-working-parts",
    "href": "32_r5.html#the-working-parts",
    "title": "RISC-V",
    "section": "The working parts",
    "text": "The working parts\n$ tree\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ link.x\n‚îú‚îÄ‚îÄ memory.x\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ main.rs\n\n1 directory, 5 files\n\nSome of this shouldn‚Äôt be new to you.\n\nCargo.lock\nCargo.toml\nsrc/main.rs\n\nSome should:\n\nlink.x\nmemory.x",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#the-internals",
    "href": "32_r5.html#the-internals",
    "title": "RISC-V",
    "section": "The internals",
    "text": "The internals\n\nWithout dwelling on the details, these .x files are for the linker\n\nRemember our good friend the linker.\nlink.x was written by someone that understands linkers.\nmemory.x was written by a script from a crate written by someone that understands linkers.\n\nFrom our perspective, they ‚Äújust work‚Äù\n\nBut how?",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#starting-point",
    "href": "32_r5.html#starting-point",
    "title": "RISC-V",
    "section": "Starting Point",
    "text": "Starting Point\n\nAt first, probably nothing works.\n\nOr at least, cargo b doesn‚Äôt work.\n\n\n$ cargo b\n   Compiling osirs v0.1.0 (/home/user/tmp/hwr5)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustcwuxfha/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustcwuxfha/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/hwr5/target/debug/deps/osirs-80f8eb3240ba748e\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: /home/user/tmp/hwr5/target/debug/deps/osirs-80f8eb3240ba748e.9chdw59nqscmfe0ef1hrxy2nb.rcgu.o: in function `_start':\n          /home/user/tmp/hwr5/src/main.rs:7: multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':\n          (.text+0x1b): undefined reference to `main'\n          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'\n          collect2: error: ld returned 1 exit status\n\n  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n  = note: use the `-l` flag to specify native libraries to link\n  = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib)\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#rustc",
    "href": "32_r5.html#rustc",
    "title": "RISC-V",
    "section": "rustc",
    "text": "rustc\n\nI found it easier to get to work with rustc\n\nCargo hater Calvin\n\nRecall a way we ran the executable in the lab.\n\ncargo rustc -- -C link-arg=-nostartfiles\n\nWe can just go straight to rustc\n\nrust -C link-arg=-nostartfiles\n\nOnly one catch.\n\nWell, two.\nWe want to link files.\nSpecifically, the .x files.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#naively",
    "href": "32_r5.html#naively",
    "title": "RISC-V",
    "section": "Naively",
    "text": "Naively\n\nYou can give rustc a shot straight-away.\n\n$ rustc src/main.rs\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: aborting due to 1 previous error\n\nWe recall we ‚Äúfixed‚Äù the problem with panics by modifying Cargo.toml.\nrustc doesn‚Äôt care about your Cargo.toml!\nWe instead have to specify an argument to rustc.\nWe do so similarly to the link-arg, with the -C flag.\n\nWe furnish basically the same thing we placed in Cargo.toml.\n\n\nrustc src/main.rs -C panic=abort\n\nGet this working and see if you can get the following error message:\n\n$ rustc src/main.rs -C panic=abort\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustceBlIYK/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustceBlIYK/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"main\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: main.main.5f6bf0c8e9d0afce-cgu.0.rcgu.o: in function `_start':\n          main.5f6bf0c8e9d0afce-cgu.0:(.text._start+0x0): multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':\n          (.text+0x1b): undefined reference to `main'\n          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'\n          collect2: error: ld returned 1 exit status\n\n  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n  = note: use the `-l` flag to specify native libraries to link\n\nerror: aborting due to 1 previous error\n\nAh hah! A linker error! Just as we hoped.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#t",
    "href": "32_r5.html#t",
    "title": "RISC-V",
    "section": "-T",
    "text": "-T\n\nThe linker complains it‚Äôs missing something, and it‚Äôs not sure what.\nWe are sure, it‚Äôs the .x files.\nTo furnish a file by name to the linker, we provide it as a link-arg prefixed with -T\n\nlink-arg=-Tlink.x\n\n\n\n\n\n\nTipMacOS Users!\n\n\n\nThis will not work on MacOS, to our knowledge.\nHere is a guide to follow that should work: MacOS\n\n\n\nIf you link both .x files, you will get a different error message.\n\n$ rustc -C link-args=-Tmemory.x -C link-args=-Tlink.x -C panic=abort src/main.rs\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustczhisJl/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustczhisJl/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"main\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\" \"-Tmemory.x\" \"-Tlink.x\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: main.main.5f6bf0c8e9d0afce-cgu.0.rcgu.o: in function `_start':\n          main.5f6bf0c8e9d0afce-cgu.0:(.text._start+0x0): multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld:\n          .got section detected in the input files. Dynamic relocations are not\n          supported. If you are linking to C code compiled using the `gcc` crate\n          then modify your build script to compile the C code _without_ the\n          -fPIC flag. See the documentation of the `gcc::Config.fpic` method for\n          details.\n          /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o: in function `_init':\n          (.init+0xb): relocation truncated to fit: R_X86_64_REX_GOTPCRELX against undefined symbol `__gmon_start__'\n          collect2: error: ld returned 1 exit status\n\n\nerror: aborting due to 1 previous error",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#risc-v",
    "href": "32_r5.html#risc-v",
    "title": "RISC-V",
    "section": "RISC-V",
    "text": "RISC-V\n\nRISC-V is what it would be like if hardware were good.\n\nBy which I mean open-source.\n\n\n\n\n\n\nGood (Open Source)\nBad (Not)\n\n\n\n\nWindows\n\nx\n\n\nLinux\nx\n\n\n\nICC (Intel C Compiler)\n\nx\n\n\nGCC\nx\n\n\n\nx86-64\n\nx\n\n\nARM64\n\nx\n\n\nRISC-V\nx\n\n\n\n\n\nRISC-V (pronounced ‚Äúrisk-five‚Äù):‚Ää1‚Ää is a free and open standard instruction set architecture (ISA) based on reduced instruction set computer (RISC) principles. Unlike proprietary ISAs such as x86 and ARM, RISC-V is described as ‚Äúfree and open‚Äù because its specifications are released under permissive open-source licenses and can be implemented without paying royalties.\n\n\nThe RISC-V instruction set architecture (ISA) offers a highly customizable open standard platform, enabling developers to build, port, and optimize software applications, extensions, and hardware. Its simplicity and modularity enables efficient design and optimization, fostering innovation and reducing development time and cost.\n\n\nAlso unlike x86 and ARM, it is easy to develop for RISC-V, and that is what we‚Äôve done.\n\n$ grep riscv link.x\n  By default uses the riscv crates default trap handler\nERROR(riscv-rt): the start of the REGION_TEXT must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_RODATA must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_DATA must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_HEAP must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_TEXT must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_STACK must be 4-byte aligned\");\nERROR(riscv-rt): `_stext` must be 4-byte aligned\");\nBUG(riscv-rt): .data is not 4-byte aligned\");\nBUG(riscv-rt): the LMA of .data is not 4-byte aligned\");\nBUG(riscv-rt): .bss is not 4-byte aligned\");\nBUG(riscv-rt): start of .heap is not 4-byte aligned\");\nERROR(riscv-rt): The .text section must be placed inside the REGION_TEXT region.\nERROR(riscv-rt): .stack section is too small for allocating stacks for all the harts.\n\nBy golly, our .x files are for RISC-V!\n\nAnd therefore good.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#target",
    "href": "32_r5.html#target",
    "title": "RISC-V",
    "section": "Target",
    "text": "Target\n\nWe recall the notion of a target triple\n\nFrom the linker lab\n\nWe note:\n\nThere are references to x86 (in my case) in the error logs.\nThere are references to RISC-V in the linker files.\nWe have to pick one, and‚Ä¶\nI didn‚Äôt provide appropriate linker files for x86\n\nBecause it‚Äôs bad!\n\n\nYou will additionlly need to specify a target.\nriscv64imac-unknown-none-elf\nYou will figure it out.\n\nAnd you will know when you have, because you will see no errors and a main will have appeared.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#main",
    "href": "32_r5.html#main",
    "title": "RISC-V",
    "section": "Main",
    "text": "Main\n\nGo ahead and run main, what could go wrong.\n\n$ ./main\n-bash: ./main: cannot execute binary file: Exec format error\n\nIf, like me, you foolish use an architecture other than RISC-V as your daily driver (that‚Äôs a metaphor, not a reference to device drivers), main won‚Äôt work on your system.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#qemu",
    "href": "32_r5.html#qemu",
    "title": "RISC-V",
    "section": "QEMU",
    "text": "QEMU\n\nWell, it will, you just have to bamboozle your system into pretending to be a good system, like RISC-V\n\nsudo apt install qemu-system-misc\n\nWe don‚Äôt allow our feelings to be hurt by RISC-V being described as ‚Äúmiscellaneous‚Äù.\n\nI didn‚Äôt properly sandbox my system before debugging so I think this is all you need but I may be wrong if I lost a dependency somewhere.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#run-qemu",
    "href": "32_r5.html#run-qemu",
    "title": "RISC-V",
    "section": "Run QEMU",
    "text": "Run QEMU\n\nYou can simply launch qemu with no strings attached.\n\n\u0016qemu-system-riscv64\n\nFor me this popped open a new window.\n\nThis is good, as otherwise you have to deal with processes and I don‚Äôt have time to teach that.\nIf you type ‚Äúquit‚Äù after the prompt of (qemu) it should close.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#run-main",
    "href": "32_r5.html#run-main",
    "title": "RISC-V",
    "section": "Run main",
    "text": "Run main\n\nYou can specify that you totally wrote a working OS, honest, by providing qemu with a specified kernel, like our main\n\n\u0016qemu-system-riscv64 -kernel main\n\n\n\n\n\n\nNoteForward Pointer\n\n\n\nWe will properly introduce kernels in the next lecture.\n\n\n\nThis will probably work.\n\n$ qemu-system-riscv64 -kernel main\nqemu-system-riscv64: Some ROM regions are overlapping\nThese ROM regions might have been loaded by direct user request or by default.\nThey could be BIOS/firmware images, a guest kernel, initrd or some other file loaded into guest memory.\nCheck whether you intended to load all this guest code, and whether it has been built to load to the correct addresses.\n\nThe following two regions overlap (in the memory address space):\n  /usr/share/qemu/opensbi-riscv64-generic-fw_dynamic.elf ELF program header segment 1 (addresses 0x0000000080000000 - 0x0000000080016ce8)\n  main ELF program header segment 0 (addresses 0x0000000080000000 - 0x0000000080000004)\n\nAnd by probably I mean with a probability of zero.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#bios",
    "href": "32_r5.html#bios",
    "title": "RISC-V",
    "section": "BIOS",
    "text": "BIOS\n\n\n\n\n\n\nNoteForward Pointer\n\n\n\nWe will properly introduce the BIOS in the next lecture.\n\n\n\nThe BIOS can be thought of as a tiny bit of read-only memory (ROM) that lives on a computer.\nWhen the computer first turns on, it immediately begins reading instructions from the BIOS (presumably over the bus, or through some other means).\nThe BIOS will then instruct the device how to procede.\nWe don‚Äôt need any of that, we already wrote an infinite loop and can just start there!\n\n\u0016qemu-system-riscv64 -kernel main -bios none\n\nIn computing, BIOS (Basic Input/Output System, also known as the System BIOS, ROM BIOS, BIOS ROM or PC BIOS) is a type of firmware used to provide runtime services for operating systems and programs and to perform hardware initialization during the booting process (power-on startup). On a computer using BIOS firmware, the firmware comes pre-installed on the computer‚Äôs motherboard.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#machine",
    "href": "32_r5.html#machine",
    "title": "RISC-V",
    "section": "Machine",
    "text": "Machine\n\nYou may get an error not unlike this one:\n\n$ qemu-system-riscv64 -bios none -kernel main\nqemu-system-riscv64: Invalid HTIF fromhost or tohost address\n\nYou also may not get this error.\nIt is caused by not telling QEMU which specific, physical machine to pretend to be.\nI recommend sifive_u, which I believe is the most popular physical chip for developmental purposes.\n\nqemu-system-riscv64 -machine sifive_u -bios none -kernel main",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#todo",
    "href": "32_r5.html#todo",
    "title": "RISC-V",
    "section": "TODO",
    "text": "TODO\nFor this homework, add a README.md to the crate describing how to get it to work.\n\nIt should be like this document, but concise.\nUse cool markdown checkboxes.\n\n- [ ] Do a thing.\n- [ ] Do another thing.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "21_xmute.html",
    "href": "21_xmute.html",
    "title": "Transmute",
    "section": "",
    "text": "Lab Day\n\nPlay with memory\nUse unsafe",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#announcements",
    "href": "21_xmute.html#announcements",
    "title": "Transmute",
    "section": "",
    "text": "Lab Day\n\nPlay with memory\nUse unsafe",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#homework",
    "href": "21_xmute.html#homework",
    "title": "Transmute",
    "section": "Homework",
    "text": "Homework\n\nmalloc is this lab just more complete\n\nCool, good, fun.\n\nDue Friday, 06 Feb.¬†at 1440 ET.\n\nAnd also covered in section.",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#requirements",
    "href": "21_xmute.html#requirements",
    "title": "Transmute",
    "section": "Requirements",
    "text": "Requirements\n\nChange the interpretation of numeric values with transmute on values\nChange the interpretation of memory with transmute on references.\nWrite a ‚ÄúHello world!‚Äù program that uses no string or character data.",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#crate",
    "href": "21_xmute.html#crate",
    "title": "Transmute",
    "section": "Crate",
    "text": "Crate\n\nTo complete the lab today, create a crate named helloworld in a folder named 21 in your 371os repository.\n\ncargo new 21 --name hello_world --vcs none",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#hello-world",
    "href": "21_xmute.html#hello-world",
    "title": "Transmute",
    "section": "‚ÄúHello world!‚Äù",
    "text": "‚ÄúHello world!‚Äù\n\nImplement ‚ÄúHello world!‚Äù using this crate.\nUse i32 to store the ‚ÄúHello world‚Äù data.\nWhile you do not have to develop it this way, the code could be a single line within an unsafe block containing only built-in function calls/declarations and i32 literals.\n\ncalvin@calvin:~/tmp/helloworld$ wc src/main.rs # 2 lines main, 2 lines unsafe, 1 line code\n  5  15 174 src/main.rs\ncalvin@calvin:~/tmp/helloworld$ grep world src/main.rs # no plaintext in file\ncalvin@calvin:~/tmp/helloworld$ cargo r --release\n   Compiling helloworld v0.1.0 (/home/calvin/tmp/oneone)\n    Finished `release` profile [optimized] target(s) in 0.14s\n     Running `target/release/helloworld`\nHello world!\n\nI love Python\n\nThe following may be useful here, to the interested student.\n\npython3 -c '[print(ord(a)) for a in \"Hello world!\"]'\n\nThis is probably insufficient for your purposes and will require some hacking.\n\n\n\nTransmute\n\nSince it is more idiomatic to use code other people have written in Rust‚Ä¶\n\nI have an opinion on this.\n\n‚Ä¶while it is possible to conduct this exercise using only raw pointers and casts‚Ä¶\n\n(in the voice of Palpatine) ‚ÄúDo it!‚Äù\n\n‚Ä¶it is my professional responsibility to recommend you use transmute.\n\npub const unsafe fn transmute&lt;Src, Dst&gt;(src: Src) -&gt; Dst\n\nRead more\n\n\n\nRaw Pointers\n\nAlso can use raw pointers here.\nWill get in the way of a single-line solution but that is okay - you should do you!\n\n\n\nNumeric Values\n\nOne obvious way to use transmute is to change one type of data into another, without altering the underlying numeric values that exist in memory.\nFor example, we can convert an array of u8s to an i32.\n\nunsafe {\n    let bytes: [u8;4] = [0x12,0x34,0x56,0x78];\n    let num: i32 = std::mem::transmute(bytes);\n    println!(\"{:x}\", num);\n}\n\nI drew a warning when doing this, but it turns out I was doing what I wanted and did not wnat to do what rustc wanted, so I didn‚Äôt worry about it.\n\n\n\nEndianness\n\nThe warning refers to the topic of endianness.\n\nBig deal in C, kinda not in Rust actually.\n\nPrecisely because of that warning basically.\nThis lab was very involved. Endian\n\n\nRead more\n\n\nIn computing, endianness is the order in which bytes within a word data type are transmitted over a data communication medium or addressed in computer memory, counting only byte significance compared to earliness.\n\n\nRegard an i32 as a word and a u8 as a bit.\nTake note of the endianness revealed by the prior code.\n\n\n\nNumeric Address\n\nOne possibly more advanced use of transmute is upon numeric addresses\n\nThe key, the numeric value of the address, stays the same.\nThe value, the numeric value in the memory location decribed by the address, stays the same.\nThe interpretation - how Rust understands the value at that location - changes.\n\n\nunsafe {\n    let nats: &[u32] = &[0x3F800000];\n    let nums: &[f32] = std::mem::transmute(nats);\n    println!(\"{}\", nums[0]);\n}\n\nRecall the meaning of 0x3F8000000\nI usually do this on arrays but I guess I‚Äôm not sure why.\n\nTry things out.\nVectors are definitely banned though, that is way too high level.",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "02_cli.html",
    "href": "02_cli.html",
    "title": "CLI",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#homework",
    "href": "02_cli.html#homework",
    "title": "CLI",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#citation",
    "href": "02_cli.html#citation",
    "title": "CLI",
    "section": "Citation",
    "text": "Citation\n\nAn I/O Project: Building a Command Line Program\nIn a way, an OS is a ‚Äúcommand line program‚Äù‚Ä¶",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#requirements",
    "href": "02_cli.html#requirements",
    "title": "CLI",
    "section": "Requirements",
    "text": "Requirements\n\nNew repository for this course.\nNew crate for this lab.\nCrate when built creates an executable that behaves identically to GNU Coreutils wc when provided with a file name and either (1) no options or a (2) options a single letter.\n\nThat is, you must support wc -c src/main.rs but not wc --files0-from=F\nCheck out wc and wc --help (which you don‚Äôt need to provide) to get a sense of the task.",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#crate",
    "href": "02_cli.html#crate",
    "title": "CLI",
    "section": "Crate",
    "text": "Crate\n\nTo complete the lab today, create a crate named my_wc in a folder named 02 in your 371os repository.\n\ncargo new 02 --name my_wc --vcs none\n\nI understand this is the same name as the lab.\n\nI am not as clever as I either think I am or would like to be.\n\nIf you‚Äôre stuck, read more here",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#wc",
    "href": "02_cli.html#wc",
    "title": "CLI",
    "section": "wc",
    "text": "wc\nImplement the complete functionality of wc using this crate.\n\nAccept character command line flags prefixed with -\nAccept string command line flags prefixed with --\nConfigure your my_wc to work on standard input if a file name is not provided.\n\n\nFull functionality\n\nHere is wc --help\nYour --help and --version may differ, but should otherwise be identical.\n\nUsage: wc [OPTION]... [FILE]...\n  or:  wc [OPTION]... --files0-from=F\nPrint newline, word, and byte counts for each FILE, and a total line if\nmore than one FILE is specified.  A word is a non-zero-length sequence of\ncharacters delimited by white space.\n\nWith no FILE, or when FILE is -, read standard input.\n\nThe options below may be used to select which counts are printed, always in\nthe following order: newline, word, character, byte, maximum line length.\n  -c, --bytes            print the byte counts\n  -m, --chars            print the character counts\n  -l, --lines            print the newline counts\n      --files0-from=F    read input from the files specified by\n                           NUL-terminated names in file F;\n                           If F is - then read names from standard input\n  -L, --max-line-length  print the maximum display width\n  -w, --words            print the word counts\n      --help     display this help and exit\n      --version  output version information and exit\n\nGNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;\nReport any translation bugs to &lt;https://translationproject.org/team/&gt;\nFull documentation &lt;https://www.gnu.org/software/coreutils/wc&gt;\nor available locally via: info '(coreutils) wc invocation'\n\n\nRubric\n\nSetup - optional\n\n$ curl https://raw.githubusercontent.com/cd-public/books/main/pg1342.txt -o book.txt\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100  739k  100  739k    0     0  1446k      0 --:--:-- --:--:-- --:--:-- 1447k\n$ head -23 book.txt | tail -1\n*** START OF THE PROJECT GUTENBERG EBOOK PRIDE AND PREJUDICE ***\n\nCharacter flags - required\n\n$ wc book.txt\n 14911 130408 757509 book.txt\n$ wc -cl book.txt\n 14911 757509 book.txt\n$ wc -c book.txt -cl\n 14911 757509 book.txt\n$ wc -l book.txt -c\n 14911 757509 book.txt\n$ wc -Ll book.txt\n 14911    159 book.txt\n\nString flags - required\n\n$ wc --bytes -c book.txt\n757509 book.txt\n$ wc --lines -c book.txt\n 14911 757509 book.txt\n$ printf \"book.txt\" &gt; file.txt\n$ wc --lines -c --files0-from=file.txt\n 14911 757509 book.txt\n$ wc --version | head -1\nwc (GNU coreutils) 8.32\n$ wc --help | head -1\nUsage: wc [OPTION]... [FILE]...\n\nStandard I/O - required\n\n$ cat book.txt | head -100 | wc\n    100     277    2787\n$ cat book.txt | head -200 | wc\n    200    1360    9359\n$ wc book.txt | wc\n      1       4      30",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#helpful-reference",
    "href": "02_cli.html#helpful-reference",
    "title": "CLI",
    "section": "Helpful Reference",
    "text": "Helpful Reference\n\nWhile linked above, I think it will be very helpful to review the following:\nAccepting Command Line Arguments - The Rust Programming Language",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "01_wc.html",
    "href": "01_wc.html",
    "title": "wc",
    "section": "",
    "text": "Lab Day\n\nSet up environment\nBuilding a command line program",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#announcements",
    "href": "01_wc.html#announcements",
    "title": "wc",
    "section": "",
    "text": "Lab Day\n\nSet up environment\nBuilding a command line program",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#homework",
    "href": "01_wc.html#homework",
    "title": "wc",
    "section": "Homework",
    "text": "Homework\n\n‚ÄúCLI‚Äù is just this lab but more complete.\n\nWindows officially no longer supported.\n\nDue Friday, 23 Jan.¬†at 1440 ET.\n\nPlan to hang out as a class 1310-1440 on Fridays, probably.",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#setup",
    "href": "01_wc.html#setup",
    "title": "wc",
    "section": "Setup",
    "text": "Setup\n\nIf you are stuck setting up Rust, following this\nAt the end you should have:\n\ncargo, git, and at least one of gcc or clang on your system.\nA repository named 371os on Github that is either (1) public or (2) shared with [cd-public](https://github.com/cd-public",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#requirements",
    "href": "01_wc.html#requirements",
    "title": "wc",
    "section": "Requirements",
    "text": "Requirements\n\nNew repository for this course.\nNew crate for this lab.\nCrate when built creates an executable that behaves identically to GNU Coreutils wc when provided with a file name and no options.\n\nThat is, you must support wc src/main.rs but not wc --files0-from=F src/main.rs\nCheck out wc and wc --help (which you don‚Äôt need to provide) to get a sense of the task.",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#repository",
    "href": "01_wc.html#repository",
    "title": "wc",
    "section": "Repository",
    "text": "Repository\n\nCreate a repository for this class.\nRequirements\n\nName is 371os\nMay be public or private to you and me (cd-public).\n\nRead more\n\nMust email me a link to your repository from your @willamette.edu email, e.g.:\n\nhttps://github.com/cd-example/371os\nIf you‚Äôre stuck, read more here",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#crate",
    "href": "01_wc.html#crate",
    "title": "wc",
    "section": "Crate",
    "text": "Crate\n\nTo complete the lab today, create a crate named my_wc in a folder named 01 in your 371os repository.\n\ncargo new 01 --name my_wc --vcs none\n\nIf you‚Äôre stuck, read more here",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#wc",
    "href": "01_wc.html#wc",
    "title": "wc",
    "section": "wc",
    "text": "wc\n\nImplement the minimal base functionality of wc using this crate.\n\n\nFull functionality\n\nHere is wc --help\nYou do not need to do all of this!\n\nUsage: wc [OPTION]... [FILE]...\n  or:  wc [OPTION]... --files0-from=F\nPrint newline, word, and byte counts for each FILE, and a total line if\nmore than one FILE is specified.  A word is a non-zero-length sequence of\ncharacters delimited by white space.\n\nWith no FILE, or when FILE is -, read standard input.\n\nThe options below may be used to select which counts are printed, always in\nthe following order: newline, word, character, byte, maximum line length.\n  -c, --bytes            print the byte counts\n  -m, --chars            print the character counts\n  -l, --lines            print the newline counts\n      --files0-from=F    read input from the files specified by\n                           NUL-terminated names in file F;\n                           If F is - then read names from standard input\n  -L, --max-line-length  print the maximum display width\n  -w, --words            print the word counts\n      --help     display this help and exit\n      --version  output version information and exit\n\nGNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;\nReport any translation bugs to &lt;https://translationproject.org/team/&gt;\nFull documentation &lt;https://www.gnu.org/software/coreutils/wc&gt;\nor available locally via: info '(coreutils) wc invocation'\n\n\nRequired functionality\n\nThat is more than required, you need only implement:\n\nUsage: wc [FILE]\nPrint newline, word, and byte counts for each FILE. A word is a \nnon-zero-length sequence of characters delimited by white space.\n\nThis can be trivially tested with some of the following:\n\n$ wc src/main.rs\n 12  30 229 src/main.rs\n$ cargo build release\n$ ./target/release/my_wc src/main.rs\n 12  30 229 src/main.rs\n\nYour src/main.rs need not be of any particular size, and you needn‚Äôt implement all code within src/main.rs, but you should get the same counts from wc and from your release binary.",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#helpful-reference",
    "href": "01_wc.html#helpful-reference",
    "title": "wc",
    "section": "Helpful Reference",
    "text": "Helpful Reference\n\nWhen working on projects like this, I almost always have the following reference material open.\nread_lines - Rust By Example\n\n\nfn read_lines(filename: &str) -&gt; Vec&lt;String&gt; {\n    let mut result = Vec::new();\n\n    for line in std::fs::read_to_string(filename).unwrap().lines() {\n        result.push(line.to_string())\n    }\n\n    result\n}",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "31_linker.html",
    "href": "31_linker.html",
    "title": "Linker",
    "section": "",
    "text": "This is continued directly from the Bare Metal lecture.\n\n\n\n\nWe left off with the following code:\n\n\n\nsrc/main.rs\n\n#![no_std]\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n\n\n\n\nWe modified the configuration with a few new lines about panics.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"\n\n\n\n\n\nWe encountered the following error:\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-code",
    "href": "31_linker.html#the-code",
    "title": "Linker",
    "section": "",
    "text": "We left off with the following code:\n\n\n\nsrc/main.rs\n\n#![no_std]\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-configuration",
    "href": "31_linker.html#the-configuration",
    "title": "Linker",
    "section": "",
    "text": "We modified the configuration with a few new lines about panics.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-state-of-play",
    "href": "31_linker.html#the-state-of-play",
    "title": "Linker",
    "section": "",
    "text": "We encountered the following error:\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-start-attribute",
    "href": "31_linker.html#the-start-attribute",
    "title": "Linker",
    "section": "The start attribute",
    "text": "The start attribute\n\nOne might think that the main function is the first function called when you run a program.\n\nUsually because that is how main is taught.\nIt isn‚Äôt entirely wrong - main is the first thing that you write that is called when you run a program.\nBut there‚Äôs often some setup first!\n\nMost languages have a ‚Äúruntime system‚Äù\n\nFor e.g.¬†Java garbage collection (e.g.¬†in Java)\nFor e.g.¬†Go software threads (goroutines)\nFor e.g.¬†Python, Pyodide runs in WebAssembly/Emscripten within your browser engine which itself runs on top of an OS.\n\nThis runtime needs to be called before main, since it needs to initialize itself.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#c-again",
    "href": "31_linker.html#c-again",
    "title": "Linker",
    "section": "C, again",
    "text": "C, again\n\nIn a typical Rust executable that links the standard library, execution starts in a C runtime library\n\ncrt0 for ‚ÄúC runtime zero‚Äù\nC stands for ‚Äúcool‚Äù\n\nThis creates a stack and places the arguments in the right hardware registers.\n\nWe recall even in our earliest mentions of C and Rust we always assume there just happens to be a stack we can push/pop fixed-size variables onto.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#getting-_started",
    "href": "31_linker.html#getting-_started",
    "title": "Linker",
    "section": "Getting _started",
    "text": "Getting _started\n\nThe C runtime then invokes the entry point of the Rust runtime, which is marked by the start language item.\nI detect a great deal of hand-waving around the term ‚Äúlanguage item‚Äù.\nI think ‚Äúlanguage item‚Äù is how Rust people describe (some subset of) things that don‚Äôt make sense with the language implementation.\nMostly, they are not expressions.\nRead more",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#example",
    "href": "31_linker.html#example",
    "title": "Linker",
    "section": "Example",
    "text": "Example\nSome features provided by lang items:\n\noverloadable operators via traits: the traits corresponding to the ==, &lt;, dereferencing (*) and + (etc.) operators are all marked with lang items; those specific four are eq, partial_ord, deref/deref_mut, and add respectively.\n\nWe recall Calvin Deutschbein Thought on both overloading and traits (they‚Äôre bad).",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#example-1",
    "href": "31_linker.html#example-1",
    "title": "Linker",
    "section": "Example",
    "text": "Example\nSome features provided by lang items:\n\npanicking: the panic and panic_impl lang items, among others.\n\nWe have already been bamboozled into using #[panic_handler]",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#example-2",
    "href": "31_linker.html#example-2",
    "title": "Linker",
    "section": "Example",
    "text": "Example\nSome features provided by lang items:\n\nstack unwinding: the lang item eh_personality is a function used by the failure mechanisms of the compiler.\n\nThe eh_personality item is cut content present in the reference material. We recall Calvin Deutschbein Thought on unwinding (it‚Äôs bad).",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#back-to-rust",
    "href": "31_linker.html#back-to-rust",
    "title": "Linker",
    "section": "Back to Rust",
    "text": "Back to Rust\n\nRust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic.\n\nWe should approach the claim of minimal with some skeptism, but it isn‚Äôt relevant to us for now.\n\nThe runtime then finally calls the main function.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#crt0-is-cheating",
    "href": "31_linker.html#crt0-is-cheating",
    "title": "Linker",
    "section": "crt0 is cheating",
    "text": "crt0 is cheating\n\nOur freestanding executable does not have access to the Rust runtime and crt0\nWe need to define our own entry point. = Implementing the start language item wouldn‚Äôt help, since it would still require crt0.\nInstead, we need to overwrite the crt0 entry point directly.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#overwriting",
    "href": "31_linker.html#overwriting",
    "title": "Linker",
    "section": "Overwriting",
    "text": "Overwriting\n\nTo tell the Rust compiler that we don‚Äôt want to use the normal entry point chain, we add the #![no_main] attribute.\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n#![no_main]\n\n/// This function is called on panic.\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#no-main-in-main",
    "href": "31_linker.html#no-main-in-main",
    "title": "Linker",
    "section": "No main in main",
    "text": "No main in main\n\nAt this point we can also remove the main function.\n\nBut notably still term our file main.rs\nWe also pretend this is not confusing.\n\nAbsent a compatible runtime, main is meaningless!\nIf you cargo build at this point, by the way, you will get some fun errors.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#start-in-main",
    "href": "31_linker.html#start-in-main",
    "title": "Linker",
    "section": "Start in main",
    "text": "Start in main\n\nInstead, overwrite the entry point with our own _start function:\n\n\n\nsrc/main.rs\n\nfn _start() -&gt; ! {\n    // Code\n}\n\n\nThis also won‚Äôt work.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#manglin",
    "href": "31_linker.html#manglin",
    "title": "Linker",
    "section": "Manglin‚Äô",
    "text": "Manglin‚Äô\n\nBy using the #[unsafe(no_mangle)] attribute, we disable ‚Äúname mangling‚Äù\n\nThe function must be named _start.\n\nOtherwise, compiler generates unique symbols like _start_imarandomstr_1234 to avoid namespace collisons.\n\nFolks‚Ä¶ it‚Äôs key-value storage.\n\nThe attribute is required for the linker in the next step.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#start-in-main-1",
    "href": "31_linker.html#start-in-main-1",
    "title": "Linker",
    "section": "Start in main",
    "text": "Start in main\n\nWrite your own mangle-free _start.:\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\nfn _start() -&gt; ! {\n    // Code\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#c-you-again",
    "href": "31_linker.html#c-you-again",
    "title": "Linker",
    "section": "C you again",
    "text": "C you again\n\nMark the function as extern \"C\" to tell the compiler that it should use the ‚ÄúC calling convention‚Äù\nThe reason for naming the function _start is that this is the default entry point name for most systems.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#a-hardware-reality",
    "href": "31_linker.html#a-hardware-reality",
    "title": "Linker",
    "section": "A Hardware Reality",
    "text": "A Hardware Reality\n\nThe C calling convention is a hardware reality\nIt is the implementation of a physical device that assumes C code is running on it,\nIt assumes the C runs in an expected, consistent, historical way.\nThis consistency leads to a usable heap and viable return.\nIt could be possible to e.g.¬†implement stack-less C\n\nBut that would not have hardware support.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#start-in-main-2",
    "href": "31_linker.html#start-in-main-2",
    "title": "Linker",
    "section": "Start in main",
    "text": "Start in main\n\nInstead, overwrite the entry point with our own _start function:\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    // Code\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#c-you-later",
    "href": "31_linker.html#c-you-later",
    "title": "Linker",
    "section": "C you later",
    "text": "C you later\n\nWe don‚Äôt have a great way to test this at this stage.\n\nIn fact, most formulations will lead to similar errors‚Ä¶\nWe just put it in now for forwards compatability.\n\nThat said, I got this working without pub extern \"C\"\n\nYou can try it out soon.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#read-more",
    "href": "31_linker.html#read-more",
    "title": "Linker",
    "section": "Read more",
    "text": "Read more\n\nname mangling\nC calling convention",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#divergence",
    "href": "31_linker.html#divergence",
    "title": "Linker",
    "section": "Divergence",
    "text": "Divergence\n\nThe ! return type returns!\nThis is required because the entry point is not called by any function, but invoked directly by the operating system or bootloader.\n\nIt can‚Äôt return anywhere!\n\nCowards use loop(), heroes use recursion.\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    _start()\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#allowance",
    "href": "31_linker.html#allowance",
    "title": "Linker",
    "section": "Allowance",
    "text": "Allowance\n\nAs you are aware, cargo is counted among the cowards that expect loop.\n\nWe still haven‚Äôt shown the trick to compile this yet, but if you knew the trick you would see the following.\n\n\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nwarning: function cannot return without recursing\n --&gt; src/main.rs:5:1\n  |\n5 | pub extern \"C\" fn _start() -&gt; ! {\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n6 |     _start()\n  |     -------- recursive call site\n  |\n  = help: a `loop` may express intention better if this is on purpose\n  = note: `#[warn(unconditional_recursion)]` on by default\n\nwarning: `osirs` (bin \"osirs\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.16s",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#hash-and-hash-bang",
    "href": "31_linker.html#hash-and-hash-bang",
    "title": "Linker",
    "section": "Hash and Hash Bang",
    "text": "Hash and Hash Bang\n\nWe applied function-level allowances to our panic to allow infinite recursion as follows:\n\nImmediately prepending, octothorpe/hash prefixed ‚Äúlanguage items‚Äù\n\n\n\n\nsrc/main.rs\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n\nWe applied file-level allowances to our src/main.rs as follows:\n\nFree-floating, octothorpe+exclamation point (hash+bang)\n\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-code-1",
    "href": "31_linker.html#the-code-1",
    "title": "Linker",
    "section": "The Code",
    "text": "The Code\n\nI promoted the recursion allowance to file-level, with the following resultant code:\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n#![allow(unconditional_recursion)]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! { _start() }\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! { panic(info) }\n\n\nPut a pin in this.\n\nWe‚Äôll be back latter.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#exit",
    "href": "31_linker.html#exit",
    "title": "Linker",
    "section": "Exit",
    "text": "Exit\n\nBefore I go out to the clubs I always ‚ÄúX it up‚Äù (put X‚Äôs on my hands) because I‚Äôm straight edge.\nOperating systems are similar.\nSo instead of returning, the entry point should e.g.¬†invoke the exit system call of the operating system.\nexit system call\nFor now, we fulfill the requirement by recursing endlessly.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#now-it-works",
    "href": "31_linker.html#now-it-works",
    "title": "Linker",
    "section": "Now it works!",
    "text": "Now it works!\n\nIt doesn‚Äôt.\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustcheyGtM/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustcheyGtM/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/32/target/debug/deps/osirs-80f8eb3240ba748e\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: /home/user/tmp/32/target/debug/deps/osirs-80f8eb3240ba748e.9chdw59nqscmfe0ef1hrxy2nb.rcgu.o: in function `_start':\n          /home/user/tmp/32/src/main.rs:14: multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':\n          (.text+0x1b): undefined reference to `main'\n          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'\n          collect2: error: ld returned 1 exit status\n\n  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n  = note: use the `-l` flag to specify native libraries to link\n  = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib)\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#linker-errors",
    "href": "31_linker.html#linker-errors",
    "title": "Linker",
    "section": "Linker Errors",
    "text": "Linker Errors\n\nThe linker is a program that combines the generated code into an executable.\n\nCould be the subject of an entire course.\nExtremely compiler-relevant.\n\nSince the executable format differs between Linux, Windows, and macOS, each system has its own linker that throws a different error.\nThe fundamental cause of the errors is the same: the default configuration of the linker assumes that our program depends on the C runtime, which it does not.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#solution",
    "href": "31_linker.html#solution",
    "title": "Linker",
    "section": "Solution",
    "text": "Solution\n\nTo solve the errors, we need to tell the linker that it should not include the C runtime.\nWe can do this either by passing a certain set of arguments to the linker or by building for a bare metal target.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#building-for-a-bare-metal-target",
    "href": "31_linker.html#building-for-a-bare-metal-target",
    "title": "Linker",
    "section": "Building for a Bare Metal Target",
    "text": "Building for a Bare Metal Target\n\nBy default Rust tries to build an executable that is able to run in your current system environment.\nFor example, if you‚Äôre using Linux on x86_64, Rust tries to build an ELF that uses x86_64 instructions.\nThis environment is called your ‚Äúhost‚Äù system.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#target-triple",
    "href": "31_linker.html#target-triple",
    "title": "Linker",
    "section": "Target Triple",
    "text": "Target Triple\n\nTo describe different environments, Rust uses a string called target triple.\nYou can see the target triple for your host system by running rustc --version --verbose:\n\n$ rustc --version --verbose\nrustc 1.87.0 (17067e9ac 2025-05-09)\nbinary: rustc\ncommit-hash: 17067e9ac6d7ecb70e50f92c1944e545188d2359\ncommit-date: 2025-05-09\nhost: x86_64-unknown-linux-gnu\nrelease: 1.87.0\nLLVM version: 20.1.1",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#comments",
    "href": "31_linker.html#comments",
    "title": "Linker",
    "section": "Comments",
    "text": "Comments\n\nThe above output is from a x86_64 Linux system.\nWe see that the host triple is x86_64-unknown-linux-gnu\n\nCPU architecture (x86_64),\nVendor (unknown) - It‚Äôs Intel #Portland\nOperating system (linux)\nThe ABI (gnu).",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#on-triples",
    "href": "31_linker.html#on-triples",
    "title": "Linker",
    "section": "On Triples",
    "text": "On Triples\n\nFor triple, rustc and the linker (for me gcc, often clang is recommended). assume an OS and C runtime.\nWe turned both of those things off.\nSo, to avoid the linker errors, we can compile for a different environment with no underlying operating system.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#bare-metal",
    "href": "31_linker.html#bare-metal",
    "title": "Linker",
    "section": "Bare Metal",
    "text": "Bare Metal\n\nOne bare metal environment is the thumbv7em-none-eabi target triple\nA embedded ARM system. Used for teaching.\nThe details are not important; it has no underlying operating system.\n\nThat is the none in the target triple.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#rustup",
    "href": "31_linker.html#rustup",
    "title": "Linker",
    "section": "Rustup",
    "text": "Rustup\n\nTo be able to compile for this target, we need to add it in rustup:\n\nrustup target add thumbv7em-none-eabihf\nThis downloads a copy of the standard (and core) library for the system. Now we can build our freestanding executable for this target:\ncargo build --target thumbv7em-none-eabihf",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#explanation",
    "href": "31_linker.html#explanation",
    "title": "Linker",
    "section": "Explanation",
    "text": "Explanation\n\nBy passing a --target argument we cross-compile\n\nBare metal compilation!\n\nSince the target system has no operating system, the linker does not try to link the C runtime and our build succeeds without any linker errors.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#looking-ahead",
    "href": "31_linker.html#looking-ahead",
    "title": "Linker",
    "section": "Looking Ahead",
    "text": "Looking Ahead\n\nThis is the approach that we will use for building our OS kernel.\nInstead of thumbv7em-none-eabihf, we will use a custom target that describes a x86_64 bare metal environment.\n\nI don‚Äôt know how this will work for the Apple Silicon folks.\nBut I am excited to find out!\n\nThe details will be explained next week.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#summary",
    "href": "31_linker.html#summary",
    "title": "Linker",
    "section": "Summary",
    "text": "Summary\nA minimal freestanding Rust executable looks like this:\n\nCode\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n#![allow(unconditional_recursion)]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    _start()\n}\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n\nConfiguration\n\nWe made no changes to this during the lab.\n\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#to-build",
    "href": "31_linker.html#to-build",
    "title": "Linker",
    "section": "To build",
    "text": "To build\nTo build this binary, we need to compile for a bare metal target such as thumbv7em-none-eabi:\ncargo build --target thumbv7em-none-eabi\nAlternatively, we can compile it for Linux by passing additional linker arguments to rustc:\ncargo rustc -- -C link-arg=-nostartfiles",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#to-run",
    "href": "31_linker.html#to-run",
    "title": "Linker",
    "section": "To run",
    "text": "To run\n\nIf you build, you can run it!\n\n$ cargo rustc -- -C link-arg=-nostartfiles\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.14s\nuser@cd-desk:~/tmp/32$ ./target/debug/osirs\nSegmentation fault (core dumped)\n\nWait a minute!",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#re-cursed",
    "href": "31_linker.html#re-cursed",
    "title": "Linker",
    "section": "RE: cursed",
    "text": "RE: cursed\n\nThe C calling convention segfaults on infinite recursion.\nSwitch to loop to get an infinite loop.\nThese two things are equally bad in my view.\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\nPop the pin",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "51_format.html",
    "href": "51_format.html",
    "title": "Format",
    "section": "",
    "text": "We wrote str_to_vga.\nWe handled a bunch of corner cases.\nWe had an all-around great time.\n\n\n\n\nWe recall our two main source code files.\n\nWe anticipate our configuration files to be unaltered.\n\n\n\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\nmod vga;\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Hello, world!\");\n    loop {}\n}\n\n\n\n\n\n\nsrc/vga.rs\n\nstatic mut LATEST: usize = 0;\nconst MMIO: *mut u8 = 0xb8000 as *mut u8;\nconst COLOR: u8 = 0xF;\n\nfn char_to_vga(a: u8) {\n    unsafe {\n        let rel: *mut u8 = ((MMIO as usize) + (LATEST * 2)) as *mut u8;\n        *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n        LATEST = LATEST + 1;\n    }\n}\n\nconst ROWS: usize = 80;\nconst COLS: usize = 25;\nconst MAX: usize = ROWS * COLS;\n\nfn scroll() {\n    unsafe {\n        for i in 80..MAX {\n            let src: *mut u8 = ((MMIO as usize) + (i * 2)) as *mut u8;\n            let dst: *mut u8 = ((MMIO as usize) + ((i - 80) * 2)) as *mut u8;\n            *dst = *src;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        for i in (MAX-80)..MAX {\n            let dst: *mut u8 = ((MMIO as usize) + ((i) * 2)) as *mut u8;\n            *dst = 32;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        LATEST = LATEST - 80;\n    }\n}\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    unsafe {\n        for i in 0..v.len() {\n            if LATEST &gt; MAX {\n                scroll();\n            }\n            match v[i] {\n                10 =&gt; LATEST = ((LATEST / 80) + 1) * 80,\n                _ =&gt; char_to_vga(v[i]),\n            }\n        }\n    }\n}",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#today",
    "href": "51_format.html#today",
    "title": "Format",
    "section": "",
    "text": "We recall our two main source code files.\n\nWe anticipate our configuration files to be unaltered.\n\n\n\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\nmod vga;\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Hello, world!\");\n    loop {}\n}\n\n\n\n\n\n\nsrc/vga.rs\n\nstatic mut LATEST: usize = 0;\nconst MMIO: *mut u8 = 0xb8000 as *mut u8;\nconst COLOR: u8 = 0xF;\n\nfn char_to_vga(a: u8) {\n    unsafe {\n        let rel: *mut u8 = ((MMIO as usize) + (LATEST * 2)) as *mut u8;\n        *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n        LATEST = LATEST + 1;\n    }\n}\n\nconst ROWS: usize = 80;\nconst COLS: usize = 25;\nconst MAX: usize = ROWS * COLS;\n\nfn scroll() {\n    unsafe {\n        for i in 80..MAX {\n            let src: *mut u8 = ((MMIO as usize) + (i * 2)) as *mut u8;\n            let dst: *mut u8 = ((MMIO as usize) + ((i - 80) * 2)) as *mut u8;\n            *dst = *src;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        for i in (MAX-80)..MAX {\n            let dst: *mut u8 = ((MMIO as usize) + ((i) * 2)) as *mut u8;\n            *dst = 32;\n            *((dst as usize + 1) as *mut u8) = COLOR;\n        }\n        LATEST = LATEST - 80;\n    }\n}\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    unsafe {\n        for i in 0..v.len() {\n            if LATEST &gt; MAX {\n                scroll();\n            }\n            match v[i] {\n                10 =&gt; LATEST = ((LATEST / 80) + 1) * 80,\n                _ =&gt; char_to_vga(v[i]),\n            }\n        }\n    }\n}",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#formatting-macros",
    "href": "51_format.html#formatting-macros",
    "title": "Format",
    "section": "Formatting Macros",
    "text": "Formatting Macros\n\nIt would be nice to support Rust‚Äôs formatting macros, too.\nWe will also discover that Rust is, in point of fact, an object-oriented language.\n\nRead: bad.\n\nI was extremely annoyed by how to get this working, but I did it.",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#functionality",
    "href": "51_format.html#functionality",
    "title": "Format",
    "section": "Functionality",
    "text": "Functionality\n\nWe need to implement the [core::fmt::Write] trait.\n\nI had foolishly assumed we could just use format!\nThat would tragically be too reasonable.\n(It also would raise some unanswered questions about memory but whatever).\n\nThe only required method of this trait is write_str:\n\ncore::fmt::Write",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#sketch",
    "href": "51_format.html#sketch",
    "title": "Format",
    "section": "Sketch",
    "text": "Sketch\n\nBasically we need to write this:\n\n\n\nsrc/vga.rs\n\nimpl core::fmt::Write for ??? {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        // Do the thing. \n        return Ok(());\n    }\n}\n\n\nThe Ok(()) is just a Ok Result containing the () ‚Äúunit type‚Äù.",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#workaround",
    "href": "51_format.html#workaround",
    "title": "Format",
    "section": "Workaround",
    "text": "Workaround\n\nI already can write text!\n\n\n\nsrc/vga.rs\n\nimpl core::fmt::Write for ??? {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        str_to_vga(s); \n        return Ok(());\n    }\n}",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#dummy-struct",
    "href": "51_format.html#dummy-struct",
    "title": "Format",
    "section": "Dummy struct",
    "text": "Dummy struct\n\nI just make an arbitrary structure.\n\n\n\nsrc/vga.rs\n\nstruct Dummy { } \n\nimpl core::fmt::Write for Dummy {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        str_to_vga(s); \n        return Ok(());\n    }\n}\n\n\nPresumably it is clear why someone would find this an annoying way to do things.",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#this-works",
    "href": "51_format.html#this-works",
    "title": "Format",
    "section": "This works",
    "text": "This works\n\nI‚Äôm not kidding it actually does.\nI was surprised too.\n\nI did forget to capitalized the W in write but‚Ä¶\n\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    use core::fmt::Write;\n    let mut d = vga::Dummy { };\n    write!(d, \"Hello {}!\", \"world\");\n    loop {}\n}\n\n\nIt throws an uninteresting warning.\n\nMake sure you know how to fix and why it happens.",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#a-println-macro",
    "href": "51_format.html#a-println-macro",
    "title": "Format",
    "section": "A println Macro",
    "text": "A println Macro\n\nWe can add a println macro.\nRust‚Äôs macro syntax is a bit strange.\nSo we won‚Äôt try to write a macro from scratch.\nInstead, we look at the source of println! in the standard library:\n\n\n\nstd/macros.rs\n\n#[macro_export]\nmacro_rules! println {\n    () =&gt; (print!(\"\\n\"));\n    ($($arg:tt)*) =&gt; (print!(\"{}\\n\", format_args!($($arg)*)));\n}",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#rules",
    "href": "51_format.html#rules",
    "title": "Format",
    "section": "Rules",
    "text": "Rules\n\nMacros are defined through one or more rules, similar to match arms.\nThe println macro has two rules:\n\nThe first rule is for invocations without arguments, e.g., println!(), which is expanded to print!(\"\\n\") and thus just prints a newline.\nThe second rule is for invocations with parameters such as println!(\"Hello\") or println!(\"Number: {}\", 4).\n\nIt is also expanded to an invocation of the print! macro.\nIt passes all arguments and an additional newline \\n at the end.\n\n\nThe #[macro_export] attribute makes the macro available to the whole crate.\nIt also places the macro at the crate root.\n\nImport the macro through use std::println instead of std::macros::println.",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#print",
    "href": "51_format.html#print",
    "title": "Format",
    "section": "print",
    "text": "print\n\n\nstd/macros.rs\n\n#[macro_export]\nmacro_rules! print {\n    ($($arg:tt)*) =&gt; ($crate::io::_print(format_args!($($arg)*)));\n}\n\n\nThe macro expands to a call of the _print function in the io module.\nThe $crate variable ensures that the macro also works from outside the std crate by expanding to std when it‚Äôs used in other crates.\nThe format_args macro builds a fmt::Arguments type from the passed arguments, which is passed to _print.\nThe _print function calls print_to, which is rather complicated because it supports different Stdout devices.\n\nWe don‚Äôt need that complexity since we just want to print to the VGA buffer.\n\n_print function\n$crate variable\nformat_args macro\nfmt::Arguments\nTo print to the VGA buffer, we just copy the println! and print! macros, but modify them to use our own _print function:\n\n\n\nsrc/vga.rs\n\n#[macro_export]\nmacro_rules! print {\n    ($($arg:tt)*) =&gt; ($crate::vga::_print(format_args!($($arg)*)));\n}\n\n#[macro_export]\nmacro_rules! println {\n    () =&gt; ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) =&gt; ($crate::print!(\"{}\\n\", format_args!($($arg)*)));\n}\n\npub fn _print(args: fmt::Arguments) {\n\n}\n\n\nHere‚Äôs mine:\n\n\npub fn _print(args: core::fmt::Arguments) {\n    use core::fmt::Write;\n    let mut d = Dummy { };\n    d.write_fmt(args).unwrap();\n}",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#hello-world-using-println",
    "href": "51_format.html#hello-world-using-println",
    "title": "Format",
    "section": "Hello World using println",
    "text": "Hello World using println\nNow we can use println in our _start function:\n\n\nsrc/main.rs\n\n```{.rs filename=\"src/main.rs\"}\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello World{}\", \"!\");\n    loop {}\n}\n\n\nWe don‚Äôt have to import the macro in the main function, because it already lives in the root namespace.",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "51_format.html#printing-panic-messages",
    "href": "51_format.html#printing-panic-messages",
    "title": "Format",
    "section": "Printing Panic Messages",
    "text": "Printing Panic Messages\nNow that we have a println macro, we can use it in our panic function to print the panic message and the location of the panic.\n\nUsing your boundless intellect and and unbreakable work ethic, implement a panic handler that prints out some relevant information.\nIt is easy enough to test.\n\npanic!(\"It is I, a panic!\");",
    "crumbs": [
      "Format"
    ]
  },
  {
    "objectID": "20_os.rjs.html#announcements",
    "href": "20_os.rjs.html#announcements",
    "title": "OS",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to OS in Rust\n\nActual OS week.\n\nAction Items:\n\nFinish working through split_at\n\nForm a strong opinion on assert\nGood anecdote for job interviews.\n\nNominally ready for next homework after this lecture.\n\nCan wait for lab/section."
  },
  {
    "objectID": "20_os.rjs.html#today",
    "href": "20_os.rjs.html#today",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages"
  },
  {
    "objectID": "20_os.rjs.html#citations",
    "href": "20_os.rjs.html#citations",
    "title": "OS",
    "section": "Citations",
    "text": "Citations\n\nBorrowed a bit from:\n\nMIT via UIC\nMIT via OCW"
  },
  {
    "objectID": "20_os.rjs.html#arriving-at-os",
    "href": "20_os.rjs.html#arriving-at-os",
    "title": "OS",
    "section": "Arriving at OS",
    "text": "Arriving at OS\n\nWe can arrive at OS from two ways:\n\nWe can look at physical hardware an infer the need for a control system.\nWe can look at formal descriptions of computing, such as automata, and infer the need for abstractions to practically use the system."
  },
  {
    "objectID": "20_os.rjs.html#the-device",
    "href": "20_os.rjs.html#the-device",
    "title": "OS",
    "section": "The Device",
    "text": "The Device\n\nWe imagine some minimal device.\n\nWhat are the minimum requirements to be a computer?"
  },
  {
    "objectID": "20_os.rjs.html#architecture---alu",
    "href": "20_os.rjs.html#architecture---alu",
    "title": "OS",
    "section": "Architecture - ALU",
    "text": "Architecture - ALU\n\nWe imagine some minimal device.\n\nIt contains an arithmetic/logic unit (ALU).\n\nCan perform e.g.¬†logical AND, bitwise AND, and numeric ADD\nCan load/store numeric values to/from numeric addresses"
  },
  {
    "objectID": "20_os.rjs.html#architecture---mmu",
    "href": "20_os.rjs.html#architecture---mmu",
    "title": "OS",
    "section": "Architecture - MMU",
    "text": "Architecture - MMU\n\nWe imagine some minimal device.\n\nIt contains ‚Äúmemory‚Äù, perhaps via a memory management unit (MMU)\n\nPersists numeric values associated with numeric addresses\nPhysically separated from the ALU\nGeniuses will say this is key-value storage"
  },
  {
    "objectID": "20_os.rjs.html#picture",
    "href": "20_os.rjs.html#picture",
    "title": "OS",
    "section": "Picture",
    "text": "Picture\n\n\n\n\n\n\n\ngraphgraph\n\n\nALU\n\nALU\n\n\n\nALU-&gt;ALU\n\n\nplus\n\n\n\nMMU\n\nMMU\n\n\n\nALU-&gt;MMU\n\n\nsave\n\n\n\nMMU-&gt;ALU\n\n\nload"
  },
  {
    "objectID": "20_os.rjs.html#architecture-1",
    "href": "20_os.rjs.html#architecture-1",
    "title": "OS",
    "section": "Architecture",
    "text": "Architecture\n\nThis is the now-legendary Von Neumann architecture."
  },
  {
    "objectID": "20_os.rjs.html#von-neumann-formally",
    "href": "20_os.rjs.html#von-neumann-formally",
    "title": "OS",
    "section": "Von Neumann, Formally",
    "text": "Von Neumann, Formally\n\nA central arithmetic unit to perform arithmetic operations;\nA central control unit to sequence operations performed by the machine;\nMemory that stores data and instructions;\nAn ‚Äúoutside recording medium‚Äù to store input to and output from the machine;\nInput and output mechanisms to transfer data between the memory and the outside recording medium."
  },
  {
    "objectID": "20_os.rjs.html#competing-formulation",
    "href": "20_os.rjs.html#competing-formulation",
    "title": "OS",
    "section": "Competing Formulation",
    "text": "Competing Formulation\nThe competing formulation known as the Harvard architecture differed in that information describing actions (say, executables or ‚Äústored memory programs‚Äù or ‚Äúinstructions‚Äù) and information for read-write (say data files or just ‚Äúdata‚Äù) had distinct storage mediums.\n\nAs far as I know, none of these were ever made.\nTheoretical idea."
  },
  {
    "objectID": "20_os.rjs.html#harvard-architecture",
    "href": "20_os.rjs.html#harvard-architecture",
    "title": "OS",
    "section": "Harvard Architecture",
    "text": "Harvard Architecture"
  },
  {
    "objectID": "20_os.rjs.html#historical-use-case",
    "href": "20_os.rjs.html#historical-use-case",
    "title": "OS",
    "section": "Historical use case",
    "text": "Historical use case\n\nHistorical computing devices had no onboard storage and programs lived on e.g.¬†external tapes.\n\nThe Harvard architecture is a helpful model in this case.\n\nToday, everything lives on a SSD (OS, browser, audo/video files, debug logs, etc.)\n\nHence Von Neumann"
  },
  {
    "objectID": "20_os.rjs.html#von-neumann---aside",
    "href": "20_os.rjs.html#von-neumann---aside",
    "title": "OS",
    "section": "Von Neumann - Aside",
    "text": "Von Neumann - Aside\n\n\n\nBe advised this is a Manhattan Project member and form your own opinion about that."
  },
  {
    "objectID": "20_os.rjs.html#hardware-doesnt-matter",
    "href": "20_os.rjs.html#hardware-doesnt-matter",
    "title": "OS",
    "section": "Hardware ‚Äúdoesn‚Äôt matter‚Äù",
    "text": "Hardware ‚Äúdoesn‚Äôt matter‚Äù\n\nWe can regard as a historical accident that hardware exists in any particular form.\n\nPerhaps the first computers could‚Äôve been biological vs.¬†mechanical vs.¬†electric.\n\nWe then regard the automata, principly the Turing Machine, as ground truth.\n\nTMs are out-of-scope for this class but probably should be a required topic in a post-Algorithms class, someday‚Ä¶\nRead more"
  },
  {
    "objectID": "20_os.rjs.html#thinking-about-a-tm",
    "href": "20_os.rjs.html#thinking-about-a-tm",
    "title": "OS",
    "section": "Thinking about a TM",
    "text": "Thinking about a TM\n\n\n\n\nHead can read and write\nHead is two-way\nTape is infinite\nInfinitely many blanks(0) follow input\nCan accept/reject at any time"
  },
  {
    "objectID": "20_os.rjs.html#vs.-hardware",
    "href": "20_os.rjs.html#vs.-hardware",
    "title": "OS",
    "section": "Vs. Hardware",
    "text": "Vs. Hardware\n\nThe TM assumes infinite memory\n\nNot a big deal, you‚Äôll never actually use infinite memory.\n\nThe TM makes no considerations of performance\n\nTapes are slower than wires, but perhaps easier to imagine.\n\nThe TM does not necessarily use binary\n\nBut then again, before-Turing, neither did computers‚Ä¶"
  },
  {
    "objectID": "20_os.rjs.html#say-we-build-a-tm",
    "href": "20_os.rjs.html#say-we-build-a-tm",
    "title": "OS",
    "section": "Say we build a TM",
    "text": "Say we build a TM\n\nWell, someone we have to model an ‚Äúinfinite tape‚Äù of memory.\n\nPerhaps by‚Ä¶ creating a bijection to the natural numbers.\nWe could then have numeric locations on the type correspond to written values (which may be numeric or linguistic)\nWait that is the same key-value storage as the MMU."
  },
  {
    "objectID": "20_os.rjs.html#all-roads",
    "href": "20_os.rjs.html#all-roads",
    "title": "OS",
    "section": "All Roads",
    "text": "All Roads\n\n‚Ä¶lead to a series of abstractions allowing higher-level users to use, but not implement, memory.\n\n\n\n\n\n\n\n\nG\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4"
  },
  {
    "objectID": "20_os.rjs.html#different-topics",
    "href": "20_os.rjs.html#different-topics",
    "title": "OS",
    "section": "Different Topics",
    "text": "Different Topics\n\nAs we layer abstractions, writing code is more efficent and running code is less efficient.\n\nUntil mature technologies outcompete humans.\n\n\n\n\n\n\n\n\n\nG\n\n\nm1\n\nElectrical\nEngineering\n\n\n\nm2\n\nArchitecture\nand OSes\n\n\n\nm1-&gt;m2\n\n\n\n\n\nm3\n\nCompilers\n(or std)\n\n\n\nm2-&gt;m3\n\n\n\n\n\nm4\n\nScripting\nLanguages\n\n\n\nm3-&gt;m4\n\n\n\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4"
  },
  {
    "objectID": "20_os.rjs.html#bus-1",
    "href": "20_os.rjs.html#bus-1",
    "title": "OS",
    "section": "Bus",
    "text": "Bus\n\nIn computer architecture, a bus (historically also called a data highway or databus) is a communication system that transfers data between components inside a computer or between computers. It encompasses both hardware (e.g., wires, optical fiber) and software, including communication protocols. At its core, a bus is a shared physical pathway, typically composed of wires, traces on a circuit board, or busbars, that allows multiple devices to communicate."
  },
  {
    "objectID": "20_os.rjs.html#shorter",
    "href": "20_os.rjs.html#shorter",
    "title": "OS",
    "section": "Shorter",
    "text": "Shorter\n\nA bus is a bundle of wires that transfers bits.\n\n\n\n\n\n\n\n\nG\n\n\ncpu\n\nCPU\n\n\n\nbus_middle\n\n\n\n\ncpu-&gt;bus_middle\n\n\n\n\n\nbus_right\n\n\n\n\nbus_middle-&gt;bus_right\n\n\n\n\nbus_left\n\n\n\n\nbus_left-&gt;bus_middle\n\n\n\n\nram\n\nRAM\n\n\n\nbus_left-&gt;ram\n\n\n\n\n\nio\n\nI/O\n\n\n\nbus_right-&gt;io"
  },
  {
    "objectID": "20_os.rjs.html#i-imagine",
    "href": "20_os.rjs.html#i-imagine",
    "title": "OS",
    "section": "I imagine‚Ä¶",
    "text": "I imagine‚Ä¶\n\nTwo registers (an ordered collection of bits) are populated by some device on a bus.\n\nOne for a numeric value.\nOne for a numeric address."
  },
  {
    "objectID": "20_os.rjs.html#i-imagine-1",
    "href": "20_os.rjs.html#i-imagine-1",
    "title": "OS",
    "section": "I imagine‚Ä¶",
    "text": "I imagine‚Ä¶\n\nThat device writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they ‚Äúown‚Äù the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever."
  },
  {
    "objectID": "20_os.rjs.html#within-a-device",
    "href": "20_os.rjs.html#within-a-device",
    "title": "OS",
    "section": "Within a Device",
    "text": "Within a Device\n\nWithin devices, numerical values are separated spatially.\n\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0"
  },
  {
    "objectID": "20_os.rjs.html#within-a-bus",
    "href": "20_os.rjs.html#within-a-bus",
    "title": "OS",
    "section": "Within a Bus",
    "text": "Within a Bus\n\nOn the bus, the wire is either, say, ‚Äúhigh‚Äù or ‚Äúlow‚Äù and these values are interpreted as ‚Äúone‚Äù or ‚Äúzero‚Äù.\n\nWe term this ‚Äúdigital‚Äù\n\n\n\ncomposed of data in the form of especially binary digits"
  },
  {
    "objectID": "20_os.rjs.html#signal-processing",
    "href": "20_os.rjs.html#signal-processing",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nE.g. sine wave with some recording window.\n\n Source"
  },
  {
    "objectID": "20_os.rjs.html#signal-processing-1",
    "href": "20_os.rjs.html#signal-processing-1",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nOut of scope\n\nPhysics/Electrical Engineering topic\nSeen in Data in the Cosmos and Computer Vision\nLudicrously radical\n\nWe handwave it here, and only introduce so you understand what the hardware/OS has to deal with."
  },
  {
    "objectID": "20_os.rjs.html#given-a-bus",
    "href": "20_os.rjs.html#given-a-bus",
    "title": "OS",
    "section": "Given a bus",
    "text": "Given a bus\n\nSay we have both a keyboard and an MMU on a bus with our ALU/CPU\n\nSay I input d, ASCII 100/0x64, on my keyboard\nThe keyboard broadcasts onto bus\nThe ALU and MMU read it\n\nHow is the signal interpreted?"
  },
  {
    "objectID": "20_os.rjs.html#throwback",
    "href": "20_os.rjs.html#throwback",
    "title": "OS",
    "section": "Throwback",
    "text": "Throwback\n\nDevice writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they ‚Äúown‚Äù the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever."
  },
  {
    "objectID": "20_os.rjs.html#so",
    "href": "20_os.rjs.html#so",
    "title": "OS",
    "section": "So‚Ä¶",
    "text": "So‚Ä¶\n\nThe keyboard doesn‚Äôt just blast a `0b1100100‚Äô onto bus.\nRather, it broadcasts some pre-determined ‚Äúaddress‚Äù corresponding to keyboard input.\n\nThe ALU sees this and knows to prepare a register to store the incoming value.\nThe MMU sees this and knows to hit a snooze.\n\nSo the keyboard prepends the numeric value with a numeric address.\n\nThis is the importance of an address space."
  },
  {
    "objectID": "20_os.rjs.html#the-big-idea",
    "href": "20_os.rjs.html#the-big-idea",
    "title": "OS",
    "section": "The Big Idea",
    "text": "The Big Idea\n\nImagine the bus is an array.\nEach array element is some word size, say 8 (cringe), 32 (mid), 64 (based), or 128 (excessive) bits.\nEach array element has some numeric address."
  },
  {
    "objectID": "20_os.rjs.html#for-the-alu",
    "href": "20_os.rjs.html#for-the-alu",
    "title": "OS",
    "section": "For the ALU",
    "text": "For the ALU\n\nWhen the ALU wants to write to memory\n\nAddress the MMU, either as\n\nA region as large as physical memory\nOne address then a key-value pair\n\nThe ALU writes a value to an address\n\nThe MMU sees this on bus and acts accordingly\nThe keyboard does whatever"
  },
  {
    "objectID": "20_os.rjs.html#wrinkles",
    "href": "20_os.rjs.html#wrinkles",
    "title": "OS",
    "section": "Wrinkles",
    "text": "Wrinkles\n\nSounds easy?\nWe can optimize"
  },
  {
    "objectID": "20_os.rjs.html#gaps",
    "href": "20_os.rjs.html#gaps",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\nUsually address space is much larger than RAM\nAddresses that can be accessed are referred to as ‚Äúmapped‚Äù\nAnd holes that can‚Äôt be accessed are ‚Äúunmapped‚Äù\nWhat happens if the CPU loads or stores to an unmapped region"
  },
  {
    "objectID": "20_os.rjs.html#gaps-1",
    "href": "20_os.rjs.html#gaps-1",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\n0x0C\n\n0x08\n\n0x04\n\n0x00\n\n\n\nnode1\n\nMonitor\n\n \n\nGPU\n\nMemory\n\nKeyboard\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1"
  },
  {
    "objectID": "20_os.rjs.html#permissions",
    "href": "20_os.rjs.html#permissions",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\nUsually as RWX\n\nRead\nWrite\nEXecute\nThe dastardly von Neumann model rears its ugly head etc.\n\nWhy have these, and\nWhat if they are violated"
  },
  {
    "objectID": "20_os.rjs.html#permissions-1",
    "href": "20_os.rjs.html#permissions-1",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\n.ini\n\n.txt\n\n.exe\n\n.log\n\n.sh\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1"
  },
  {
    "objectID": "20_os.rjs.html#multiple-devices",
    "href": "20_os.rjs.html#multiple-devices",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\nTreat code and data as the same.\nBe unfathomably based.\nThe keyboard is just memory.\nSo is the CPU/GPU\nSo is the internet (Network interface controller)\n\nWe can execute the internet?"
  },
  {
    "objectID": "20_os.rjs.html#multiple-devices-1",
    "href": "20_os.rjs.html#multiple-devices-1",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\nI/O\n\nkeys\n\nMMU\n\n.txt\n\nMMU\n\n.exe\n\nNIC\n\n.htm\n\nNIC\n\n.jsx\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1"
  },
  {
    "objectID": "20_os.rjs.html#further",
    "href": "20_os.rjs.html#further",
    "title": "OS",
    "section": "Further",
    "text": "Further\n\nPhysical vs.¬†virtual address\n\nUsually computers can describe more memory locations than the MMU can retain.\n\nCaching\n\nUsually read/write is slow but repeated, so save common requests to deload devices and bus\n\nBlock size\n\nBits and even words are are two small, usually pages (4KB) or blocks (cloud scale)"
  },
  {
    "objectID": "20_os.rjs.html#recall",
    "href": "20_os.rjs.html#recall",
    "title": "OS",
    "section": "Recall",
    "text": "Recall\n\nYou have already been a client of the stack/heap\n\nIn C\nIn Rust\n\nQuoth me:\n\n\nIt‚Äôs the OS‚Äôs problem. And therefore our problem next term."
  },
  {
    "objectID": "20_os.rjs.html#python",
    "href": "20_os.rjs.html#python",
    "title": "OS",
    "section": "Python",
    "text": "Python\nimport ctypes\nimport gc \n\ndi = lambda obj_id : _ctypes.PyObj_FromPtr(obj_id)\nfree = gc.collect"
  },
  {
    "objectID": "20_os.rjs.html#rust",
    "href": "20_os.rjs.html#rust",
    "title": "OS",
    "section": "Rust",
    "text": "Rust\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}"
  },
  {
    "objectID": "20_os.rjs.html#c",
    "href": "20_os.rjs.html#c",
    "title": "OS",
    "section": "C",
    "text": "C\n#include &lt;stdlib.h&gt;\n\nvoid main() {\n        int *p = (int *)malloc(sizeof(int));\n        int *q = (int *)malloc(sizeof(int));\n        free(p);\n        p = q;\n}"
  },
  {
    "objectID": "20_os.rjs.html#all-of-these",
    "href": "20_os.rjs.html#all-of-these",
    "title": "OS",
    "section": "All of these‚Ä¶",
    "text": "All of these‚Ä¶\n\nAre your problem now.\nThere is also a stack (less theoretically complicated, more implementation complicated) which we have also covered.\nOn to the lab/homework!"
  },
  {
    "objectID": "20_os.rjs.html#today-1",
    "href": "20_os.rjs.html#today-1",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages"
  },
  {
    "objectID": "20_os.html",
    "href": "20_os.html",
    "title": "OS",
    "section": "",
    "text": "Welcome to OS in Rust\n\nActual OS week.\n\nAction Items:\n\nFinish working through split_at\n\nForm a strong opinion on assert\nGood anecdote for job interviews.\n\nNominally ready for next homework after this lecture.\n\nCan wait for lab/section.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#announcements",
    "href": "20_os.html#announcements",
    "title": "OS",
    "section": "",
    "text": "Welcome to OS in Rust\n\nActual OS week.\n\nAction Items:\n\nFinish working through split_at\n\nForm a strong opinion on assert\nGood anecdote for job interviews.\n\nNominally ready for next homework after this lecture.\n\nCan wait for lab/section.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#today",
    "href": "20_os.html#today",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#citations",
    "href": "20_os.html#citations",
    "title": "OS",
    "section": "Citations",
    "text": "Citations\n\nBorrowed a bit from:\n\nMIT via UIC\nMIT via OCW",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#arriving-at-os",
    "href": "20_os.html#arriving-at-os",
    "title": "OS",
    "section": "Arriving at OS",
    "text": "Arriving at OS\n\nWe can arrive at OS from two ways:\n\nWe can look at physical hardware an infer the need for a control system.\nWe can look at formal descriptions of computing, such as automata, and infer the need for abstractions to practically use the system.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#the-device",
    "href": "20_os.html#the-device",
    "title": "OS",
    "section": "The Device",
    "text": "The Device\n\nWe imagine some minimal device.\n\nWhat are the minimum requirements to be a computer?",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#architecture---alu",
    "href": "20_os.html#architecture---alu",
    "title": "OS",
    "section": "Architecture - ALU",
    "text": "Architecture - ALU\n\nWe imagine some minimal device.\n\nIt contains an arithmetic/logic unit (ALU).\n\nCan perform e.g.¬†logical AND, bitwise AND, and numeric ADD\nCan load/store numeric values to/from numeric addresses",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#architecture---mmu",
    "href": "20_os.html#architecture---mmu",
    "title": "OS",
    "section": "Architecture - MMU",
    "text": "Architecture - MMU\n\nWe imagine some minimal device.\n\nIt contains ‚Äúmemory‚Äù, perhaps via a memory management unit (MMU)\n\nPersists numeric values associated with numeric addresses\nPhysically separated from the ALU\nGeniuses will say this is key-value storage",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#picture",
    "href": "20_os.html#picture",
    "title": "OS",
    "section": "Picture",
    "text": "Picture\n\n\n\n\n\n\n\ngraphgraph\n\n\nALU\n\nALU\n\n\n\nALU-&gt;ALU\n\n\nplus\n\n\n\nMMU\n\nMMU\n\n\n\nALU-&gt;MMU\n\n\nsave\n\n\n\nMMU-&gt;ALU\n\n\nload",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#architecture-1",
    "href": "20_os.html#architecture-1",
    "title": "OS",
    "section": "Architecture",
    "text": "Architecture\n\nThis is the now-legendary Von Neumann architecture.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#von-neumann-formally",
    "href": "20_os.html#von-neumann-formally",
    "title": "OS",
    "section": "Von Neumann, Formally",
    "text": "Von Neumann, Formally\n\nA central arithmetic unit to perform arithmetic operations;\nA central control unit to sequence operations performed by the machine;\nMemory that stores data and instructions;\nAn ‚Äúoutside recording medium‚Äù to store input to and output from the machine;\nInput and output mechanisms to transfer data between the memory and the outside recording medium.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#competing-formulation",
    "href": "20_os.html#competing-formulation",
    "title": "OS",
    "section": "Competing Formulation",
    "text": "Competing Formulation\nThe competing formulation known as the Harvard architecture differed in that information describing actions (say, executables or ‚Äústored memory programs‚Äù or ‚Äúinstructions‚Äù) and information for read-write (say data files or just ‚Äúdata‚Äù) had distinct storage mediums.\n\nAs far as I know, none of these were ever made.\nTheoretical idea.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#harvard-architecture",
    "href": "20_os.html#harvard-architecture",
    "title": "OS",
    "section": "Harvard Architecture",
    "text": "Harvard Architecture",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#historical-use-case",
    "href": "20_os.html#historical-use-case",
    "title": "OS",
    "section": "Historical use case",
    "text": "Historical use case\n\nHistorical computing devices had no onboard storage and programs lived on e.g.¬†external tapes.\n\nThe Harvard architecture is a helpful model in this case.\n\nToday, everything lives on a SSD (OS, browser, audo/video files, debug logs, etc.)\n\nHence Von Neumann",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#von-neumann---aside",
    "href": "20_os.html#von-neumann---aside",
    "title": "OS",
    "section": "Von Neumann - Aside",
    "text": "Von Neumann - Aside\n\n\n\nBe advised this is a Manhattan Project member and form your own opinion about that.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#hardware-doesnt-matter",
    "href": "20_os.html#hardware-doesnt-matter",
    "title": "OS",
    "section": "Hardware ‚Äúdoesn‚Äôt matter‚Äù",
    "text": "Hardware ‚Äúdoesn‚Äôt matter‚Äù\n\nWe can regard as a historical accident that hardware exists in any particular form.\n\nPerhaps the first computers could‚Äôve been biological vs.¬†mechanical vs.¬†electric.\n\nWe then regard the automata, principly the Turing Machine, as ground truth.\n\nTMs are out-of-scope for this class but probably should be a required topic in a post-Algorithms class, someday‚Ä¶\nRead more",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#thinking-about-a-tm",
    "href": "20_os.html#thinking-about-a-tm",
    "title": "OS",
    "section": "Thinking about a TM",
    "text": "Thinking about a TM\n\n\n\n\nHead can read and write\nHead is two-way\nTape is infinite\nInfinitely many blanks(0) follow input\nCan accept/reject at any time",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#vs.-hardware",
    "href": "20_os.html#vs.-hardware",
    "title": "OS",
    "section": "Vs. Hardware",
    "text": "Vs. Hardware\n\nThe TM assumes infinite memory\n\nNot a big deal, you‚Äôll never actually use infinite memory.\n\nThe TM makes no considerations of performance\n\nTapes are slower than wires, but perhaps easier to imagine.\n\nThe TM does not necessarily use binary\n\nBut then again, before-Turing, neither did computers‚Ä¶",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#say-we-build-a-tm",
    "href": "20_os.html#say-we-build-a-tm",
    "title": "OS",
    "section": "Say we build a TM",
    "text": "Say we build a TM\n\nWell, someone we have to model an ‚Äúinfinite tape‚Äù of memory.\n\nPerhaps by‚Ä¶ creating a bijection to the natural numbers.\nWe could then have numeric locations on the type correspond to written values (which may be numeric or linguistic)\nWait that is the same key-value storage as the MMU.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#all-roads",
    "href": "20_os.html#all-roads",
    "title": "OS",
    "section": "All Roads",
    "text": "All Roads\n\n‚Ä¶lead to a series of abstractions allowing higher-level users to use, but not implement, memory.\n\n\n\n\n\n\n\n\nG\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#different-topics",
    "href": "20_os.html#different-topics",
    "title": "OS",
    "section": "Different Topics",
    "text": "Different Topics\n\nAs we layer abstractions, writing code is more efficent and running code is less efficient.\n\nUntil mature technologies outcompete humans.\n\n\n\n\n\n\n\n\n\nG\n\n\nm1\n\nElectrical\nEngineering\n\n\n\nm2\n\nArchitecture\nand OSes\n\n\n\nm1-&gt;m2\n\n\n\n\n\nm3\n\nCompilers\n(or std)\n\n\n\nm2-&gt;m3\n\n\n\n\n\nm4\n\nScripting\nLanguages\n\n\n\nm3-&gt;m4\n\n\n\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#bus-1",
    "href": "20_os.html#bus-1",
    "title": "OS",
    "section": "Bus",
    "text": "Bus\n\nIn computer architecture, a bus (historically also called a data highway or databus) is a communication system that transfers data between components inside a computer or between computers. It encompasses both hardware (e.g., wires, optical fiber) and software, including communication protocols. At its core, a bus is a shared physical pathway, typically composed of wires, traces on a circuit board, or busbars, that allows multiple devices to communicate.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#shorter",
    "href": "20_os.html#shorter",
    "title": "OS",
    "section": "Shorter",
    "text": "Shorter\n\nA bus is a bundle of wires that transfers bits.\n\n\n\n\n\n\n\n\nG\n\n\ncpu\n\nCPU\n\n\n\nbus_middle\n\n\n\n\ncpu-&gt;bus_middle\n\n\n\n\n\nbus_right\n\n\n\n\nbus_middle-&gt;bus_right\n\n\n\n\nbus_left\n\n\n\n\nbus_left-&gt;bus_middle\n\n\n\n\nram\n\nRAM\n\n\n\nbus_left-&gt;ram\n\n\n\n\n\nio\n\nI/O\n\n\n\nbus_right-&gt;io",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#i-imagine",
    "href": "20_os.html#i-imagine",
    "title": "OS",
    "section": "I imagine‚Ä¶",
    "text": "I imagine‚Ä¶\n\nTwo registers (an ordered collection of bits) are populated by some device on a bus.\n\nOne for a numeric value.\nOne for a numeric address.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#i-imagine-1",
    "href": "20_os.html#i-imagine-1",
    "title": "OS",
    "section": "I imagine‚Ä¶",
    "text": "I imagine‚Ä¶\n\nThat device writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they ‚Äúown‚Äù the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#within-a-device",
    "href": "20_os.html#within-a-device",
    "title": "OS",
    "section": "Within a Device",
    "text": "Within a Device\n\nWithin devices, numerical values are separated spatially.\n\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#within-a-bus",
    "href": "20_os.html#within-a-bus",
    "title": "OS",
    "section": "Within a Bus",
    "text": "Within a Bus\n\nOn the bus, the wire is either, say, ‚Äúhigh‚Äù or ‚Äúlow‚Äù and these values are interpreted as ‚Äúone‚Äù or ‚Äúzero‚Äù.\n\nWe term this ‚Äúdigital‚Äù\n\n\n\ncomposed of data in the form of especially binary digits",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#signal-processing",
    "href": "20_os.html#signal-processing",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nE.g. sine wave with some recording window.\n\n Source",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#signal-processing-1",
    "href": "20_os.html#signal-processing-1",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nOut of scope\n\nPhysics/Electrical Engineering topic\nSeen in Data in the Cosmos and Computer Vision\nLudicrously radical\n\nWe handwave it here, and only introduce so you understand what the hardware/OS has to deal with.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#given-a-bus",
    "href": "20_os.html#given-a-bus",
    "title": "OS",
    "section": "Given a bus",
    "text": "Given a bus\n\nSay we have both a keyboard and an MMU on a bus with our ALU/CPU\n\nSay I input d, ASCII 100/0x64, on my keyboard\nThe keyboard broadcasts onto bus\nThe ALU and MMU read it\n\nHow is the signal interpreted?",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#throwback",
    "href": "20_os.html#throwback",
    "title": "OS",
    "section": "Throwback",
    "text": "Throwback\n\nDevice writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they ‚Äúown‚Äù the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#so",
    "href": "20_os.html#so",
    "title": "OS",
    "section": "So‚Ä¶",
    "text": "So‚Ä¶\n\nThe keyboard doesn‚Äôt just blast a `0b1100100‚Äô onto bus.\nRather, it broadcasts some pre-determined ‚Äúaddress‚Äù corresponding to keyboard input.\n\nThe ALU sees this and knows to prepare a register to store the incoming value.\nThe MMU sees this and knows to hit a snooze.\n\nSo the keyboard prepends the numeric value with a numeric address.\n\nThis is the importance of an address space.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#the-big-idea",
    "href": "20_os.html#the-big-idea",
    "title": "OS",
    "section": "The Big Idea",
    "text": "The Big Idea\n\nImagine the bus is an array.\nEach array element is some word size, say 8 (cringe), 32 (mid), 64 (based), or 128 (excessive) bits.\nEach array element has some numeric address.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#for-the-alu",
    "href": "20_os.html#for-the-alu",
    "title": "OS",
    "section": "For the ALU",
    "text": "For the ALU\n\nWhen the ALU wants to write to memory\n\nAddress the MMU, either as\n\nA region as large as physical memory\nOne address then a key-value pair\n\nThe ALU writes a value to an address\n\nThe MMU sees this on bus and acts accordingly\nThe keyboard does whatever",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#wrinkles",
    "href": "20_os.html#wrinkles",
    "title": "OS",
    "section": "Wrinkles",
    "text": "Wrinkles\n\nSounds easy?\nWe can optimize",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#gaps",
    "href": "20_os.html#gaps",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\nUsually address space is much larger than RAM\nAddresses that can be accessed are referred to as ‚Äúmapped‚Äù\nAnd holes that can‚Äôt be accessed are ‚Äúunmapped‚Äù\nWhat happens if the CPU loads or stores to an unmapped region",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#gaps-1",
    "href": "20_os.html#gaps-1",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\n0x0C\n\n0x08\n\n0x04\n\n0x00\n\n\n\nnode1\n\nMonitor\n\n \n\nGPU\n\nMemory\n\nKeyboard\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#permissions",
    "href": "20_os.html#permissions",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\nUsually as RWX\n\nRead\nWrite\nEXecute\nThe dastardly von Neumann model rears its ugly head etc.\n\nWhy have these, and\nWhat if they are violated",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#permissions-1",
    "href": "20_os.html#permissions-1",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\n.ini\n\n.txt\n\n.exe\n\n.log\n\n.sh\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#multiple-devices",
    "href": "20_os.html#multiple-devices",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\nTreat code and data as the same.\nBe unfathomably based.\nThe keyboard is just memory.\nSo is the CPU/GPU\nSo is the internet (Network interface controller)\n\nWe can execute the internet?",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#multiple-devices-1",
    "href": "20_os.html#multiple-devices-1",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\nI/O\n\nkeys\n\nMMU\n\n.txt\n\nMMU\n\n.exe\n\nNIC\n\n.htm\n\nNIC\n\n.jsx\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#further",
    "href": "20_os.html#further",
    "title": "OS",
    "section": "Further",
    "text": "Further\n\nPhysical vs.¬†virtual address\n\nUsually computers can describe more memory locations than the MMU can retain.\n\nCaching\n\nUsually read/write is slow but repeated, so save common requests to deload devices and bus\n\nBlock size\n\nBits and even words are are two small, usually pages (4KB) or blocks (cloud scale)",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#recall",
    "href": "20_os.html#recall",
    "title": "OS",
    "section": "Recall",
    "text": "Recall\n\nYou have already been a client of the stack/heap\n\nIn C\nIn Rust\n\nQuoth me:\n\n\nIt‚Äôs the OS‚Äôs problem. And therefore our problem next term.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#python",
    "href": "20_os.html#python",
    "title": "OS",
    "section": "Python",
    "text": "Python\nimport ctypes\nimport gc \n\ndi = lambda obj_id : _ctypes.PyObj_FromPtr(obj_id)\nfree = gc.collect",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#rust",
    "href": "20_os.html#rust",
    "title": "OS",
    "section": "Rust",
    "text": "Rust\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#c",
    "href": "20_os.html#c",
    "title": "OS",
    "section": "C",
    "text": "C\n#include &lt;stdlib.h&gt;\n\nvoid main() {\n        int *p = (int *)malloc(sizeof(int));\n        int *q = (int *)malloc(sizeof(int));\n        free(p);\n        p = q;\n}",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#all-of-these",
    "href": "20_os.html#all-of-these",
    "title": "OS",
    "section": "All of these‚Ä¶",
    "text": "All of these‚Ä¶\n\nAre your problem now.\nThere is also a stack (less theoretically complicated, more implementation complicated) which we have also covered.\nOn to the lab/homework!",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#today-1",
    "href": "20_os.html#today-1",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages",
    "crumbs": [
      "OS"
    ]
  }
]