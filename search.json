[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OS in Rust",
    "section": "",
    "text": "CS 371 “OS in Rust”\n\nCalled:\n\nCS 371: Advanced Systems Computing, Adv. Operating Systems\n\nThe second semester class in a:\n\nCompiled language, with\nNo garbage collector.\n\nIn the second semester, one of the \\(n\\) great systems\n\nOperating System (OS)\nCompiler\nWeb Server\n\nTaught this year on OS and in Rust.\n\nSo to me, “OS in Rust”\n\n\n\nMW 1310-1440\n\n\nProf. Calvin\n\n\nSyllabus\n\nSyllabus link\n\n\n\n\nCalendar\n\n\n\nWeek\nDate (M)\nLecture (M)\nLab (W)\nHW (F)\n\n\n\n\n0x0\n01/12\nDerust\nwc\nCLI\n\n\n0x1\n01/19\nNone\nUnsafe\nSplits\n\n\n0x2\n01/26\nOSes\nTransmute\nmalloc\n\n\n0x3\n02/02\nBare Metal\nLinker\nRISC-V\n\n\n0x4\n02/09\nKernel\nBoot\nHello\n\n\n0x5\n02/16\nText\n\n\n\n\n0x6\n02/23\nTesting\n\n\n\n\n0x7\n03/02\nExceptions\n\n\n\n\n0x8\n03/09\nFaults\n\n\n\n\n0x9\n03/16\nInterrupts\n\n\n\n\n0bX\n03/23\nNone\nNone\nNone\n\n\n0xA\n03/30\nPaging\n\n\n\n\n0xB\n03/06\nPage Tables\n\n\n\n\n0xC\n04/13\nThe Heap\n\n\n\n\n0xD\n04/20\nAllocators\nNone\n\n\n\n0xE\n04/29\nasync\n\nNone\n\n\n\n\nFinal OS due Tuesday, May 5th, from 2:00 pm - 5:00 pm (5 PM ET on 5/5)\n\n\nLecture Recordings"
  },
  {
    "objectID": "41_boot.html",
    "href": "41_boot.html",
    "title": "Boot",
    "section": "",
    "text": "We had add a .cargo/config.toml and updated our existing files.\nWe were able to build an executable for a bare metal target.\nWe have not yet run the executable, and will have to do so using qemu.\n\n\n\n\n\nLet’s break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed “misc” qemu\n\nReal ones will use apt\n\n\nsudo apt install qemu-system-x86\n\n\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab.\n\n\n\n\n\n\nUnaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}\n\n\n\n\n\nAll new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"\n\n\n\n\n\nAll new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}\n\n\n\n\n\nMove panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#where-we-left-off.",
    "href": "41_boot.html#where-we-left-off.",
    "title": "Boot",
    "section": "",
    "text": "We had add a .cargo/config.toml and updated our existing files.\nWe were able to build an executable for a bare metal target.\nWe have not yet run the executable, and will have to do so using qemu.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#qemu",
    "href": "41_boot.html#qemu",
    "title": "Boot",
    "section": "",
    "text": "Let’s break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed “misc” qemu\n\nReal ones will use apt\n\n\nsudo apt install qemu-system-x86",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#boot-it",
    "href": "41_boot.html#boot-it",
    "title": "Boot",
    "section": "",
    "text": "$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#main-file",
    "href": "41_boot.html#main-file",
    "title": "Boot",
    "section": "",
    "text": "Unaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#config-file",
    "href": "41_boot.html#config-file",
    "title": "Boot",
    "section": "",
    "text": "All new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#target-file",
    "href": "41_boot.html#target-file",
    "title": "Boot",
    "section": "",
    "text": "All new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#cargo-file",
    "href": "41_boot.html#cargo-file",
    "title": "Boot",
    "section": "",
    "text": "Move panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#running-our-kernel",
    "href": "41_boot.html#running-our-kernel",
    "title": "Boot",
    "section": "Running our Kernel",
    "text": "Running our Kernel\n\nNow that we have an executable that does something perceptible, it is time to run it.\nFirst, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader.\nThen we can run the disk image in qemu virtual machine…\n…or boot it on real hardware using a USB stick.\n\nIf you do that, you are responsible for what happens.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#creating-a-bootimage",
    "href": "41_boot.html#creating-a-bootimage",
    "title": "Boot",
    "section": "Creating a Bootimage",
    "text": "Creating a Bootimage\n\nTo turn our compiled kernel into a bootable disk image, we need to link it with a bootloader.\nRecall the bootloader is responsible for initializing the CPU and loading our kernel.\n\nMU/TH/UR dumping a bucket of electrons atop a CPU.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#work-smart-not-hard",
    "href": "41_boot.html#work-smart-not-hard",
    "title": "Boot",
    "section": "Work Smart Not Hard",
    "text": "Work Smart Not Hard\n\nWe do not write our own bootloader1.\nWe use the bootloader crate.\nThis crate implements a basic BIOS bootloader without any C dependencies.\n\nJust Rust and\ninline assembly (asm!, handwaved for the compilers class)\n\nTo use it for booting our kernel, we need to add a dependency on it:\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nbootloader = \"0.9\"\n\n\nNote: We use bootloader v0.9.\nNewer versions allegedly use a different build system and will result in build errors.\n\nI didn’t check.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#onward",
    "href": "41_boot.html#onward",
    "title": "Boot",
    "section": "Onward!",
    "text": "Onward!\n\nAdding the bootloader as a dependency is not enough to actually create a bootable disk image.\nThe problem is that we need to link our kernel with the bootloader after compilation.\nBut Cargo has no support for [post-build scripts].(https://github.com/rust-lang/cargo/issues/545)\n\nTypical Cargo L.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#install-bootimage",
    "href": "41_boot.html#install-bootimage",
    "title": "Boot",
    "section": "Install Bootimage",
    "text": "Install Bootimage\n\nTo solve this problem, use a tool named bootimage\nIt first compiles the kernel and bootloader.\nThen it links them together to create a bootable disk image.\nTo install the tool, we will use… cargo:\n\ncargo install bootimage",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#create-bootimage",
    "href": "41_boot.html#create-bootimage",
    "title": "Boot",
    "section": "Create Bootimage",
    "text": "Create Bootimage\n\nOnce installed it is a simple matter to use:\n\ncargo bootimage\n\nThis will obviously work on the first try, unless it doesn’t.\nIn point of fact, I expect you to be able to fix two or three sequential errors you should see after using this command.\n\nStop here and get a bootimage working with no errors.\nYou can consult lecture materials and also review the recommendations of Cargo when it reports an error.\nIf you get stuck here’s a spoiler.\n\n\n\nrustup +nightly component add llvm-tools-preview\ncargo +nightly bootimage",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#how-does-it-work",
    "href": "41_boot.html#how-does-it-work",
    "title": "Boot",
    "section": "How does it work?",
    "text": "How does it work?\nThe bootimage tool performs the following steps behind the scenes:\n\nIt compiles our kernel to an ELF file.\nIt compiles the bootloader dependency as a standalone executable.\nIt links the bytes of the kernel ELF file to the bootloader.\n\nRead about the rust-osdev/bootloader",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#on-boot",
    "href": "41_boot.html#on-boot",
    "title": "Boot",
    "section": "On Boot",
    "text": "On Boot\n\nWhen booted, the bootloader reads and parses the appended ELF file.\nIt then maps the program segments to virtual addresses.\nZeroes the .bss section, and sets up a stack.\n\n.bss holds static variables.\nLike static mut BUS from the Malloc assignment.\n\nIt reads the entry point address (_start).\nIt “jumps” to _start and begins executing the code there.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#booting-it-in-qemu",
    "href": "41_boot.html#booting-it-in-qemu",
    "title": "Boot",
    "section": "Booting it in QEMU",
    "text": "Booting it in QEMU\n\nWe can now boot the disk image in a virtual machine.\nTo boot it in qemu, execute the following command:\n\nqemu-system-x86_64 -drive format=raw,file=target/x86_64-osirs/debug/bootimage-osirs.bin\n\nNaturally this won’t work if you have other names for your files, but hopefully you get the gist.\nThis opens a separate window “QEMU” window and currently display nothing.\n\nWe want to continue to open this graphics window so we have somewhere to look at text when we finally get it to work!",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#real-machine",
    "href": "41_boot.html#real-machine",
    "title": "Boot",
    "section": "Real Machine",
    "text": "Real Machine\n\n\n\n\n\n\nDon’t do this\n\n\n\nDon’t do this.\n\n\n\nIt is also possible to write it to a USB stick and boot it on a real machine, but be careful to choose the correct device name, because everything on that device is overwritten:\n\ndd if=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX && sync\n\nWhere sdX is the device name of your USB stick.\nAfter writing the image to the USB stick, you can run it on real hardware by booting from it.\nYou probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick.\nNote that it currently doesn’t work for UEFI machines, since the bootloader crate has no UEFI support yet.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#using-cargo-run",
    "href": "41_boot.html#using-cargo-run",
    "title": "Boot",
    "section": "Using cargo run",
    "text": "Using cargo run\nTo make it easier to run our kernel in QEMU, we can set the runner configuration key for cargo:\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"\n\n[target.'cfg(target_os = \"none\")']\nrunner = \"bootimage runner\"\n\n\ntarget.'cfg(target_os = \"none\")' matches any case where \"os\" is \"none\".\n\nLike our custom target.\n\nThe runner key specifies the command that should be invoked for cargo run.\nThe command is run after a successful build with the executable path passed as the first argument.",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#runners",
    "href": "41_boot.html#runners",
    "title": "Boot",
    "section": "Runners",
    "text": "Runners\n\nThe bootimage runner command is specifically designed to be usable as a runner executable.\nIt links the given executable with the project’s bootloader dependency and then launches QEMU.\nSee the Readme of bootimage for more details and possible configuration options.\nNow we can use cargo run to compile our kernel and boot it in QEMU!",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "41_boot.html#footnotes",
    "href": "41_boot.html#footnotes",
    "title": "Boot",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis would be cool and fun and we should do it sometime, we just have other things to do!↩︎",
    "crumbs": [
      "Boot"
    ]
  },
  {
    "objectID": "32_r5.html",
    "href": "32_r5.html",
    "title": "RISC-V",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#homework",
    "href": "32_r5.html#homework",
    "title": "RISC-V",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#requirements",
    "href": "32_r5.html#requirements",
    "title": "RISC-V",
    "section": "Requirements",
    "text": "Requirements\n\n371rs/32 crate; I named mine “osirs”\nUse the src/main.rs from the linker lab.\nRun on emulated RISC-V in QEMU.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#code",
    "href": "32_r5.html#code",
    "title": "RISC-V",
    "section": "Code",
    "text": "Code\n\n\n\n\n\n\nDon’t be like me\n\n\n\nLoops are more stable than recursion I guess.\n\n\n\n\nsrc/main.rs\n\n#![no_main]\n#![no_std]\n\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#other-stuff",
    "href": "32_r5.html#other-stuff",
    "title": "RISC-V",
    "section": "Other stuff",
    "text": "Other stuff\n\nI graciously borrrowed some code from this repository.\nhelloworld_in_riscv_and_rust_baremetal\n\ngit clone https://github.com/Alignof/helloworld_in_riscv_and_rust_baremetal.git\n\nJust kidding don’t use that, use this instead.\n\ngit clone https://github.com/cd-rs/hwr5.git\n\nI made a cool version.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#the-working-parts",
    "href": "32_r5.html#the-working-parts",
    "title": "RISC-V",
    "section": "The working parts",
    "text": "The working parts\n$ tree\n.\n├── Cargo.lock\n├── Cargo.toml\n├── link.x\n├── memory.x\n└── src\n    └── main.rs\n\n1 directory, 5 files\n\nSome of this shouldn’t be new to you.\n\nCargo.lock\nCargo.toml\nsrc/main.rs\n\nSome should:\n\nlink.x\nmemory.x",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#the-internals",
    "href": "32_r5.html#the-internals",
    "title": "RISC-V",
    "section": "The internals",
    "text": "The internals\n\nWithout dwelling on the details, these .x files are for the linker\n\nRemember our good friend the linker.\nlink.x was written by someone that understands linkers.\nmemory.x was written by a script from a crate written by someone that understands linkers.\n\nFrom our perspective, they “just work”\n\nBut how?",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#starting-point",
    "href": "32_r5.html#starting-point",
    "title": "RISC-V",
    "section": "Starting Point",
    "text": "Starting Point\n\nAt first, probably nothing works.\n\nOr at least, cargo b doesn’t work.\n\n\n$ cargo b\n   Compiling osirs v0.1.0 (/home/user/tmp/hwr5)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustcwuxfha/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustcwuxfha/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/hwr5/target/debug/deps/osirs-80f8eb3240ba748e\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: /home/user/tmp/hwr5/target/debug/deps/osirs-80f8eb3240ba748e.9chdw59nqscmfe0ef1hrxy2nb.rcgu.o: in function `_start':\n          /home/user/tmp/hwr5/src/main.rs:7: multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':\n          (.text+0x1b): undefined reference to `main'\n          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'\n          collect2: error: ld returned 1 exit status\n\n  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n  = note: use the `-l` flag to specify native libraries to link\n  = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib)\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#rustc",
    "href": "32_r5.html#rustc",
    "title": "RISC-V",
    "section": "rustc",
    "text": "rustc\n\nI found it easier to get to work with rustc\n\nCargo hater Calvin\n\nRecall a way we ran the executable in the lab.\n\ncargo rustc -- -C link-arg=-nostartfiles\n\nWe can just go straight to rustc\n\nrust -C link-arg=-nostartfiles\n\nOnly one catch.\n\nWell, two.\nWe want to link files.\nSpecifically, the .x files.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#naively",
    "href": "32_r5.html#naively",
    "title": "RISC-V",
    "section": "Naively",
    "text": "Naively\n\nYou can give rustc a shot straight-away.\n\n$ rustc src/main.rs\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: aborting due to 1 previous error\n\nWe recall we “fixed” the problem with panics by modifying Cargo.toml.\nrustc doesn’t care about your Cargo.toml!\nWe instead have to specify an argument to rustc.\nWe do so similarly to the link-arg, with the -C flag.\n\nWe furnish basically the same thing we placed in Cargo.toml.\n\n\nrustc src/main.rs -C panic=abort\n\nGet this working and see if you can get the following error message:\n\n$ rustc src/main.rs -C panic=abort\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustceBlIYK/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustceBlIYK/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"main\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: main.main.5f6bf0c8e9d0afce-cgu.0.rcgu.o: in function `_start':\n          main.5f6bf0c8e9d0afce-cgu.0:(.text._start+0x0): multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':\n          (.text+0x1b): undefined reference to `main'\n          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'\n          collect2: error: ld returned 1 exit status\n\n  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n  = note: use the `-l` flag to specify native libraries to link\n\nerror: aborting due to 1 previous error\n\nAh hah! A linker error! Just as we hoped.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#t",
    "href": "32_r5.html#t",
    "title": "RISC-V",
    "section": "-T",
    "text": "-T\n\nThe linker complains it’s missing something, and it’s not sure what.\nWe are sure, it’s the .x files.\nTo furnish a file by name to the linker, we provide it as a link-arg prefixed with -T\n\nlink-arg=-Tlink.x\n\n\n\n\n\n\nMacOS Users!\n\n\n\nThis will not work on MacOS, to our knowledge.\nHere is a guide to follow that should work: MacOS\n\n\n\nIf you link both .x files, you will get a different error message.\n\n$ rustc -C link-args=-Tmemory.x -C link-args=-Tlink.x -C panic=abort src/main.rs\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustczhisJl/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustczhisJl/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"main\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\" \"-Tmemory.x\" \"-Tlink.x\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: main.main.5f6bf0c8e9d0afce-cgu.0.rcgu.o: in function `_start':\n          main.5f6bf0c8e9d0afce-cgu.0:(.text._start+0x0): multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld:\n          .got section detected in the input files. Dynamic relocations are not\n          supported. If you are linking to C code compiled using the `gcc` crate\n          then modify your build script to compile the C code _without_ the\n          -fPIC flag. See the documentation of the `gcc::Config.fpic` method for\n          details.\n          /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o: in function `_init':\n          (.init+0xb): relocation truncated to fit: R_X86_64_REX_GOTPCRELX against undefined symbol `__gmon_start__'\n          collect2: error: ld returned 1 exit status\n\n\nerror: aborting due to 1 previous error",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#risc-v",
    "href": "32_r5.html#risc-v",
    "title": "RISC-V",
    "section": "RISC-V",
    "text": "RISC-V\n\nRISC-V is what it would be like if hardware were good.\n\nBy which I mean open-source.\n\n\n\n\n\n\nGood (Open Source)\nBad (Not)\n\n\n\n\nWindows\n\nx\n\n\nLinux\nx\n\n\n\nICC (Intel C Compiler)\n\nx\n\n\nGCC\nx\n\n\n\nx86-64\n\nx\n\n\nARM64\n\nx\n\n\nRISC-V\nx\n\n\n\n\n\nRISC-V (pronounced “risk-five”): 1  is a free and open standard instruction set architecture (ISA) based on reduced instruction set computer (RISC) principles. Unlike proprietary ISAs such as x86 and ARM, RISC-V is described as “free and open” because its specifications are released under permissive open-source licenses and can be implemented without paying royalties.\n\n\nThe RISC-V instruction set architecture (ISA) offers a highly customizable open standard platform, enabling developers to build, port, and optimize software applications, extensions, and hardware. Its simplicity and modularity enables efficient design and optimization, fostering innovation and reducing development time and cost.\n\n\nAlso unlike x86 and ARM, it is easy to develop for RISC-V, and that is what we’ve done.\n\n$ grep riscv link.x\n  By default uses the riscv crates default trap handler\nERROR(riscv-rt): the start of the REGION_TEXT must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_RODATA must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_DATA must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_HEAP must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_TEXT must be 4-byte aligned\");\nERROR(riscv-rt): the start of the REGION_STACK must be 4-byte aligned\");\nERROR(riscv-rt): `_stext` must be 4-byte aligned\");\nBUG(riscv-rt): .data is not 4-byte aligned\");\nBUG(riscv-rt): the LMA of .data is not 4-byte aligned\");\nBUG(riscv-rt): .bss is not 4-byte aligned\");\nBUG(riscv-rt): start of .heap is not 4-byte aligned\");\nERROR(riscv-rt): The .text section must be placed inside the REGION_TEXT region.\nERROR(riscv-rt): .stack section is too small for allocating stacks for all the harts.\n\nBy golly, our .x files are for RISC-V!\n\nAnd therefore good.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#target",
    "href": "32_r5.html#target",
    "title": "RISC-V",
    "section": "Target",
    "text": "Target\n\nWe recall the notion of a target triple\n\nFrom the linker lab\n\nWe note:\n\nThere are references to x86 (in my case) in the error logs.\nThere are references to RISC-V in the linker files.\nWe have to pick one, and…\nI didn’t provide appropriate linker files for x86\n\nBecause it’s bad!\n\n\nYou will additionlly need to specify a target.\nriscv64imac-unknown-none-elf\nYou will figure it out.\n\nAnd you will know when you have, because you will see no errors and a main will have appeared.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#main",
    "href": "32_r5.html#main",
    "title": "RISC-V",
    "section": "Main",
    "text": "Main\n\nGo ahead and run main, what could go wrong.\n\n$ ./main\n-bash: ./main: cannot execute binary file: Exec format error\n\nIf, like me, you foolish use an architecture other than RISC-V as your daily driver (that’s a metaphor, not a reference to device drivers), main won’t work on your system.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#qemu",
    "href": "32_r5.html#qemu",
    "title": "RISC-V",
    "section": "QEMU",
    "text": "QEMU\n\nWell, it will, you just have to bamboozle your system into pretending to be a good system, like RISC-V\n\nsudo apt install qemu-system-misc\n\nWe don’t allow our feelings to be hurt by RISC-V being described as “miscellaneous”.\n\nI didn’t properly sandbox my system before debugging so I think this is all you need but I may be wrong if I lost a dependency somewhere.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#run-qemu",
    "href": "32_r5.html#run-qemu",
    "title": "RISC-V",
    "section": "Run QEMU",
    "text": "Run QEMU\n\nYou can simply launch qemu with no strings attached.\n\n\u0016qemu-system-riscv64\n\nFor me this popped open a new window.\n\nThis is good, as otherwise you have to deal with processes and I don’t have time to teach that.\nIf you type “quit” after the prompt of (qemu) it should close.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#run-main",
    "href": "32_r5.html#run-main",
    "title": "RISC-V",
    "section": "Run main",
    "text": "Run main\n\nYou can specify that you totally wrote a working OS, honest, by providing qemu with a specified kernel, like our main\n\n\u0016qemu-system-riscv64 -kernel main\n\n\n\n\n\n\nForward Pointer\n\n\n\nWe will properly introduce kernels in the next lecture.\n\n\n\nThis will probably work.\n\n$ qemu-system-riscv64 -kernel main\nqemu-system-riscv64: Some ROM regions are overlapping\nThese ROM regions might have been loaded by direct user request or by default.\nThey could be BIOS/firmware images, a guest kernel, initrd or some other file loaded into guest memory.\nCheck whether you intended to load all this guest code, and whether it has been built to load to the correct addresses.\n\nThe following two regions overlap (in the memory address space):\n  /usr/share/qemu/opensbi-riscv64-generic-fw_dynamic.elf ELF program header segment 1 (addresses 0x0000000080000000 - 0x0000000080016ce8)\n  main ELF program header segment 0 (addresses 0x0000000080000000 - 0x0000000080000004)\n\nAnd by probably I mean with a probability of zero.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#bios",
    "href": "32_r5.html#bios",
    "title": "RISC-V",
    "section": "BIOS",
    "text": "BIOS\n\n\n\n\n\n\nForward Pointer\n\n\n\nWe will properly introduce the BIOS in the next lecture.\n\n\n\nThe BIOS can be thought of as a tiny bit of read-only memory (ROM) that lives on a computer.\nWhen the computer first turns on, it immediately begins reading instructions from the BIOS (presumably over the bus, or through some other means).\nThe BIOS will then instruct the device how to procede.\nWe don’t need any of that, we already wrote an infinite loop and can just start there!\n\n\u0016qemu-system-riscv64 -kernel main -bios none\n\nIn computing, BIOS (Basic Input/Output System, also known as the System BIOS, ROM BIOS, BIOS ROM or PC BIOS) is a type of firmware used to provide runtime services for operating systems and programs and to perform hardware initialization during the booting process (power-on startup). On a computer using BIOS firmware, the firmware comes pre-installed on the computer’s motherboard.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#machine",
    "href": "32_r5.html#machine",
    "title": "RISC-V",
    "section": "Machine",
    "text": "Machine\n\nYou may get an error not unlike this one:\n\n$ qemu-system-riscv64 -bios none -kernel main\nqemu-system-riscv64: Invalid HTIF fromhost or tohost address\n\nYou also may not get this error.\nIt is caused by not telling QEMU which specific, physical machine to pretend to be.\nI recommend sifive_u, which I believe is the most popular physical chip for developmental purposes.\n\nqemu-system-riscv64 -machine sifive_u -bios none -kernel main",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "32_r5.html#todo",
    "href": "32_r5.html#todo",
    "title": "RISC-V",
    "section": "TODO",
    "text": "TODO\nFor this homework, add a README.md to the crate describing how to get it to work.\n\nIt should be like this document, but concise.\nUse cool markdown checkboxes.\n\n- [ ] Do a thing.\n- [ ] Do another thing.",
    "crumbs": [
      "RISC-V"
    ]
  },
  {
    "objectID": "30_metal.html",
    "href": "30_metal.html",
    "title": "Bare Metal",
    "section": "",
    "text": "Action Items:\n\nmalloc stands eternal\n\nPossibly the coolest assignment ever\nI’m glad you all love it\n\nHomework this week is more complicated but also more supported.\n\nPrioritize malloc I think.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#announcements",
    "href": "30_metal.html#announcements",
    "title": "Bare Metal",
    "section": "",
    "text": "Action Items:\n\nmalloc stands eternal\n\nPossibly the coolest assignment ever\nI’m glad you all love it\n\nHomework this week is more complicated but also more supported.\n\nPrioritize malloc I think.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#today",
    "href": "30_metal.html#today",
    "title": "Bare Metal",
    "section": "Today",
    "text": "Today\n\nBare metal\n\nBare metal\nRanting about how cool this is\nSimulation\nEmulation\n\nA bare metal binary\n\nRuntimes\nstd",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#citations",
    "href": "30_metal.html#citations",
    "title": "Bare Metal",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nWelcome to Bare Metal Rust\nA Freestanding Rust Binary",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#throwback-thmonday",
    "href": "30_metal.html#throwback-thmonday",
    "title": "Bare Metal",
    "section": "Throwback ThMonday",
    "text": "Throwback ThMonday\n\nI did this in grad school.\n\nRTL Simulation of C-Program on Bare-metal OR1200\n\nMy researcher (Juni) did this in ’22\n\nBare-Metal Programs on RISC-V\n\nI did this… last week.\n\nSlides including bare-metal execution in Verilog",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#bare-metal",
    "href": "30_metal.html#bare-metal",
    "title": "Bare Metal",
    "section": "Bare Metal",
    "text": "Bare Metal\n\nA computer which has no operating system. The software executed by a bare machine, commonly called a “bare metal program” or “bare metal application”, is designed to interact directly with hardware. Bare machines are widely used in embedded systems, particularly in cases where resources are limited or high performance is required.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#some-terms",
    "href": "30_metal.html#some-terms",
    "title": "Bare Metal",
    "section": "Some Terms",
    "text": "Some Terms\n\nShould introduce a few terms.\n\nNot required for OS but useful to know.\n\nTerms\n\nSimulation\nEmulation\nCross-compilation\nQEMU",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#simulation",
    "href": "30_metal.html#simulation",
    "title": "Bare Metal",
    "section": "Simulation",
    "text": "Simulation\n\nModels a system’s behavior\nFocuses on high-level results, not internal logic\n“Close enough” for performance or logic testing\nSimulating hardware components in software\nFaster but less precise",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#emulation",
    "href": "30_metal.html#emulation",
    "title": "Bare Metal",
    "section": "Emulation",
    "text": "Emulation\n\nReplicating exact internal behavior of hardware\nSoftware acting as hardware (CPU, registers, memory)\nAccuracy vs. Speed:\n\nMuch slower than simulation… unless?\nGoal: Guest software doesn’t know it’s not on actual silicon",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#example",
    "href": "30_metal.html#example",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nx86-64 - the Intel/AMD architecture common for Linux and Windows - supports a “long double” float with 80 bits of precision.\nARM64 - a competing formulation most popularized as “Apple silicon” with the M1 - lacks long doubles.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#context",
    "href": "30_metal.html#context",
    "title": "Bare Metal",
    "section": "Context",
    "text": "Context\n\nIt is trivial to implement a float in software…\n\nf16\n\nIt is relatively not-trivial to implement an architecture in software, though possible.\n\nHere’s the smallest example I know:\nPicoRV32",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#cross-compiling",
    "href": "30_metal.html#cross-compiling",
    "title": "Bare Metal",
    "section": "Cross-Compiling",
    "text": "Cross-Compiling\n\nExample:” compiling code on an x86 laptop for an ARM chip\n\nCommon in embedded applications (e.g. program a thermostat)\n\nCompiler runs on Host A, produces binary for Target B\n\nEssential for “bare metal” development\nTransmit the binary over wires (the bus!) to another device’s memory.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#considerations",
    "href": "30_metal.html#considerations",
    "title": "Bare Metal",
    "section": "Considerations",
    "text": "Considerations\n\nWe must:\n\nTarget a specific architecture\nLink against specific hardware memory maps\n\nSomehow you also need the actual hardware, unless…",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#qemu",
    "href": "30_metal.html#qemu",
    "title": "Bare Metal",
    "section": "QEMU",
    "text": "QEMU\n\nI used this a lot in grad school; less now.\n\nSupports both emulation and virtualization\n\nVirtualization emulates a device rather than a binary.\nUsed in cloud; can be fast; huge research area.\n\n\nLet’s us run bare metal binaries without physical chips (which would cost $)\nWrite locally \\(\\rightarrow\\) Cross-compile \\(\\rightarrow\\) Run in QEMU",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#first-steps",
    "href": "30_metal.html#first-steps",
    "title": "Bare Metal",
    "section": "First Steps",
    "text": "First Steps\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library.\nThis makes it possible to run Rust code on the “bare metal” without an underlying operating system.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#introduction",
    "href": "30_metal.html#introduction",
    "title": "Bare Metal",
    "section": "Introduction",
    "text": "Introduction\n\nTo write an operating system kernel, we need code that does not depend on any operating system features.\nThis means that we can’t use files, the heap, networks, random numbers, standard output, etc.\nWe’re trying to write our own OS!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#on-std",
    "href": "30_metal.html#on-std",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWe can’t use most of the Rust standard library, but…\n…there are a lot of Rust features that we can use.\nFor example, we can use iterators, closures, pattern matching, option and result\n\nRecall the official Calvin Deutschbein position on option and result:\n“It’s why Rust is good.” - me",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#on-std-1",
    "href": "30_metal.html#on-std-1",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWhile not initially helpful, we can use string formatting, and…\n… the ownership system.\n\nBeats malloc!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#quoth-the-blog",
    "href": "30_metal.html#quoth-the-blog",
    "title": "Bare Metal",
    "section": "Quoth The Blog",
    "text": "Quoth The Blog\n\nThese features make it possible to write a kernel in a very expressive, high level way without worrying about undefined behavior or memory safety.\n\n\nWell, we’ll see.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#we-keep",
    "href": "30_metal.html#we-keep",
    "title": "Bare Metal",
    "section": "We keep",
    "text": "We keep\n\noption\nresult\nRust standard library\niterators\nclosures\npattern matching\nstring formatting\nownership system\nundefined behavior\nmemory safety",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#onward",
    "href": "30_metal.html#onward",
    "title": "Bare Metal",
    "section": "Onward!",
    "text": "Onward!\n\nWe now enumerate the necessary steps to create a freestanding Rust binary…\n…and explains why the steps are needed.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#no_std",
    "href": "30_metal.html#no_std",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nBy default, all Rust crates link the standard library.\n\nIt depends on the operating system for features such as threads, files, or networking.\nIt also depends on the C standard library libc, which closely interacts with OS services.\n\nThat is, part of GNU but not part of Linux.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#no_std-1",
    "href": "30_metal.html#no_std-1",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nSince our plan is to write an operating system, we can’t use any OS-dependent libraries.\n\nThat would be recursive, which is only good sometimes!\n\nSo we have to disable the automatic inclusion of the standard library through the no_std attribute.\n\nstandard library\nno_std attribute",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#to-begin",
    "href": "30_metal.html#to-begin",
    "title": "Bare Metal",
    "section": "To begin",
    "text": "To begin\n\nWe can start creation the same way we make anything else in Rust…\nCargo (sighs heavily)\n\ncargo new ????",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#example-1",
    "href": "30_metal.html#example-1",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nPersonally, I would expect you to maintain different OS versions with same crate name but within distinctly named directories (32,42 etc.)\n\ncargo new 32 --name osirs --vcs none",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#branches",
    "href": "30_metal.html#branches",
    "title": "Bare Metal",
    "section": "Branches",
    "text": "Branches\n\nA competing formulation would be to use git branch to create different developmental branches.\nThis is the industry standard and I wanted to introduce it but felt a time crunch.\nIf you are looking for something to do, figure it out.\n\nDon’t worry about me finding things; its worth it to me for you to learn.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#name",
    "href": "30_metal.html#name",
    "title": "Bare Metal",
    "section": "Name",
    "text": "Name\n\n\n\nYou don’t have to name your OS anything in particular, I just thought osirs (OS in Rust) sounded heckin’ rad.\nʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\nAlso a cringe AI real estate firm!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#refresh",
    "href": "30_metal.html#refresh",
    "title": "Bare Metal",
    "section": "Refresh",
    "text": "Refresh\n\nWhen we run the command, cargo creates the following directory structure for us:\n\n$ tree\n.\n├── Cargo.toml\n└── src\n    └── main.rs\n\n1 directory, 2 files",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#recall",
    "href": "30_metal.html#recall",
    "title": "Bare Metal",
    "section": "Recall",
    "text": "Recall\n\nCargo.toml contains the crate configuration\n\nCrate name\nCrate author\nCrate version\n\nsrc/main.rs file contains our main function.\nAfter cargo build, find the compiled osirs binary in the target/debug subfolder.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#blah-blah-blah",
    "href": "30_metal.html#blah-blah-blah",
    "title": "Bare Metal",
    "section": "Blah blah blah",
    "text": "Blah blah blah\n\u0016$ cargo build ; tree\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n.\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── main.rs\n└── target\n    ├── CACHEDIR.TAG\n    └── debug\n        ├── build\n        ├── deps\n        │   ├── osirs-43412975b38d059d\n        │   └── osirs-43412975b38d059d.d\n        ├── examples\n        ├── incremental\n        │   └── osirs-3gae52yq1943v\n        │       ├── s-hfeunnoewq-0c8luu5-5dmhke08rl6h5l09ku3va3gkx\n        │       │   ├── 1tq3ts5gahvv7j1hzrmfdrzi6.o\n        │       │   ├── 6zk3flo890c0qhh6fykb6746g.o\n        │       │   ├── 8z45o15v3gxm5hydv3o63x07l.o\n        │       │   ├── 9itjtn00r7d8c6mknmav20oex.o\n        │       │   ├── bh9pj42wzikjd1ilqutnjbrx7.o\n        │       │   ├── dep-graph.bin\n        │       │   ├── eymyqxruzdb24suchgzd8ygxb.o\n        │       │   ├── query-cache.bin\n        │       │   └── work-products.bin\n        │       └── s-hfeunnoewq-0c8luu5.lock\n        ├── osirs\n        └── osirs.d\n\n9 directories, 18 files",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#running",
    "href": "30_metal.html#running",
    "title": "Bare Metal",
    "section": "Running",
    "text": "Running\n\nTechnically no one can stop you from using cargo run or even cargo run --release\nBut you can also just build and then directly run the executable.\n\n\u0016\u0016$ ./target/debug/osirs\nHello, world!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#the-no_std-attribute",
    "href": "30_metal.html#the-no_std-attribute",
    "title": "Bare Metal",
    "section": "The no_std Attribute",
    "text": "The no_std Attribute\n\nInitially, the crate implicitly links the standard library.\nWe can prepend the no_std attribute to src/main.rs to get the version of Rust that builds character!\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n}",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#we-can-rebuild",
    "href": "30_metal.html#we-can-rebuild",
    "title": "Bare Metal",
    "section": "We Can Rebuild",
    "text": "We Can Rebuild\n\nActually we can’t.\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n  |     ^^^^^^^\n\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 3 previous errors    ^^^^^^^",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#enhance",
    "href": "30_metal.html#enhance",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n  |     ^^^^^^^\n\nOh right, we can’t print without an OS.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#background",
    "href": "30_metal.html#background",
    "title": "Bare Metal",
    "section": "Background",
    "text": "Background\n\nThe println macro is part of the standard library std.\nWe said no_std.\nSo we can no longer print things.\nI hope it is clear how this is character-building!\nRead more:\n\nprintln macro\nstandard output",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#rip-it",
    "href": "30_metal.html#rip-it",
    "title": "Bare Metal",
    "section": "Rip it",
    "text": "Rip it\n\nRemove the printing and try again:\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    // println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n}",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#problems-remain",
    "href": "30_metal.html#problems-remain",
    "title": "Bare Metal",
    "section": "Problems remain",
    "text": "Problems remain\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 2 previous errors",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#enhance-1",
    "href": "30_metal.html#enhance-1",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n  |     ^^^^^^^\n\nSometimes, Rust explodes and calls the OS (written in C!) for help.\nIt can’t do that without std and is sad 😭",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panic",
    "href": "30_metal.html#panic",
    "title": "Bare Metal",
    "section": "Panic",
    "text": "Panic\n\nThe panic_handler attribute defines the function that the compiler should invoke when a panic occurs.\nstd provides its own panic handler function, but in a no_std environment we need to define it ourselves:\npanic",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#our-approach",
    "href": "30_metal.html#our-approach",
    "title": "Bare Metal",
    "section": "Our Approach",
    "text": "Our Approach\n\n\nsrc/main.rs\n\n// main.rs\n\n/// This function is called on panic.\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panics",
    "href": "30_metal.html#panics",
    "title": "Bare Metal",
    "section": "Panics",
    "text": "Panics\n\nThe PanicInfo parameter contains:\n\nfile and line where the panic happened\npanic message (e.g. panic!(\"YOLO\")\n\nThe function should never return.\n\nSo it is marked as a “diverging function”\nIt returns the “never” type !.\n\nNot much we can do in this function for now, so just recurse to prevent a return.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#read-more",
    "href": "30_metal.html#read-more",
    "title": "Bare Metal",
    "section": "Read more…",
    "text": "Read more…\n\nI had never heard of or used these but to me it was clear why they would have to exist in a type safe language.\n\nPanicInfo\ndiverging function\n“never” type",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#retry",
    "href": "30_metal.html#retry",
    "title": "Bare Metal",
    "section": "Retry",
    "text": "Retry\n\nI bet it works now!\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nThey should make a version of the OS class that is easy.\n\n(They did - this class)",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panic-abort",
    "href": "30_metal.html#panic-abort",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\n\n\nFun fact - back when I was an OS engineer slash rocket scientist my first launch was “PA-1” for “Pad Abort 1”\n\nBlew up a rocket on the launch pad to make sure it was safe for humans.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#panic-abort-1",
    "href": "30_metal.html#panic-abort-1",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\nThe use of the term “abort” which in some nation-states is a hot-button political issue has come up from time-to-time in the discourse.\nRead more from 2018\n\n\n25.7.4 Aborting a Program\n\n...\n\nFuture Change Warning: Proposed Federal censorship regulations may prohibit us from giving you information about the possibility of calling this function. We would be required to say that this is not an acceptable way of terminating a program.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#quoth-stallman",
    "href": "30_metal.html#quoth-stallman",
    "title": "Bare Metal",
    "section": "Quoth Stallman",
    "text": "Quoth Stallman\n\n“The point of this joke is even more important now than it was when I first wrote it,” [Free Software Foundation president] Stallman wrote in a note posted to project mailing list, in reference to today’s political climate. “Please do not remove it. GNU is not a purely technical project, so the fact that this is not strictly and grimly technical is not a reason to remove this.”",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#now-in-rust",
    "href": "30_metal.html#now-in-rust",
    "title": "Bare Metal",
    "section": "Now in Rust",
    "text": "Now in Rust\n\nWe can oppose fascism and\n\n(looks into the history of NASA and Lockheed Martin)\n(clears throat)\nMoving on!\n\n\nWe can abort programs… in Rust",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#how",
    "href": "30_metal.html#how",
    "title": "Bare Metal",
    "section": "How?",
    "text": "How?\n\nRead carefully:\n\n= help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n= note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nGeniuses will recognize panic=\"abort\" syntax",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#toml",
    "href": "30_metal.html#toml",
    "title": "Bare Metal",
    "section": "TOML",
    "text": "TOML\n\nIt’s .toml\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#crate-options",
    "href": "30_metal.html#crate-options",
    "title": "Bare Metal",
    "section": "Crate options",
    "text": "Crate options\n\nNominally there are use cases for which unwinding is undesirable\n\nMy take: All cases.\n\nSo Rust provides an option to “abort on panic” instead.\nOur reference materials claims this disables the generation of unwinding symbol information and thus considerably reduces binary size.\n\nI could not verify this independently.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#update-cargo.toml",
    "href": "30_metal.html#update-cargo.toml",
    "title": "Bare Metal",
    "section": "Update Cargo.toml",
    "text": "Update Cargo.toml\n\nAdd the following:\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#now",
    "href": "30_metal.html#now",
    "title": "Bare Metal",
    "section": "Now…",
    "text": "Now…\n\nThis sets the panic strategy to abort for both the dev profile (used for cargo build) and the release profile (used for cargo build --release).\nabort on panic\nI bet it will work now.",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#whoops",
    "href": "30_metal.html#whoops",
    "title": "Bare Metal",
    "section": "Whoops!",
    "text": "Whoops!\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nWe don’t have and can’t use a main!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.html#to-be-continued",
    "href": "30_metal.html#to-be-continued",
    "title": "Bare Metal",
    "section": "To be continued",
    "text": "To be continued\n\nI am 99% sure we run out of time here…\nAnd will continue with the lab on linker errors!",
    "crumbs": [
      "Bare Metal"
    ]
  },
  {
    "objectID": "30_metal.rjs.html#announcements",
    "href": "30_metal.rjs.html#announcements",
    "title": "Bare Metal",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nmalloc stands eternal\n\nPossibly the coolest assignment ever\nI’m glad you all love it\n\nHomework this week is more complicated but also more supported.\n\nPrioritize malloc I think."
  },
  {
    "objectID": "30_metal.rjs.html#today",
    "href": "30_metal.rjs.html#today",
    "title": "Bare Metal",
    "section": "Today",
    "text": "Today\n\nBare metal\n\nBare metal\nRanting about how cool this is\nSimulation\nEmulation\n\nA bare metal binary\n\nRuntimes\nstd"
  },
  {
    "objectID": "30_metal.rjs.html#citations",
    "href": "30_metal.rjs.html#citations",
    "title": "Bare Metal",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nWelcome to Bare Metal Rust\nA Freestanding Rust Binary"
  },
  {
    "objectID": "30_metal.rjs.html#throwback-thmonday",
    "href": "30_metal.rjs.html#throwback-thmonday",
    "title": "Bare Metal",
    "section": "Throwback ThMonday",
    "text": "Throwback ThMonday\n\nI did this in grad school.\n\nRTL Simulation of C-Program on Bare-metal OR1200\n\nMy researcher (Juni) did this in ’22\n\nBare-Metal Programs on RISC-V\n\nI did this… last week.\n\nSlides including bare-metal execution in Verilog"
  },
  {
    "objectID": "30_metal.rjs.html#bare-metal",
    "href": "30_metal.rjs.html#bare-metal",
    "title": "Bare Metal",
    "section": "Bare Metal",
    "text": "Bare Metal\n\nA computer which has no operating system. The software executed by a bare machine, commonly called a “bare metal program” or “bare metal application”, is designed to interact directly with hardware. Bare machines are widely used in embedded systems, particularly in cases where resources are limited or high performance is required."
  },
  {
    "objectID": "30_metal.rjs.html#some-terms",
    "href": "30_metal.rjs.html#some-terms",
    "title": "Bare Metal",
    "section": "Some Terms",
    "text": "Some Terms\n\nShould introduce a few terms.\n\nNot required for OS but useful to know.\n\nTerms\n\nSimulation\nEmulation\nCross-compilation\nQEMU"
  },
  {
    "objectID": "30_metal.rjs.html#simulation",
    "href": "30_metal.rjs.html#simulation",
    "title": "Bare Metal",
    "section": "Simulation",
    "text": "Simulation\n\nModels a system’s behavior\nFocuses on high-level results, not internal logic\n“Close enough” for performance or logic testing\nSimulating hardware components in software\nFaster but less precise"
  },
  {
    "objectID": "30_metal.rjs.html#emulation",
    "href": "30_metal.rjs.html#emulation",
    "title": "Bare Metal",
    "section": "Emulation",
    "text": "Emulation\n\nReplicating exact internal behavior of hardware\nSoftware acting as hardware (CPU, registers, memory)\nAccuracy vs. Speed:\n\nMuch slower than simulation… unless?\nGoal: Guest software doesn’t know it’s not on actual silicon"
  },
  {
    "objectID": "30_metal.rjs.html#example",
    "href": "30_metal.rjs.html#example",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nx86-64 - the Intel/AMD architecture common for Linux and Windows - supports a “long double” float with 80 bits of precision.\nARM64 - a competing formulation most popularized as “Apple silicon” with the M1 - lacks long doubles."
  },
  {
    "objectID": "30_metal.rjs.html#context",
    "href": "30_metal.rjs.html#context",
    "title": "Bare Metal",
    "section": "Context",
    "text": "Context\n\nIt is trivial to implement a float in software…\n\nf16\n\nIt is relatively not-trivial to implement an architecture in software, though possible.\n\nHere’s the smallest example I know:\nPicoRV32"
  },
  {
    "objectID": "30_metal.rjs.html#cross-compiling",
    "href": "30_metal.rjs.html#cross-compiling",
    "title": "Bare Metal",
    "section": "Cross-Compiling",
    "text": "Cross-Compiling\n\nExample:” compiling code on an x86 laptop for an ARM chip\n\nCommon in embedded applications (e.g. program a thermostat)\n\nCompiler runs on Host A, produces binary for Target B\n\nEssential for “bare metal” development\nTransmit the binary over wires (the bus!) to another device’s memory."
  },
  {
    "objectID": "30_metal.rjs.html#considerations",
    "href": "30_metal.rjs.html#considerations",
    "title": "Bare Metal",
    "section": "Considerations",
    "text": "Considerations\n\nWe must:\n\nTarget a specific architecture\nLink against specific hardware memory maps\n\nSomehow you also need the actual hardware, unless…"
  },
  {
    "objectID": "30_metal.rjs.html#qemu",
    "href": "30_metal.rjs.html#qemu",
    "title": "Bare Metal",
    "section": "QEMU",
    "text": "QEMU\n\nI used this a lot in grad school; less now.\n\nSupports both emulation and virtualization\n\nVirtualization emulates a device rather than a binary.\nUsed in cloud; can be fast; huge research area.\n\n\nLet’s us run bare metal binaries without physical chips (which would cost $)\nWrite locally \\(\\rightarrow\\) Cross-compile \\(\\rightarrow\\) Run in QEMU"
  },
  {
    "objectID": "30_metal.rjs.html#first-steps",
    "href": "30_metal.rjs.html#first-steps",
    "title": "Bare Metal",
    "section": "First Steps",
    "text": "First Steps\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library.\nThis makes it possible to run Rust code on the “bare metal” without an underlying operating system."
  },
  {
    "objectID": "30_metal.rjs.html#introduction",
    "href": "30_metal.rjs.html#introduction",
    "title": "Bare Metal",
    "section": "Introduction",
    "text": "Introduction\n\nTo write an operating system kernel, we need code that does not depend on any operating system features.\nThis means that we can’t use files, the heap, networks, random numbers, standard output, etc.\nWe’re trying to write our own OS!"
  },
  {
    "objectID": "30_metal.rjs.html#on-std",
    "href": "30_metal.rjs.html#on-std",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWe can’t use most of the Rust standard library, but…\n…there are a lot of Rust features that we can use.\nFor example, we can use iterators, closures, pattern matching, option and result\n\nRecall the official Calvin Deutschbein position on option and result:\n“It’s why Rust is good.” - me"
  },
  {
    "objectID": "30_metal.rjs.html#on-std-1",
    "href": "30_metal.rjs.html#on-std-1",
    "title": "Bare Metal",
    "section": "On std",
    "text": "On std\n\nWhile not initially helpful, we can use string formatting, and…\n… the ownership system.\n\nBeats malloc!"
  },
  {
    "objectID": "30_metal.rjs.html#quoth-the-blog",
    "href": "30_metal.rjs.html#quoth-the-blog",
    "title": "Bare Metal",
    "section": "Quoth The Blog",
    "text": "Quoth The Blog\n\nThese features make it possible to write a kernel in a very expressive, high level way without worrying about undefined behavior or memory safety.\n\n\nWell, we’ll see."
  },
  {
    "objectID": "30_metal.rjs.html#we-keep",
    "href": "30_metal.rjs.html#we-keep",
    "title": "Bare Metal",
    "section": "We keep",
    "text": "We keep\n\noption\nresult\nRust standard library\niterators\nclosures\npattern matching\nstring formatting\nownership system\nundefined behavior\nmemory safety"
  },
  {
    "objectID": "30_metal.rjs.html#onward",
    "href": "30_metal.rjs.html#onward",
    "title": "Bare Metal",
    "section": "Onward!",
    "text": "Onward!\n\nWe now enumerate the necessary steps to create a freestanding Rust binary…\n…and explains why the steps are needed."
  },
  {
    "objectID": "30_metal.rjs.html#no_std",
    "href": "30_metal.rjs.html#no_std",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nBy default, all Rust crates link the standard library.\n\nIt depends on the operating system for features such as threads, files, or networking.\nIt also depends on the C standard library libc, which closely interacts with OS services.\n\nThat is, part of GNU but not part of Linux."
  },
  {
    "objectID": "30_metal.rjs.html#no_std-1",
    "href": "30_metal.rjs.html#no_std-1",
    "title": "Bare Metal",
    "section": "no_std",
    "text": "no_std\n\nSince our plan is to write an operating system, we can’t use any OS-dependent libraries.\n\nThat would be recursive, which is only good sometimes!\n\nSo we have to disable the automatic inclusion of the standard library through the no_std attribute.\n\nstandard library\nno_std attribute"
  },
  {
    "objectID": "30_metal.rjs.html#to-begin",
    "href": "30_metal.rjs.html#to-begin",
    "title": "Bare Metal",
    "section": "To begin",
    "text": "To begin\n\nWe can start creation the same way we make anything else in Rust…\nCargo (sighs heavily)\n\ncargo new ????"
  },
  {
    "objectID": "30_metal.rjs.html#example-1",
    "href": "30_metal.rjs.html#example-1",
    "title": "Bare Metal",
    "section": "Example",
    "text": "Example\n\nPersonally, I would expect you to maintain different OS versions with same crate name but within distinctly named directories (32,42 etc.)\n\ncargo new 32 --name osirs --vcs none"
  },
  {
    "objectID": "30_metal.rjs.html#branches",
    "href": "30_metal.rjs.html#branches",
    "title": "Bare Metal",
    "section": "Branches",
    "text": "Branches\n\nA competing formulation would be to use git branch to create different developmental branches.\nThis is the industry standard and I wanted to introduce it but felt a time crunch.\nIf you are looking for something to do, figure it out.\n\nDon’t worry about me finding things; its worth it to me for you to learn."
  },
  {
    "objectID": "30_metal.rjs.html#name",
    "href": "30_metal.rjs.html#name",
    "title": "Bare Metal",
    "section": "Name",
    "text": "Name\n\n\n\nYou don’t have to name your OS anything in particular, I just thought osirs (OS in Rust) sounded heckin’ rad.\nʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\nAlso a cringe AI real estate firm!"
  },
  {
    "objectID": "30_metal.rjs.html#refresh",
    "href": "30_metal.rjs.html#refresh",
    "title": "Bare Metal",
    "section": "Refresh",
    "text": "Refresh\n\nWhen we run the command, cargo creates the following directory structure for us:\n\n$ tree\n.\n├── Cargo.toml\n└── src\n    └── main.rs\n\n1 directory, 2 files"
  },
  {
    "objectID": "30_metal.rjs.html#recall",
    "href": "30_metal.rjs.html#recall",
    "title": "Bare Metal",
    "section": "Recall",
    "text": "Recall\n\nCargo.toml contains the crate configuration\n\nCrate name\nCrate author\nCrate version\n\nsrc/main.rs file contains our main function.\nAfter cargo build, find the compiled osirs binary in the target/debug subfolder."
  },
  {
    "objectID": "30_metal.rjs.html#blah-blah-blah",
    "href": "30_metal.rjs.html#blah-blah-blah",
    "title": "Bare Metal",
    "section": "Blah blah blah",
    "text": "Blah blah blah\n\u0016$ cargo build ; tree\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n.\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── main.rs\n└── target\n    ├── CACHEDIR.TAG\n    └── debug\n        ├── build\n        ├── deps\n        │   ├── osirs-43412975b38d059d\n        │   └── osirs-43412975b38d059d.d\n        ├── examples\n        ├── incremental\n        │   └── osirs-3gae52yq1943v\n        │       ├── s-hfeunnoewq-0c8luu5-5dmhke08rl6h5l09ku3va3gkx\n        │       │   ├── 1tq3ts5gahvv7j1hzrmfdrzi6.o\n        │       │   ├── 6zk3flo890c0qhh6fykb6746g.o\n        │       │   ├── 8z45o15v3gxm5hydv3o63x07l.o\n        │       │   ├── 9itjtn00r7d8c6mknmav20oex.o\n        │       │   ├── bh9pj42wzikjd1ilqutnjbrx7.o\n        │       │   ├── dep-graph.bin\n        │       │   ├── eymyqxruzdb24suchgzd8ygxb.o\n        │       │   ├── query-cache.bin\n        │       │   └── work-products.bin\n        │       └── s-hfeunnoewq-0c8luu5.lock\n        ├── osirs\n        └── osirs.d\n\n9 directories, 18 files"
  },
  {
    "objectID": "30_metal.rjs.html#running",
    "href": "30_metal.rjs.html#running",
    "title": "Bare Metal",
    "section": "Running",
    "text": "Running\n\nTechnically no one can stop you from using cargo run or even cargo run --release\nBut you can also just build and then directly run the executable.\n\n\u0016\u0016$ ./target/debug/osirs\nHello, world!"
  },
  {
    "objectID": "30_metal.rjs.html#the-no_std-attribute",
    "href": "30_metal.rjs.html#the-no_std-attribute",
    "title": "Bare Metal",
    "section": "The no_std Attribute",
    "text": "The no_std Attribute\n\nInitially, the crate implicitly links the standard library.\nWe can prepend the no_std attribute to src/main.rs to get the version of Rust that builds character!\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n}"
  },
  {
    "objectID": "30_metal.rjs.html#we-can-rebuild",
    "href": "30_metal.rjs.html#we-can-rebuild",
    "title": "Bare Metal",
    "section": "We Can Rebuild",
    "text": "We Can Rebuild\n\nActually we can’t.\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n  |     ^^^^^^^\n\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 3 previous errors    ^^^^^^^"
  },
  {
    "objectID": "30_metal.rjs.html#enhance",
    "href": "30_metal.rjs.html#enhance",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n  |     ^^^^^^^\n\nOh right, we can’t print without an OS."
  },
  {
    "objectID": "30_metal.rjs.html#background",
    "href": "30_metal.rjs.html#background",
    "title": "Bare Metal",
    "section": "Background",
    "text": "Background\n\nThe println macro is part of the standard library std.\nWe said no_std.\nSo we can no longer print things.\nI hope it is clear how this is character-building!\nRead more:\n\nprintln macro\nstandard output"
  },
  {
    "objectID": "30_metal.rjs.html#rip-it",
    "href": "30_metal.rjs.html#rip-it",
    "title": "Bare Metal",
    "section": "Rip it",
    "text": "Rip it\n\nRemove the printing and try again:\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n\nfn main() {\n    // println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n}"
  },
  {
    "objectID": "30_metal.rjs.html#problems-remain",
    "href": "30_metal.rjs.html#problems-remain",
    "title": "Bare Metal",
    "section": "Problems remain",
    "text": "Problems remain\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: `#[panic_handler]` function required, but not found\n\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 2 previous errors"
  },
  {
    "objectID": "30_metal.rjs.html#enhance-1",
    "href": "30_metal.rjs.html#enhance-1",
    "title": "Bare Metal",
    "section": "Enhance!",
    "text": "Enhance!\nerror: cannot find macro `println` in this scope\n --&gt; src/main.rs:6:5\n  |\n6 |     println!(\"ʙᴏᴡ ᴅᴏᴡɴ ʙᴇғᴏʀᴇ ᴛʜᴇ ɢᴏᴅ ᴏғ ᴅᴇᴀᴛʜ\");\n  |     ^^^^^^^\n\nSometimes, Rust explodes and calls the OS (written in C!) for help.\nIt can’t do that without std and is sad 😭"
  },
  {
    "objectID": "30_metal.rjs.html#panic",
    "href": "30_metal.rjs.html#panic",
    "title": "Bare Metal",
    "section": "Panic",
    "text": "Panic\n\nThe panic_handler attribute defines the function that the compiler should invoke when a panic occurs.\nstd provides its own panic handler function, but in a no_std environment we need to define it ourselves:\npanic"
  },
  {
    "objectID": "30_metal.rjs.html#our-approach",
    "href": "30_metal.rjs.html#our-approach",
    "title": "Bare Metal",
    "section": "Our Approach",
    "text": "Our Approach\n\n\nsrc/main.rs\n\n// main.rs\n\n/// This function is called on panic.\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}"
  },
  {
    "objectID": "30_metal.rjs.html#panics",
    "href": "30_metal.rjs.html#panics",
    "title": "Bare Metal",
    "section": "Panics",
    "text": "Panics\n\nThe PanicInfo parameter contains:\n\nfile and line where the panic happened\npanic message (e.g. panic!(\"YOLO\")\n\nThe function should never return.\n\nSo it is marked as a “diverging function”\nIt returns the “never” type !.\n\nNot much we can do in this function for now, so just recurse to prevent a return."
  },
  {
    "objectID": "30_metal.rjs.html#read-more",
    "href": "30_metal.rjs.html#read-more",
    "title": "Bare Metal",
    "section": "Read more…",
    "text": "Read more…\n\nI had never heard of or used these but to me it was clear why they would have to exist in a type safe language.\n\nPanicInfo\ndiverging function\n“never” type"
  },
  {
    "objectID": "30_metal.rjs.html#retry",
    "href": "30_metal.rjs.html#retry",
    "title": "Bare Metal",
    "section": "Retry",
    "text": "Retry\n\nI bet it works now!\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: unwinding panics are not supported without std\n  |\n  = help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n  = note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nThey should make a version of the OS class that is easy.\n\n(They did - this class)"
  },
  {
    "objectID": "30_metal.rjs.html#panic-abort",
    "href": "30_metal.rjs.html#panic-abort",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\n\n\nFun fact - back when I was an OS engineer slash rocket scientist my first launch was “PA-1” for “Pad Abort 1”\n\nBlew up a rocket on the launch pad to make sure it was safe for humans."
  },
  {
    "objectID": "30_metal.rjs.html#panic-abort-1",
    "href": "30_metal.rjs.html#panic-abort-1",
    "title": "Bare Metal",
    "section": "Panic abort",
    "text": "Panic abort\n\nThe use of the term “abort” which in some nation-states is a hot-button political issue has come up from time-to-time in the discourse.\nRead more from 2018\n\n\n25.7.4 Aborting a Program\n\n...\n\nFuture Change Warning: Proposed Federal censorship regulations may prohibit us from giving you information about the possibility of calling this function. We would be required to say that this is not an acceptable way of terminating a program."
  },
  {
    "objectID": "30_metal.rjs.html#quoth-stallman",
    "href": "30_metal.rjs.html#quoth-stallman",
    "title": "Bare Metal",
    "section": "Quoth Stallman",
    "text": "Quoth Stallman\n\n“The point of this joke is even more important now than it was when I first wrote it,” [Free Software Foundation president] Stallman wrote in a note posted to project mailing list, in reference to today’s political climate. “Please do not remove it. GNU is not a purely technical project, so the fact that this is not strictly and grimly technical is not a reason to remove this.”"
  },
  {
    "objectID": "30_metal.rjs.html#now-in-rust",
    "href": "30_metal.rjs.html#now-in-rust",
    "title": "Bare Metal",
    "section": "Now in Rust",
    "text": "Now in Rust\n\nWe can oppose fascism and\n\n(looks into the history of NASA and Lockheed Martin)\n(clears throat)\nMoving on!\n\n\nWe can abort programs… in Rust"
  },
  {
    "objectID": "30_metal.rjs.html#how",
    "href": "30_metal.rjs.html#how",
    "title": "Bare Metal",
    "section": "How?",
    "text": "How?\n\nRead carefully:\n\n= help: using nightly cargo, use -Zbuild-std with panic=\"abort\" to avoid unwinding\n= note: since the core library is usually precompiled with panic=\"unwind\", rebuilding your crate with panic=\"abort\" may not be enough to fix the problem\n\nGeniuses will recognize panic=\"abort\" syntax"
  },
  {
    "objectID": "30_metal.rjs.html#toml",
    "href": "30_metal.rjs.html#toml",
    "title": "Bare Metal",
    "section": "TOML",
    "text": "TOML\n\nIt’s .toml\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]"
  },
  {
    "objectID": "30_metal.rjs.html#crate-options",
    "href": "30_metal.rjs.html#crate-options",
    "title": "Bare Metal",
    "section": "Crate options",
    "text": "Crate options\n\nNominally there are use cases for which unwinding is undesirable\n\nMy take: All cases.\n\nSo Rust provides an option to “abort on panic” instead.\nOur reference materials claims this disables the generation of unwinding symbol information and thus considerably reduces binary size.\n\nI could not verify this independently."
  },
  {
    "objectID": "30_metal.rjs.html#update-cargo.toml",
    "href": "30_metal.rjs.html#update-cargo.toml",
    "title": "Bare Metal",
    "section": "Update Cargo.toml",
    "text": "Update Cargo.toml\n\nAdd the following:\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\""
  },
  {
    "objectID": "30_metal.rjs.html#now",
    "href": "30_metal.rjs.html#now",
    "title": "Bare Metal",
    "section": "Now…",
    "text": "Now…\n\nThis sets the panic strategy to abort for both the dev profile (used for cargo build) and the release profile (used for cargo build --release).\nabort on panic\nI bet it will work now."
  },
  {
    "objectID": "30_metal.rjs.html#whoops",
    "href": "30_metal.rjs.html#whoops",
    "title": "Bare Metal",
    "section": "Whoops!",
    "text": "Whoops!\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nWe don’t have and can’t use a main!"
  },
  {
    "objectID": "30_metal.rjs.html#to-be-continued",
    "href": "30_metal.rjs.html#to-be-continued",
    "title": "Bare Metal",
    "section": "To be continued",
    "text": "To be continued\n\nI am 99% sure we run out of time here…\nAnd will continue with the lab on linker errors!"
  },
  {
    "objectID": "21_xmute.html",
    "href": "21_xmute.html",
    "title": "Transmute",
    "section": "",
    "text": "Lab Day\n\nPlay with memory\nUse unsafe",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#announcements",
    "href": "21_xmute.html#announcements",
    "title": "Transmute",
    "section": "",
    "text": "Lab Day\n\nPlay with memory\nUse unsafe",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#homework",
    "href": "21_xmute.html#homework",
    "title": "Transmute",
    "section": "Homework",
    "text": "Homework\n\nmalloc is this lab just more complete\n\nCool, good, fun.\n\nDue Friday, 06 Feb. at 1440 ET.\n\nAnd also covered in section.",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#requirements",
    "href": "21_xmute.html#requirements",
    "title": "Transmute",
    "section": "Requirements",
    "text": "Requirements\n\nChange the interpretation of numeric values with transmute on values\nChange the interpretation of memory with transmute on references.\nWrite a “Hello world!” program that uses no string or character data.",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#crate",
    "href": "21_xmute.html#crate",
    "title": "Transmute",
    "section": "Crate",
    "text": "Crate\n\nTo complete the lab today, create a crate named helloworld in a folder named 21 in your 371os repository.\n\ncargo new 21 --name hello_world --vcs none",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "21_xmute.html#hello-world",
    "href": "21_xmute.html#hello-world",
    "title": "Transmute",
    "section": "“Hello world!”",
    "text": "“Hello world!”\n\nImplement “Hello world!” using this crate.\nUse i32 to store the “Hello world” data.\nWhile you do not have to develop it this way, the code could be a single line within an unsafe block containing only built-in function calls/declarations and i32 literals.\n\ncalvin@calvin:~/tmp/helloworld$ wc src/main.rs # 2 lines main, 2 lines unsafe, 1 line code\n  5  15 174 src/main.rs\ncalvin@calvin:~/tmp/helloworld$ grep world src/main.rs # no plaintext in file\ncalvin@calvin:~/tmp/helloworld$ cargo r --release\n   Compiling helloworld v0.1.0 (/home/calvin/tmp/oneone)\n    Finished `release` profile [optimized] target(s) in 0.14s\n     Running `target/release/helloworld`\nHello world!\n\nI love Python\n\nThe following may be useful here, to the interested student.\n\npython3 -c '[print(ord(a)) for a in \"Hello world!\"]'\n\nThis is probably insufficient for your purposes and will require some hacking.\n\n\n\nTransmute\n\nSince it is more idiomatic to use code other people have written in Rust…\n\nI have an opinion on this.\n\n…while it is possible to conduct this exercise using only raw pointers and casts…\n\n(in the voice of Palpatine) “Do it!”\n\n…it is my professional responsibility to recommend you use transmute.\n\npub const unsafe fn transmute&lt;Src, Dst&gt;(src: Src) -&gt; Dst\n\nRead more\n\n\n\nRaw Pointers\n\nAlso can use raw pointers here.\nWill get in the way of a single-line solution but that is okay - you should do you!\n\n\n\nNumeric Values\n\nOne obvious way to use transmute is to change one type of data into another, without altering the underlying numeric values that exist in memory.\nFor example, we can convert an array of u8s to an i32.\n\nunsafe {\n    let bytes: [u8;4] = [0x12,0x34,0x56,0x78];\n    let num: i32 = std::mem::transmute(bytes);\n    println!(\"{:x}\", num);\n}\n\nI drew a warning when doing this, but it turns out I was doing what I wanted and did not wnat to do what rustc wanted, so I didn’t worry about it.\n\n\n\nEndianness\n\nThe warning refers to the topic of endianness.\n\nBig deal in C, kinda not in Rust actually.\n\nPrecisely because of that warning basically.\nThis lab was very involved. Endian\n\n\nRead more\n\n\nIn computing, endianness is the order in which bytes within a word data type are transmitted over a data communication medium or addressed in computer memory, counting only byte significance compared to earliness.\n\n\nRegard an i32 as a word and a u8 as a bit.\nTake note of the endianness revealed by the prior code.\n\n\n\nNumeric Address\n\nOne possibly more advanced use of transmute is upon numeric addresses\n\nThe key, the numeric value of the address, stays the same.\nThe value, the numeric value in the memory location decribed by the address, stays the same.\nThe interpretation - how Rust understands the value at that location - changes.\n\n\nunsafe {\n    let nats: &[u32] = &[0x3F800000];\n    let nums: &[f32] = std::mem::transmute(nats);\n    println!(\"{}\", nums[0]);\n}\n\nRecall the meaning of 0x3F8000000\nI usually do this on arrays but I guess I’m not sure why.\n\nTry things out.\nVectors are definitely banned though, that is way too high level.",
    "crumbs": [
      "Transmute"
    ]
  },
  {
    "objectID": "12_split_at.html",
    "href": "12_split_at.html",
    "title": "Splits",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#homework",
    "href": "12_split_at.html#homework",
    "title": "Splits",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#citation",
    "href": "12_split_at.html#citation",
    "title": "Splits",
    "section": "Citation",
    "text": "Citation\n\nCalling an Unsafe Function or Method\nIn a way, an OS is an unsafe function or method… (this is a stretch)",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#requirements",
    "href": "12_split_at.html#requirements",
    "title": "Splits",
    "section": "Requirements",
    "text": "Requirements\n\nUpdate repository for this course.\nNew crate for this homework.\nFollow the write-up",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#unsafe",
    "href": "12_split_at.html#unsafe",
    "title": "Splits",
    "section": "Unsafe",
    "text": "Unsafe\n\nHere is an unsafe function named dangerous that doesn’t do anything in its body:\n\n    unsafe fn dangerous() {}\n\n    unsafe {\n        dangerous();\n    }\n\nWe must call the dangerous function within a separate unsafe block.\nIf we try to call dangerous without the unsafe block, we’ll get an error.",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "12_split_at.html#creating-a-safe-abstraction-over-unsafe-code",
    "href": "12_split_at.html#creating-a-safe-abstraction-over-unsafe-code",
    "title": "Splits",
    "section": "Creating a Safe Abstraction over Unsafe Code",
    "text": "Creating a Safe Abstraction over Unsafe Code\n\nJust because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe.\n\nThis blew my mind.\n\nIn fact, wrapping unsafe code in a safe function is a common abstraction.\nAs an example, let’s study the split_at_mut function from the standard library, which requires some unsafe code.\n\n\nNo Safe Way\nPeople scared of Portland refer to Safeway I shop at as the “Unsafeway” which I think is hilarious\n\nWe’ll explore how we might implement it.\nThis safe method is defined on mutable slices:\n\nIt takes one slice and makes it two by splitting the slice at the index given as an argument.\n\nHere’s an example.\n\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n\n    let (a, b) = r.split_at_mut(3);\n\nThere’s no safe way to do this.\n\nThis won’t work\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n    let len = values.len();\n\n    assert!(mid &lt;= len);\n\n    (&mut values[..mid], &mut values[mid..])\n}\n\nIt explodes:\n\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n --&gt; src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n  |                         - let's call the lifetime of this reference `'1`\n...\n6 |     (&mut values[..mid], &mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for `'1`\n  |\n  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n\n\nEnter the Borrow Checker\n\nRust’s borrow checker can’t understand that we’re borrowing different parts of the slice\n\nIt only knows that we’re borrowing from the same slice twice.\n\nBorrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but…\n\nrustc isn’t smart enough to know this.\n\nWhen we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.\n\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n\n    let ptr = values.as_mut_ptr();\n    let mid = std::cmp::min(values.len(), mid);\n\n    unsafe {\n        (\n            std::slice::from_raw_parts_mut(ptr, mid),\n            std::slice::from_raw_parts_mut(ptr.add(mid), values.len() - mid),\n        )\n    }\n}",
    "crumbs": [
      "Splits"
    ]
  },
  {
    "objectID": "02_cli.html",
    "href": "02_cli.html",
    "title": "CLI",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#homework",
    "href": "02_cli.html#homework",
    "title": "CLI",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#citation",
    "href": "02_cli.html#citation",
    "title": "CLI",
    "section": "Citation",
    "text": "Citation\n\nAn I/O Project: Building a Command Line Program\nIn a way, an OS is a “command line program”…",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#requirements",
    "href": "02_cli.html#requirements",
    "title": "CLI",
    "section": "Requirements",
    "text": "Requirements\n\nNew repository for this course.\nNew crate for this lab.\nCrate when built creates an executable that behaves identically to GNU Coreutils wc when provided with a file name and either (1) no options or a (2) options a single letter.\n\nThat is, you must support wc -c src/main.rs but not wc --files0-from=F\nCheck out wc and wc --help (which you don’t need to provide) to get a sense of the task.",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#crate",
    "href": "02_cli.html#crate",
    "title": "CLI",
    "section": "Crate",
    "text": "Crate\n\nTo complete the lab today, create a crate named my_wc in a folder named 02 in your 371os repository.\n\ncargo new 02 --name my_wc --vcs none\n\nI understand this is the same name as the lab.\n\nI am not as clever as I either think I am or would like to be.\n\nIf you’re stuck, read more here",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#wc",
    "href": "02_cli.html#wc",
    "title": "CLI",
    "section": "wc",
    "text": "wc\nImplement the complete functionality of wc using this crate.\n\nAccept character command line flags prefixed with -\nAccept string command line flags prefixed with --\nConfigure your my_wc to work on standard input if a file name is not provided.\n\n\nFull functionality\n\nHere is wc --help\nYour --help and --version may differ, but should otherwise be identical.\n\nUsage: wc [OPTION]... [FILE]...\n  or:  wc [OPTION]... --files0-from=F\nPrint newline, word, and byte counts for each FILE, and a total line if\nmore than one FILE is specified.  A word is a non-zero-length sequence of\ncharacters delimited by white space.\n\nWith no FILE, or when FILE is -, read standard input.\n\nThe options below may be used to select which counts are printed, always in\nthe following order: newline, word, character, byte, maximum line length.\n  -c, --bytes            print the byte counts\n  -m, --chars            print the character counts\n  -l, --lines            print the newline counts\n      --files0-from=F    read input from the files specified by\n                           NUL-terminated names in file F;\n                           If F is - then read names from standard input\n  -L, --max-line-length  print the maximum display width\n  -w, --words            print the word counts\n      --help     display this help and exit\n      --version  output version information and exit\n\nGNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;\nReport any translation bugs to &lt;https://translationproject.org/team/&gt;\nFull documentation &lt;https://www.gnu.org/software/coreutils/wc&gt;\nor available locally via: info '(coreutils) wc invocation'\n\n\nRubric\n\nSetup - optional\n\n$ curl https://raw.githubusercontent.com/cd-public/books/main/pg1342.txt -o book.txt\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100  739k  100  739k    0     0  1446k      0 --:--:-- --:--:-- --:--:-- 1447k\n$ head -23 book.txt | tail -1\n*** START OF THE PROJECT GUTENBERG EBOOK PRIDE AND PREJUDICE ***\n\nCharacter flags - required\n\n$ wc book.txt\n 14911 130408 757509 book.txt\n$ wc -cl book.txt\n 14911 757509 book.txt\n$ wc -c book.txt -cl\n 14911 757509 book.txt\n$ wc -l book.txt -c\n 14911 757509 book.txt\n$ wc -Ll book.txt\n 14911    159 book.txt\n\nString flags - required\n\n$ wc --bytes -c book.txt\n757509 book.txt\n$ wc --lines -c book.txt\n 14911 757509 book.txt\n$ printf \"book.txt\" &gt; file.txt\n$ wc --lines -c --files0-from=file.txt\n 14911 757509 book.txt\n$ wc --version | head -1\nwc (GNU coreutils) 8.32\n$ wc --help | head -1\nUsage: wc [OPTION]... [FILE]...\n\nStandard I/O - required\n\n$ cat book.txt | head -100 | wc\n    100     277    2787\n$ cat book.txt | head -200 | wc\n    200    1360    9359\n$ wc book.txt | wc\n      1       4      30",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "02_cli.html#helpful-reference",
    "href": "02_cli.html#helpful-reference",
    "title": "CLI",
    "section": "Helpful Reference",
    "text": "Helpful Reference\n\nWhile linked above, I think it will be very helpful to review the following:\nAccepting Command Line Arguments - The Rust Programming Language",
    "crumbs": [
      "CLI"
    ]
  },
  {
    "objectID": "00_derust.html",
    "href": "00_derust.html",
    "title": "Derust",
    "section": "",
    "text": "Welcome to OS in Rust\n\nThe most famous systems topic…\nNow in Rust, your favorite language!\n\nAction Items:\n\nAccess the course webpage\nJoin the Discord!\n\nWe’ll use CSSA.\n\nSet up Linux/Rust/Git.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#announcements",
    "href": "00_derust.html#announcements",
    "title": "Derust",
    "section": "",
    "text": "Welcome to OS in Rust\n\nThe most famous systems topic…\nNow in Rust, your favorite language!\n\nAction Items:\n\nAccess the course webpage\nJoin the Discord!\n\nWe’ll use CSSA.\n\nSet up Linux/Rust/Git.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#homework",
    "href": "00_derust.html#homework",
    "title": "Derust",
    "section": "Homework",
    "text": "Homework\n\nThe first homework, wc, is ready now.\n\nMostly just Rust practice.\n\nDue Friday, 23 Jan at 1440 PT.\n\nFriday of next week.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#today",
    "href": "00_derust.html#today",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#it-me",
    "href": "00_derust.html#it-me",
    "title": "Derust",
    "section": "It me",
    "text": "It me\n\nName\n\n(Prof. )?Calvin\n\nCredentials\n\nB.A. Mathematics\nB.S., M.S., Ph.D. Computer Science\n\nPronouns\n\nthey/them",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#the-great-work",
    "href": "00_derust.html#the-great-work",
    "title": "Derust",
    "section": "The Great Work",
    "text": "The Great Work\n\nThesis Title\n\nMining Secure Behavior of Hardware Designs\n\nPlain English\n\nJust as there are bugs in code that makes software, modern hardware is also written in code and therefore may contain bugs. I find these bugs.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#course-format",
    "href": "00_derust.html#course-format",
    "title": "Derust",
    "section": "Course Format",
    "text": "Course Format\n\nLecture Monday\nLab Wednesday\nHomework due Friday 1440 PT (the next Friday)\n\nYou should all meet on Friday.\n\nIn-class midterm week of 3/16\nYour OS is due whenever the final is scheduled.\n\nWaiting on registrar to announce.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#grade-policy",
    "href": "00_derust.html#grade-policy",
    "title": "Derust",
    "section": "Grade Policy",
    "text": "Grade Policy\n\nYour voices have been heard:\n\n\nI think failing my systems class was the best thing that happened to me.\n\n\nThis course demanded strong self-motivation… Thus, I didn’t learn as much as I might’ve if grading mattered more.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#specification-grading",
    "href": "00_derust.html#specification-grading",
    "title": "Derust",
    "section": "Specification Grading",
    "text": "Specification Grading\n\nBasically, I will assign some stuff but you don’t have to do all of it perfectly.\n\nNo partial credit, everything is boolean grading.\n\nI took distributions over final, midterm, and Lab/HW",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#it-pays-to-get-as",
    "href": "00_derust.html#it-pays-to-get-as",
    "title": "Derust",
    "section": "It pays to get A’s",
    "text": "It pays to get A’s\n\n\n\nGrade\nRequirements\n\n\n\n\nA\nFinal meets spec\n\n\nA\n90% ave HW/Lab/Midterm, Final compiles\n\n\nA-\n90% ave HW/Lab, Midterm/Final compile\n\n\nA-\nMidterm meets spec, Final compiles",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#but-bs-are-the-knees",
    "href": "00_derust.html#but-bs-are-the-knees",
    "title": "Derust",
    "section": "But B’s are the Knees",
    "text": "But B’s are the Knees\n\n\n\nGrade\nRequirements\n\n\n\n\nB+\n90% ave HW/Lab, Midterm compiles\n\n\nB\n80% ave HW/Lab, Midterm compiles\n\n\nB-\n80% ave HW/Lab",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#these-may-earn-degrees",
    "href": "00_derust.html#these-may-earn-degrees",
    "title": "Derust",
    "section": "These may (???) earn degrees",
    "text": "These may (???) earn degrees\n\n\n\nGrade\nRequirements\n\n\n\n\nC\n80% ave Lab\n\n\nD\n60% ave Lab\n\n\nF\nAnything else",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#lab-grading",
    "href": "00_derust.html#lab-grading",
    "title": "Derust",
    "section": "Lab Grading",
    "text": "Lab Grading\n\n“A” (=100%)\n\nMeets spec by end of class\n\n“B” (=90%)\n\nCompiles at end of class\n\n“F” (=0%)\n\nAnything else",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#hw-grading",
    "href": "00_derust.html#hw-grading",
    "title": "Derust",
    "section": "HW Grading",
    "text": "HW Grading\n\n“A” (=100%)\n\nOn time\nPasses autograder.\n\nI lack confidence I can make excellent autograders for all stages, so give me some grace here.\n\n\n“B” (=90%)\n\nOn time\nCompiles\n\n“F” (=0%)\n\nAnything else",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#final",
    "href": "00_derust.html#final",
    "title": "Derust",
    "section": "Final",
    "text": "Final\n\nCreate, document, and publish an operating system… in Rust!\n\nFree-standing binary\nFaults/exceptions/interrupts\nMemory management",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#late-work-policy",
    "href": "00_derust.html#late-work-policy",
    "title": "Derust",
    "section": "Late Work Policy",
    "text": "Late Work Policy\n\nLate work is not accepted.\n\nNo exceptions.\nThe specification grading framework incorpates tolerances.\nAn OS that meets spec by end-of-term is an A, always.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#ai-policy",
    "href": "00_derust.html#ai-policy",
    "title": "Derust",
    "section": "AI Policy",
    "text": "AI Policy\n\nI would be shocked if it is helpful to you.\nIf you think it is helpful, that is probably not a good sign.\nYou can use it (I wouldn’t)",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#collaboration-policy",
    "href": "00_derust.html#collaboration-policy",
    "title": "Derust",
    "section": "Collaboration Policy",
    "text": "Collaboration Policy\n\nYou should chat with each other.\nYou should write your own code.\nIf someone shows you something and you don’t understand it as well as code you write yourself, it is a waste of your time to use the code.\n\nBut not a waste as a way to learn.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#a-la-151",
    "href": "00_derust.html#a-la-151",
    "title": "Derust",
    "section": "a la 151",
    "text": "a la 151\n\nThis term we will have sections\nMeet Friday 1310-1440\nMeant to help unpack learning in class and work on homework.\nSingle section/section-leader (Jimmy)\nMiss more than 4 sections and drop one “bin” on specification grading.\n\nUnless excused.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#the-hard-part",
    "href": "00_derust.html#the-hard-part",
    "title": "Derust",
    "section": "The Hard Part",
    "text": "The Hard Part\n\nAfter ~10 years of systems research I’ve convinced myself only two things really matter:\n\nReferences, and\nRecursion\n\nRecursion isn’t too bad…\n\n&gt;&gt;&gt; exp = lambda b, n : b if n == 1 else b*exp(b,n-1)\n&gt;&gt;&gt; exp(2,8)\n256\n\nCovered in 271 and possibly 351 and no longer interesting on its own, though will be used.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#references",
    "href": "00_derust.html#references",
    "title": "Derust",
    "section": "References",
    "text": "References\n\nReferences are a beast, but without them nothing makes sense!\n\n\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; def addx():\n...     x += 1\n...\n&gt;&gt;&gt; addx()\nUnboundLocalError:\n&lt;blah blah blah error messages&gt;\n\n&gt;&gt;&gt; x = [1]\n&gt;&gt;&gt; def addx():\n...     x[0] += 1\n...\n&gt;&gt;&gt; addx()\n&gt;&gt;&gt; x\n[2]",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#insight",
    "href": "00_derust.html#insight",
    "title": "Derust",
    "section": "Insight",
    "text": "Insight\n\nDefinition:\n\nReferences: Values that are meaningful only as keys to values in key-value memory storage, as a memory addresses.\n\nImportance:\n\nThis key-value storage is a service provided by the operating system!",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#python-and-oses",
    "href": "00_derust.html#python-and-oses",
    "title": "Derust",
    "section": "Python and OSes",
    "text": "Python and OSes\n\nWhy not .py (.js, .java, .cs, .cpp, etc)?\n\nThese languages assume an underlying OS (or VM or browser).\nThere is more to life than running code other people wrote.\nGood languages (except Java) but not for us\nThe other systems language is C (and maybe C++)",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-and-references",
    "href": "00_derust.html#rust-and-references",
    "title": "Derust",
    "section": "Rust and References",
    "text": "Rust and References\n\nRust:\n\nObscures references, but…\nDoes not obscure memory.\n\nThis is good!\n\nMemory matters, but pointers are historical accident.\n\nYou should probably use Rust in every application where correctness or performance matters.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-and-recursion",
    "href": "00_derust.html#rust-and-recursion",
    "title": "Derust",
    "section": "Rust and Recursion",
    "text": "Rust and Recursion\n\nSeparately, Rust is built on one of the most exciting ongoing computer science research efforts:\nLLVM (stands for LLVM)\nBasically, a way of turning human-readable code into machine-executable code.\n\nVery good at turning recursion into iteration and/or vice versa.\n\nThis term, we benefit from LLVM in that we can make Rust programs for platforms without an underlying OS.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#citation",
    "href": "00_derust.html#citation",
    "title": "Derust",
    "section": "Citation",
    "text": "Citation\n\nWe will follow “Philipp Oppermann’s blog” “Writing an OS in Rust” version 2.\nRead more.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#bare-bones",
    "href": "00_derust.html#bare-bones",
    "title": "Derust",
    "section": "Bare Bones",
    "text": "Bare Bones\n\nA binary that doesn’t require an underlying OS.\nSomething that (1) runs and (2) prints.\nSimple I/O\nUnit and integration testing.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#interrupts",
    "href": "00_derust.html#interrupts",
    "title": "Derust",
    "section": "Interrupts",
    "text": "Interrupts\n\nCPU Exceptions\n\nLike division by zero.\n\nDouble faults\n\nFaults while handling a fault.\n\nHardware interrupts\n\nLike I/O",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#memory-management",
    "href": "00_derust.html#memory-management",
    "title": "Derust",
    "section": "Memory Management",
    "text": "Memory Management\n\nPaging\nPage tables\n\nTogether, how to find things you saved for a while.\n\nThe heap\nHeap allocation.\n\nTogether, how to find things you saved while working.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#final-examproject",
    "href": "00_derust.html#final-examproject",
    "title": "Derust",
    "section": "Final Exam/Project",
    "text": "Final Exam/Project\n\nImplement Minimal OS in Rust\n\nIndividual\nUnder version control\nCompiles and runs and is tested",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#vim",
    "href": "00_derust.html#vim",
    "title": "Derust",
    "section": "Vim",
    "text": "Vim\n\nYou should use vim or another console-based editor as a component of your learning in this class.\nThis will not be assessed (how can it be) but will likely be expected of you in life.\nI will live-code in vim probably.\n\nThis will be painful, but that is okay.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features",
    "href": "00_derust.html#rust-features",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options",
    "href": "00_derust.html#options",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes code makes sense.\nMAD\n\nfrom numpy import uint64\n\n# Multiply-add operation\ndef mad(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a + b * c",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-1",
    "href": "00_derust.html#options-1",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes it doesn’t.\nThis needn’t return a positive value!\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a - b * c",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-2",
    "href": "00_derust.html#options-2",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems…\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-3",
    "href": "00_derust.html#options-3",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems…\n\nfrom numpy import uint64\nfrom typing import Union\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; Union[None,uint64]:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#options-4",
    "href": "00_derust.html#options-4",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nEver wish there was a nice way to handle a Union[None,x] \\(\\forall x\\)?\nIt’s the option type:\n\nfn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {\n    if denominator == 0.0 {\n        None\n    } else {\n        Some(numerator / denominator)\n    }\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features-1",
    "href": "00_derust.html#rust-features-1",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#results",
    "href": "00_derust.html#results",
    "title": "Derust",
    "section": "Results",
    "text": "Results\n\nResults are basically options that incorporate error handling.\n\n// Linux Kernel Versions, latest is 6\nfn check_version(val: u8) -&gt; Result&lt;u8, &'static str&gt; {\n    if val &lt; 7 {\n        return Ok(val);\n    } else {\n        return Err(\"Not yet released.\")\n    }\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#check-it",
    "href": "00_derust.html#check-it",
    "title": "Derust",
    "section": "Check it",
    "text": "Check it\n\nAdd main.\n\n\n\nsrc/main.rs\n\n\u0016fn main() {\n    dbg!(check_version(4));\n    dbg!(check_version(7));\n}\n\n\ncargo r\n\n[src/main.rs:10:5] check_version(4) = Ok(\n    4,\n)\n[src/main.rs:11:5] check_version(7) = Err(\n    \"Not yet released.\",\n)",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features-2",
    "href": "00_derust.html#rust-features-2",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#std",
    "href": "00_derust.html#std",
    "title": "Derust",
    "section": "std",
    "text": "std\n\nOptions, results, and more fun things, like vectors, are all part of std\n\n\nThe Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec&lt;T&gt; and Option&lt;T&gt;, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#iterators",
    "href": "00_derust.html#iterators",
    "title": "Derust",
    "section": "Iterators",
    "text": "Iterators\n\nAn iterator is pretty much a for-each loop, the Python loop type.\n\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n\nOh look, vec! from std",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#closures",
    "href": "00_derust.html#closures",
    "title": "Derust",
    "section": "Closures",
    "text": "Closures\n\nA closure is pretty much a lambda function, like the Python lambda keyword.\n\nfn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n\nNo one can stop you from writing fn’s, not even people who actually know Rust!",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#pattern-matching",
    "href": "00_derust.html#pattern-matching",
    "title": "Derust",
    "section": "Pattern Matching",
    "text": "Pattern Matching\n\nThe language designers intend options (and results) to be handled as follows:\n\nfn main() {\n    let s = \"Hello, world\";\n    match s.chars().nth(11) {\n        Some(c) =&gt; println!(\"The 11th character is {:?}\", c),\n        None =&gt; println!(\"String `s` is fewer than 11 characters in length\"),\n    }\n}\n\nBasically, if-else is “un-Rust-like” most of the time.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#formatting",
    "href": "00_derust.html#formatting",
    "title": "Derust",
    "section": "Formatting",
    "text": "Formatting\n\nprint!, println!, and format! are all nice ways to work with strings.\nHandy if you are an OS and want to interface with a human.\nAssuming you (the OS) know how to display text.\n\nWe’ll get there.\n\n\nformat!(\"test\");                             // =&gt; \"test\"\nformat!(\"hello {}\", \"world!\");               // =&gt; \"hello world!\"\nformat!(\"x = {}, y = {val}\", 10, val = 30);  // =&gt; \"x = 10, y = 30\"\nlet (x, y) = (1, 2);\nformat!(\"{x} + {y} = 3\");                    // =&gt; \"1 + 2 = 3\"\n\nSimilar to Python f-strings and also every other language.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#read-more",
    "href": "00_derust.html#read-more",
    "title": "Derust",
    "section": "Read More",
    "text": "Read More\n\nI use most of these language features in two extended examples.\n\nHex reader\nFibonacci",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#rust-features-3",
    "href": "00_derust.html#rust-features-3",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#ownership",
    "href": "00_derust.html#ownership",
    "title": "Derust",
    "section": "Ownership",
    "text": "Ownership\n\nBig topic.\nBig deal.\nLearn by doing.\nQuick example.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#size",
    "href": "00_derust.html#size",
    "title": "Derust",
    "section": "Size",
    "text": "Size\n\nVersus e.g. u8 which was a fixed size.\nA string is not.\n\n// String of length 0\nlet s = \"\"; \n// Complete text of Bhagavad Gita\nlet t = \"Dhritarashtra said: O Sanjay, after gathering on the holy field of Kurukshetra, and desiring to fight, what did my sons and the sons of Pandu do? ...\n\nAnd in fact, if we implemented Python integers in Rust, they would follow similar rules.\n\nAnything that has no bounded upper size, basically.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#ownership-rules",
    "href": "00_derust.html#ownership-rules",
    "title": "Derust",
    "section": "Ownership Rules",
    "text": "Ownership Rules\n\nEach value in Rust has an owner.\nThere can only be one owner at a time.\nWhen the owner goes out of scope, the value will be dropped.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#scope",
    "href": "00_derust.html#scope",
    "title": "Derust",
    "section": "Scope",
    "text": "Scope\n\nQuoth Rust Book:\n\n{                      // s is not valid here, since it's not yet declared\n    let s = \"hello\";   // s is valid from this point forward\n\n    // do stuff with s\n}                      // this scope is now over, and s is no longer valid\n\nYou can experimentally verify each of the claims.\nBasically, the memory associated with s exists at some time points, but not others.\nThink: Address of building that hasn’t been made/has been condemned.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#capital-s-string",
    "href": "00_derust.html#capital-s-string",
    "title": "Derust",
    "section": "Capital S String",
    "text": "Capital S String\n\nCapital S String is closer to data structure than a data type in some ways:\n\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{s}\"); // this will print `hello, world!`\n\nIt accepts a push operation a la a queue/stack/list, and must be initialized with a function call.\nA String is mutable, a literal is not.",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#its-confusing",
    "href": "00_derust.html#its-confusing",
    "title": "Derust",
    "section": "It’s confusing",
    "text": "It’s confusing\n\nThis leads to some un-Pythonic behavior.\nWe compare fixed size and variable size types, which have distinct behavior\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis doesn’t.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s;\n    println!(\"{s}\")\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#whats-happening",
    "href": "00_derust.html#whats-happening",
    "title": "Derust",
    "section": "What’s happening?",
    "text": "What’s happening?\n\ns passes “out of scope” once its value is assigned to t.\nThereafter, there is no declared variable of name s.\nBut this only happens to some types.\n\nIt is unbounded types, but it’s unclear that e.g. String::from(\"6\") isn’t a fixed width string of lenth 1 (to me at least).",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#clone",
    "href": "00_derust.html#clone",
    "title": "Derust",
    "section": "Clone",
    "text": "Clone\n\nMy secret inside source with a real job (e.g. not professor) who writes Rust and also thought this was a bit silly:\n\n\nWhenever I use Rust, I just always .clone and when someone asks me about it, I say that’s a performance optimization for latter.\n\n\nRust says the same thing, actually:\n\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n6 |     let t = s.clone();\n  |              ++++++++",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#example",
    "href": "00_derust.html#example",
    "title": "Derust",
    "section": "Example",
    "text": "Example\n\nIt is reasonable to use .clone on capital S String for e.g. Wordle, as needed.\nAs a challenge, don’t use .clone (you don’t need it)\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis works.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s.clone();\n    println!(\"{s}\")\n}",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.html#today-1",
    "href": "00_derust.html#today-1",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust",
    "crumbs": [
      "Derust"
    ]
  },
  {
    "objectID": "00_derust.rjs.html#announcements",
    "href": "00_derust.rjs.html#announcements",
    "title": "Derust",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to OS in Rust\n\nThe most famous systems topic…\nNow in Rust, your favorite language!\n\nAction Items:\n\nAccess the course webpage\nJoin the Discord!\n\nWe’ll use CSSA.\n\nSet up Linux/Rust/Git."
  },
  {
    "objectID": "00_derust.rjs.html#homework",
    "href": "00_derust.rjs.html#homework",
    "title": "Derust",
    "section": "Homework",
    "text": "Homework\n\nThe first homework, wc, is ready now.\n\nMostly just Rust practice.\n\nDue Friday, 23 Jan at 1440 PT.\n\nFriday of next week."
  },
  {
    "objectID": "00_derust.rjs.html#today",
    "href": "00_derust.rjs.html#today",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust"
  },
  {
    "objectID": "00_derust.rjs.html#it-me",
    "href": "00_derust.rjs.html#it-me",
    "title": "Derust",
    "section": "It me",
    "text": "It me\n\nName\n\n(Prof. )?Calvin\n\nCredentials\n\nB.A. Mathematics\nB.S., M.S., Ph.D. Computer Science\n\nPronouns\n\nthey/them"
  },
  {
    "objectID": "00_derust.rjs.html#the-great-work",
    "href": "00_derust.rjs.html#the-great-work",
    "title": "Derust",
    "section": "The Great Work",
    "text": "The Great Work\n\nThesis Title\n\nMining Secure Behavior of Hardware Designs\n\nPlain English\n\nJust as there are bugs in code that makes software, modern hardware is also written in code and therefore may contain bugs. I find these bugs."
  },
  {
    "objectID": "00_derust.rjs.html#course-format",
    "href": "00_derust.rjs.html#course-format",
    "title": "Derust",
    "section": "Course Format",
    "text": "Course Format\n\nLecture Monday\nLab Wednesday\nHomework due Friday 1440 PT (the next Friday)\n\nYou should all meet on Friday.\n\nIn-class midterm week of 3/16\nYour OS is due whenever the final is scheduled.\n\nWaiting on registrar to announce."
  },
  {
    "objectID": "00_derust.rjs.html#grade-policy",
    "href": "00_derust.rjs.html#grade-policy",
    "title": "Derust",
    "section": "Grade Policy",
    "text": "Grade Policy\n\nYour voices have been heard:\n\n\nI think failing my systems class was the best thing that happened to me.\n\n\nThis course demanded strong self-motivation… Thus, I didn’t learn as much as I might’ve if grading mattered more."
  },
  {
    "objectID": "00_derust.rjs.html#specification-grading",
    "href": "00_derust.rjs.html#specification-grading",
    "title": "Derust",
    "section": "Specification Grading",
    "text": "Specification Grading\n\nBasically, I will assign some stuff but you don’t have to do all of it perfectly.\n\nNo partial credit, everything is boolean grading.\n\nI took distributions over final, midterm, and Lab/HW"
  },
  {
    "objectID": "00_derust.rjs.html#it-pays-to-get-as",
    "href": "00_derust.rjs.html#it-pays-to-get-as",
    "title": "Derust",
    "section": "It pays to get A’s",
    "text": "It pays to get A’s\n\n\n\nGrade\nRequirements\n\n\n\n\nA\nFinal meets spec\n\n\nA\n90% ave HW/Lab/Midterm, Final compiles\n\n\nA-\n90% ave HW/Lab, Midterm/Final compile\n\n\nA-\nMidterm meets spec, Final compiles"
  },
  {
    "objectID": "00_derust.rjs.html#but-bs-are-the-knees",
    "href": "00_derust.rjs.html#but-bs-are-the-knees",
    "title": "Derust",
    "section": "But B’s are the Knees",
    "text": "But B’s are the Knees\n\n\n\nGrade\nRequirements\n\n\n\n\nB+\n90% ave HW/Lab, Midterm compiles\n\n\nB\n80% ave HW/Lab, Midterm compiles\n\n\nB-\n80% ave HW/Lab"
  },
  {
    "objectID": "00_derust.rjs.html#these-may-earn-degrees",
    "href": "00_derust.rjs.html#these-may-earn-degrees",
    "title": "Derust",
    "section": "These may (???) earn degrees",
    "text": "These may (???) earn degrees\n\n\n\nGrade\nRequirements\n\n\n\n\nC\n80% ave Lab\n\n\nD\n60% ave Lab\n\n\nF\nAnything else"
  },
  {
    "objectID": "00_derust.rjs.html#lab-grading",
    "href": "00_derust.rjs.html#lab-grading",
    "title": "Derust",
    "section": "Lab Grading",
    "text": "Lab Grading\n\n“A” (=100%)\n\nMeets spec by end of class\n\n“B” (=90%)\n\nCompiles at end of class\n\n“F” (=0%)\n\nAnything else"
  },
  {
    "objectID": "00_derust.rjs.html#hw-grading",
    "href": "00_derust.rjs.html#hw-grading",
    "title": "Derust",
    "section": "HW Grading",
    "text": "HW Grading\n\n“A” (=100%)\n\nOn time\nPasses autograder.\n\nI lack confidence I can make excellent autograders for all stages, so give me some grace here.\n\n\n“B” (=90%)\n\nOn time\nCompiles\n\n“F” (=0%)\n\nAnything else"
  },
  {
    "objectID": "00_derust.rjs.html#final",
    "href": "00_derust.rjs.html#final",
    "title": "Derust",
    "section": "Final",
    "text": "Final\n\nCreate, document, and publish an operating system… in Rust!\n\nFree-standing binary\nFaults/exceptions/interrupts\nMemory management"
  },
  {
    "objectID": "00_derust.rjs.html#late-work-policy",
    "href": "00_derust.rjs.html#late-work-policy",
    "title": "Derust",
    "section": "Late Work Policy",
    "text": "Late Work Policy\n\nLate work is not accepted.\n\nNo exceptions.\nThe specification grading framework incorpates tolerances.\nAn OS that meets spec by end-of-term is an A, always."
  },
  {
    "objectID": "00_derust.rjs.html#ai-policy",
    "href": "00_derust.rjs.html#ai-policy",
    "title": "Derust",
    "section": "AI Policy",
    "text": "AI Policy\n\nI would be shocked if it is helpful to you.\nIf you think it is helpful, that is probably not a good sign.\nYou can use it (I wouldn’t)"
  },
  {
    "objectID": "00_derust.rjs.html#collaboration-policy",
    "href": "00_derust.rjs.html#collaboration-policy",
    "title": "Derust",
    "section": "Collaboration Policy",
    "text": "Collaboration Policy\n\nYou should chat with each other.\nYou should write your own code.\nIf someone shows you something and you don’t understand it as well as code you write yourself, it is a waste of your time to use the code.\n\nBut not a waste as a way to learn."
  },
  {
    "objectID": "00_derust.rjs.html#a-la-151",
    "href": "00_derust.rjs.html#a-la-151",
    "title": "Derust",
    "section": "a la 151",
    "text": "a la 151\n\nThis term we will have sections\nMeet Friday 1310-1440\nMeant to help unpack learning in class and work on homework.\nSingle section/section-leader (Jimmy)\nMiss more than 4 sections and drop one “bin” on specification grading.\n\nUnless excused."
  },
  {
    "objectID": "00_derust.rjs.html#the-hard-part",
    "href": "00_derust.rjs.html#the-hard-part",
    "title": "Derust",
    "section": "The Hard Part",
    "text": "The Hard Part\n\nAfter ~10 years of systems research I’ve convinced myself only two things really matter:\n\nReferences, and\nRecursion\n\nRecursion isn’t too bad…\n\n&gt;&gt;&gt; exp = lambda b, n : b if n == 1 else b*exp(b,n-1)\n&gt;&gt;&gt; exp(2,8)\n256\n\nCovered in 271 and possibly 351 and no longer interesting on its own, though will be used."
  },
  {
    "objectID": "00_derust.rjs.html#references",
    "href": "00_derust.rjs.html#references",
    "title": "Derust",
    "section": "References",
    "text": "References\n\nReferences are a beast, but without them nothing makes sense!\n\n\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; def addx():\n...     x += 1\n...\n&gt;&gt;&gt; addx()\nUnboundLocalError:\n&lt;blah blah blah error messages&gt;\n\n&gt;&gt;&gt; x = [1]\n&gt;&gt;&gt; def addx():\n...     x[0] += 1\n...\n&gt;&gt;&gt; addx()\n&gt;&gt;&gt; x\n[2]"
  },
  {
    "objectID": "00_derust.rjs.html#insight",
    "href": "00_derust.rjs.html#insight",
    "title": "Derust",
    "section": "Insight",
    "text": "Insight\n\nDefinition:\n\nReferences: Values that are meaningful only as keys to values in key-value memory storage, as a memory addresses.\n\nImportance:\n\nThis key-value storage is a service provided by the operating system!"
  },
  {
    "objectID": "00_derust.rjs.html#python-and-oses",
    "href": "00_derust.rjs.html#python-and-oses",
    "title": "Derust",
    "section": "Python and OSes",
    "text": "Python and OSes\n\nWhy not .py (.js, .java, .cs, .cpp, etc)?\n\nThese languages assume an underlying OS (or VM or browser).\nThere is more to life than running code other people wrote.\nGood languages (except Java) but not for us\nThe other systems language is C (and maybe C++)"
  },
  {
    "objectID": "00_derust.rjs.html#rust-and-references",
    "href": "00_derust.rjs.html#rust-and-references",
    "title": "Derust",
    "section": "Rust and References",
    "text": "Rust and References\n\nRust:\n\nObscures references, but…\nDoes not obscure memory.\n\nThis is good!\n\nMemory matters, but pointers are historical accident.\n\nYou should probably use Rust in every application where correctness or performance matters."
  },
  {
    "objectID": "00_derust.rjs.html#rust-and-recursion",
    "href": "00_derust.rjs.html#rust-and-recursion",
    "title": "Derust",
    "section": "Rust and Recursion",
    "text": "Rust and Recursion\n\nSeparately, Rust is built on one of the most exciting ongoing computer science research efforts:\nLLVM (stands for LLVM)\nBasically, a way of turning human-readable code into machine-executable code.\n\nVery good at turning recursion into iteration and/or vice versa.\n\nThis term, we benefit from LLVM in that we can make Rust programs for platforms without an underlying OS."
  },
  {
    "objectID": "00_derust.rjs.html#citation",
    "href": "00_derust.rjs.html#citation",
    "title": "Derust",
    "section": "Citation",
    "text": "Citation\n\nWe will follow “Philipp Oppermann’s blog” “Writing an OS in Rust” version 2.\nRead more."
  },
  {
    "objectID": "00_derust.rjs.html#bare-bones",
    "href": "00_derust.rjs.html#bare-bones",
    "title": "Derust",
    "section": "Bare Bones",
    "text": "Bare Bones\n\nA binary that doesn’t require an underlying OS.\nSomething that (1) runs and (2) prints.\nSimple I/O\nUnit and integration testing."
  },
  {
    "objectID": "00_derust.rjs.html#interrupts",
    "href": "00_derust.rjs.html#interrupts",
    "title": "Derust",
    "section": "Interrupts",
    "text": "Interrupts\n\nCPU Exceptions\n\nLike division by zero.\n\nDouble faults\n\nFaults while handling a fault.\n\nHardware interrupts\n\nLike I/O"
  },
  {
    "objectID": "00_derust.rjs.html#memory-management",
    "href": "00_derust.rjs.html#memory-management",
    "title": "Derust",
    "section": "Memory Management",
    "text": "Memory Management\n\nPaging\nPage tables\n\nTogether, how to find things you saved for a while.\n\nThe heap\nHeap allocation.\n\nTogether, how to find things you saved while working."
  },
  {
    "objectID": "00_derust.rjs.html#final-examproject",
    "href": "00_derust.rjs.html#final-examproject",
    "title": "Derust",
    "section": "Final Exam/Project",
    "text": "Final Exam/Project\n\nImplement Minimal OS in Rust\n\nIndividual\nUnder version control\nCompiles and runs and is tested"
  },
  {
    "objectID": "00_derust.rjs.html#vim",
    "href": "00_derust.rjs.html#vim",
    "title": "Derust",
    "section": "Vim",
    "text": "Vim\n\nYou should use vim or another console-based editor as a component of your learning in this class.\nThis will not be assessed (how can it be) but will likely be expected of you in life.\nI will live-code in vim probably.\n\nThis will be painful, but that is okay."
  },
  {
    "objectID": "00_derust.rjs.html#rust-features",
    "href": "00_derust.rjs.html#rust-features",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#options",
    "href": "00_derust.rjs.html#options",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes code makes sense.\nMAD\n\nfrom numpy import uint64\n\n# Multiply-add operation\ndef mad(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a + b * c"
  },
  {
    "objectID": "00_derust.rjs.html#options-1",
    "href": "00_derust.rjs.html#options-1",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nSometimes it doesn’t.\nThis needn’t return a positive value!\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    return a - b * c"
  },
  {
    "objectID": "00_derust.rjs.html#options-2",
    "href": "00_derust.rjs.html#options-2",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems…\n\nfrom numpy import uint64\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; uint64:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None"
  },
  {
    "objectID": "00_derust.rjs.html#options-3",
    "href": "00_derust.rjs.html#options-3",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nHandle your cases!\nBut this causes other problems…\n\nfrom numpy import uint64\nfrom typing import Union\n\n# Multiply-sub operation\ndef msu(a:uint64, b:uint64, c:uint64) -&gt; Union[None,uint64]:\n    if b * c &gt; a:\n        return a + b * c\n    else:\n        return None"
  },
  {
    "objectID": "00_derust.rjs.html#options-4",
    "href": "00_derust.rjs.html#options-4",
    "title": "Derust",
    "section": "Options",
    "text": "Options\n\nEver wish there was a nice way to handle a Union[None,x] \\(\\forall x\\)?\nIt’s the option type:\n\nfn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {\n    if denominator == 0.0 {\n        None\n    } else {\n        Some(numerator / denominator)\n    }\n}"
  },
  {
    "objectID": "00_derust.rjs.html#rust-features-1",
    "href": "00_derust.rjs.html#rust-features-1",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#results",
    "href": "00_derust.rjs.html#results",
    "title": "Derust",
    "section": "Results",
    "text": "Results\n\nResults are basically options that incorporate error handling.\n\n// Linux Kernel Versions, latest is 6\nfn check_version(val: u8) -&gt; Result&lt;u8, &'static str&gt; {\n    if val &lt; 7 {\n        return Ok(val);\n    } else {\n        return Err(\"Not yet released.\")\n    }\n}"
  },
  {
    "objectID": "00_derust.rjs.html#check-it",
    "href": "00_derust.rjs.html#check-it",
    "title": "Derust",
    "section": "Check it",
    "text": "Check it\n\nAdd main.\n\n\n\nsrc/main.rs\n\n\u0016fn main() {\n    dbg!(check_version(4));\n    dbg!(check_version(7));\n}\n\n\ncargo r\n\n[src/main.rs:10:5] check_version(4) = Ok(\n    4,\n)\n[src/main.rs:11:5] check_version(7) = Err(\n    \"Not yet released.\",\n)"
  },
  {
    "objectID": "00_derust.rjs.html#rust-features-2",
    "href": "00_derust.rjs.html#rust-features-2",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#std",
    "href": "00_derust.rjs.html#std",
    "title": "Derust",
    "section": "std",
    "text": "std\n\nOptions, results, and more fun things, like vectors, are all part of std\n\n\nThe Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types, like Vec&lt;T&gt; and Option&lt;T&gt;, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things."
  },
  {
    "objectID": "00_derust.rjs.html#iterators",
    "href": "00_derust.rjs.html#iterators",
    "title": "Derust",
    "section": "Iterators",
    "text": "Iterators\n\nAn iterator is pretty much a for-each loop, the Python loop type.\n\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n\nOh look, vec! from std"
  },
  {
    "objectID": "00_derust.rjs.html#closures",
    "href": "00_derust.rjs.html#closures",
    "title": "Derust",
    "section": "Closures",
    "text": "Closures\n\nA closure is pretty much a lambda function, like the Python lambda keyword.\n\nfn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n\nNo one can stop you from writing fn’s, not even people who actually know Rust!"
  },
  {
    "objectID": "00_derust.rjs.html#pattern-matching",
    "href": "00_derust.rjs.html#pattern-matching",
    "title": "Derust",
    "section": "Pattern Matching",
    "text": "Pattern Matching\n\nThe language designers intend options (and results) to be handled as follows:\n\nfn main() {\n    let s = \"Hello, world\";\n    match s.chars().nth(11) {\n        Some(c) =&gt; println!(\"The 11th character is {:?}\", c),\n        None =&gt; println!(\"String `s` is fewer than 11 characters in length\"),\n    }\n}\n\nBasically, if-else is “un-Rust-like” most of the time."
  },
  {
    "objectID": "00_derust.rjs.html#formatting",
    "href": "00_derust.rjs.html#formatting",
    "title": "Derust",
    "section": "Formatting",
    "text": "Formatting\n\nprint!, println!, and format! are all nice ways to work with strings.\nHandy if you are an OS and want to interface with a human.\nAssuming you (the OS) know how to display text.\n\nWe’ll get there.\n\n\nformat!(\"test\");                             // =&gt; \"test\"\nformat!(\"hello {}\", \"world!\");               // =&gt; \"hello world!\"\nformat!(\"x = {}, y = {val}\", 10, val = 30);  // =&gt; \"x = 10, y = 30\"\nlet (x, y) = (1, 2);\nformat!(\"{x} + {y} = 3\");                    // =&gt; \"1 + 2 = 3\"\n\nSimilar to Python f-strings and also every other language."
  },
  {
    "objectID": "00_derust.rjs.html#read-more",
    "href": "00_derust.rjs.html#read-more",
    "title": "Derust",
    "section": "Read More",
    "text": "Read More\n\nI use most of these language features in two extended examples.\n\nHex reader\nFibonacci"
  },
  {
    "objectID": "00_derust.rjs.html#rust-features-3",
    "href": "00_derust.rjs.html#rust-features-3",
    "title": "Derust",
    "section": "Rust Features",
    "text": "Rust Features\n\noption\nresult\nstd\niterators\nclosures\npattern matching\nformat!\nownership"
  },
  {
    "objectID": "00_derust.rjs.html#ownership",
    "href": "00_derust.rjs.html#ownership",
    "title": "Derust",
    "section": "Ownership",
    "text": "Ownership\n\nBig topic.\nBig deal.\nLearn by doing.\nQuick example."
  },
  {
    "objectID": "00_derust.rjs.html#size",
    "href": "00_derust.rjs.html#size",
    "title": "Derust",
    "section": "Size",
    "text": "Size\n\nVersus e.g. u8 which was a fixed size.\nA string is not.\n\n// String of length 0\nlet s = \"\"; \n// Complete text of Bhagavad Gita\nlet t = \"Dhritarashtra said: O Sanjay, after gathering on the holy field of Kurukshetra, and desiring to fight, what did my sons and the sons of Pandu do? ...\n\nAnd in fact, if we implemented Python integers in Rust, they would follow similar rules.\n\nAnything that has no bounded upper size, basically."
  },
  {
    "objectID": "00_derust.rjs.html#ownership-rules",
    "href": "00_derust.rjs.html#ownership-rules",
    "title": "Derust",
    "section": "Ownership Rules",
    "text": "Ownership Rules\n\nEach value in Rust has an owner.\nThere can only be one owner at a time.\nWhen the owner goes out of scope, the value will be dropped."
  },
  {
    "objectID": "00_derust.rjs.html#scope",
    "href": "00_derust.rjs.html#scope",
    "title": "Derust",
    "section": "Scope",
    "text": "Scope\n\nQuoth Rust Book:\n\n{                      // s is not valid here, since it's not yet declared\n    let s = \"hello\";   // s is valid from this point forward\n\n    // do stuff with s\n}                      // this scope is now over, and s is no longer valid\n\nYou can experimentally verify each of the claims.\nBasically, the memory associated with s exists at some time points, but not others.\nThink: Address of building that hasn’t been made/has been condemned."
  },
  {
    "objectID": "00_derust.rjs.html#capital-s-string",
    "href": "00_derust.rjs.html#capital-s-string",
    "title": "Derust",
    "section": "Capital S String",
    "text": "Capital S String\n\nCapital S String is closer to data structure than a data type in some ways:\n\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{s}\"); // this will print `hello, world!`\n\nIt accepts a push operation a la a queue/stack/list, and must be initialized with a function call.\nA String is mutable, a literal is not."
  },
  {
    "objectID": "00_derust.rjs.html#its-confusing",
    "href": "00_derust.rjs.html#its-confusing",
    "title": "Derust",
    "section": "It’s confusing",
    "text": "It’s confusing\n\nThis leads to some un-Pythonic behavior.\nWe compare fixed size and variable size types, which have distinct behavior\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis doesn’t.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s;\n    println!(\"{s}\")\n}"
  },
  {
    "objectID": "00_derust.rjs.html#whats-happening",
    "href": "00_derust.rjs.html#whats-happening",
    "title": "Derust",
    "section": "What’s happening?",
    "text": "What’s happening?\n\ns passes “out of scope” once its value is assigned to t.\nThereafter, there is no declared variable of name s.\nBut this only happens to some types.\n\nIt is unbounded types, but it’s unclear that e.g. String::from(\"6\") isn’t a fixed width string of lenth 1 (to me at least)."
  },
  {
    "objectID": "00_derust.rjs.html#clone",
    "href": "00_derust.rjs.html#clone",
    "title": "Derust",
    "section": "Clone",
    "text": "Clone\n\nMy secret inside source with a real job (e.g. not professor) who writes Rust and also thought this was a bit silly:\n\n\nWhenever I use Rust, I just always .clone and when someone asks me about it, I say that’s a performance optimization for latter.\n\n\nRust says the same thing, actually:\n\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n6 |     let t = s.clone();\n  |              ++++++++"
  },
  {
    "objectID": "00_derust.rjs.html#example",
    "href": "00_derust.rjs.html#example",
    "title": "Derust",
    "section": "Example",
    "text": "Example\n\nIt is reasonable to use .clone on capital S String for e.g. Wordle, as needed.\nAs a challenge, don’t use .clone (you don’t need it)\n\n\n\n\nThis works.\n\nfn main() {\n    let x = 5;\n    let y = x;\n    println!(\"{x}\");\n}\n\n\nThis works.\n\nfn main() {\n    let s = String::from(\"6\");\n    let t = s.clone();\n    println!(\"{s}\")\n}"
  },
  {
    "objectID": "00_derust.rjs.html#today-1",
    "href": "00_derust.rjs.html#today-1",
    "title": "Derust",
    "section": "Today",
    "text": "Today\n\nLogistics\nOn Systems\nOn Rust\nCourse Sketch\nDerust"
  },
  {
    "objectID": "01_wc.html",
    "href": "01_wc.html",
    "title": "wc",
    "section": "",
    "text": "Lab Day\n\nSet up environment\nBuilding a command line program",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#announcements",
    "href": "01_wc.html#announcements",
    "title": "wc",
    "section": "",
    "text": "Lab Day\n\nSet up environment\nBuilding a command line program",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#homework",
    "href": "01_wc.html#homework",
    "title": "wc",
    "section": "Homework",
    "text": "Homework\n\n“CLI” is just this lab but more complete.\n\nWindows officially no longer supported.\n\nDue Friday, 23 Jan. at 1440 ET.\n\nPlan to hang out as a class 1310-1440 on Fridays, probably.",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#setup",
    "href": "01_wc.html#setup",
    "title": "wc",
    "section": "Setup",
    "text": "Setup\n\nIf you are stuck setting up Rust, following this\nAt the end you should have:\n\ncargo, git, and at least one of gcc or clang on your system.\nA repository named 371os on Github that is either (1) public or (2) shared with [cd-public](https://github.com/cd-public",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#requirements",
    "href": "01_wc.html#requirements",
    "title": "wc",
    "section": "Requirements",
    "text": "Requirements\n\nNew repository for this course.\nNew crate for this lab.\nCrate when built creates an executable that behaves identically to GNU Coreutils wc when provided with a file name and no options.\n\nThat is, you must support wc src/main.rs but not wc --files0-from=F src/main.rs\nCheck out wc and wc --help (which you don’t need to provide) to get a sense of the task.",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#repository",
    "href": "01_wc.html#repository",
    "title": "wc",
    "section": "Repository",
    "text": "Repository\n\nCreate a repository for this class.\nRequirements\n\nName is 371os\nMay be public or private to you and me (cd-public).\n\nRead more\n\nMust email me a link to your repository from your @willamette.edu email, e.g.:\n\nhttps://github.com/cd-example/371os\nIf you’re stuck, read more here",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#crate",
    "href": "01_wc.html#crate",
    "title": "wc",
    "section": "Crate",
    "text": "Crate\n\nTo complete the lab today, create a crate named my_wc in a folder named 01 in your 371os repository.\n\ncargo new 01 --name my_wc --vcs none\n\nIf you’re stuck, read more here",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#wc",
    "href": "01_wc.html#wc",
    "title": "wc",
    "section": "wc",
    "text": "wc\n\nImplement the minimal base functionality of wc using this crate.\n\n\nFull functionality\n\nHere is wc --help\nYou do not need to do all of this!\n\nUsage: wc [OPTION]... [FILE]...\n  or:  wc [OPTION]... --files0-from=F\nPrint newline, word, and byte counts for each FILE, and a total line if\nmore than one FILE is specified.  A word is a non-zero-length sequence of\ncharacters delimited by white space.\n\nWith no FILE, or when FILE is -, read standard input.\n\nThe options below may be used to select which counts are printed, always in\nthe following order: newline, word, character, byte, maximum line length.\n  -c, --bytes            print the byte counts\n  -m, --chars            print the character counts\n  -l, --lines            print the newline counts\n      --files0-from=F    read input from the files specified by\n                           NUL-terminated names in file F;\n                           If F is - then read names from standard input\n  -L, --max-line-length  print the maximum display width\n  -w, --words            print the word counts\n      --help     display this help and exit\n      --version  output version information and exit\n\nGNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;\nReport any translation bugs to &lt;https://translationproject.org/team/&gt;\nFull documentation &lt;https://www.gnu.org/software/coreutils/wc&gt;\nor available locally via: info '(coreutils) wc invocation'\n\n\nRequired functionality\n\nThat is more than required, you need only implement:\n\nUsage: wc [FILE]\nPrint newline, word, and byte counts for each FILE. A word is a \nnon-zero-length sequence of characters delimited by white space.\n\nThis can be trivially tested with some of the following:\n\n$ wc src/main.rs\n 12  30 229 src/main.rs\n$ cargo build release\n$ ./target/release/my_wc src/main.rs\n 12  30 229 src/main.rs\n\nYour src/main.rs need not be of any particular size, and you needn’t implement all code within src/main.rs, but you should get the same counts from wc and from your release binary.",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "01_wc.html#helpful-reference",
    "href": "01_wc.html#helpful-reference",
    "title": "wc",
    "section": "Helpful Reference",
    "text": "Helpful Reference\n\nWhen working on projects like this, I almost always have the following reference material open.\nread_lines - Rust By Example\n\n\nfn read_lines(filename: &str) -&gt; Vec&lt;String&gt; {\n    let mut result = Vec::new();\n\n    for line in std::fs::read_to_string(filename).unwrap().lines() {\n        result.push(line.to_string())\n    }\n\n    result\n}",
    "crumbs": [
      "wc"
    ]
  },
  {
    "objectID": "11_unsafe.rjs.html#announcements",
    "href": "11_unsafe.rjs.html#announcements",
    "title": "Unsafe",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to OS in Rust\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept. at 1440 PT.\nJust a quick demo for HW this week, check it out whenever."
  },
  {
    "objectID": "11_unsafe.rjs.html#today",
    "href": "11_unsafe.rjs.html#today",
    "title": "Unsafe",
    "section": "Today",
    "text": "Today\n\nUnsafe\nUB\nDereferencing"
  },
  {
    "objectID": "11_unsafe.rjs.html#the-dark-arts-of-unsafe-rust",
    "href": "11_unsafe.rjs.html#the-dark-arts-of-unsafe-rust",
    "title": "Unsafe",
    "section": "The Dark Arts of Unsafe Rust",
    "text": "The Dark Arts of Unsafe Rust\n\nTHE KNOWLEDGE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF UNLEASHING INDESCRIBABLE HORRORS THAT SHATTER YOUR PSYCHE AND SET YOUR MIND ADRIFT IN THE UNKNOWABLY INFINITE COSMOS."
  },
  {
    "objectID": "11_unsafe.rjs.html#motivation",
    "href": "11_unsafe.rjs.html#motivation",
    "title": "Unsafe",
    "section": "Motivation",
    "text": "Motivation\n\nOften we don’t worry about low-level implementation details.\n\nHow many bits is an integer in Python?\nHow many bits is this array in Rust?\n\n\nlet mut array: [i32; 3] = [0; 3];\n\nWho could possibly care how much space the empty tuple occupies?"
  },
  {
    "objectID": "11_unsafe.rjs.html#sometimes-it-matters",
    "href": "11_unsafe.rjs.html#sometimes-it-matters",
    "title": "Unsafe",
    "section": "Sometimes it matters…",
    "text": "Sometimes it matters…\n\nThe most common reason is performance, but\nMore importantly, these details can become a matter of correctness when interfacing directly with\n\nhardware,\noperating systems, or\nother languages (by which we mean C)"
  },
  {
    "objectID": "11_unsafe.rjs.html#legacy",
    "href": "11_unsafe.rjs.html#legacy",
    "title": "Unsafe",
    "section": "Legacy",
    "text": "Legacy\nWhen implementation details start to matter in a safe programming language, programmers usually have three options:\n\nfiddle with the code to “encourage” the compiler/runtime to perform an optimization\nadopt a more unidiomatic or cumbersome design to get the desired implementation\nrewrite the implementation in a language that lets you deal with those details"
  },
  {
    "objectID": "11_unsafe.rjs.html#rust-on-c",
    "href": "11_unsafe.rjs.html#rust-on-c",
    "title": "Unsafe",
    "section": "Rust on C",
    "text": "Rust on C\n\nUnfortunately, C is incredibly unsafe to use (sometimes for good reason), and this unsafety is magnified when trying to interoperate with another language. Care must be taken to ensure C and the other language agree on what’s happening, and that they don’t step on each other’s toes."
  },
  {
    "objectID": "11_unsafe.rjs.html#both-and",
    "href": "11_unsafe.rjs.html#both-and",
    "title": "Unsafe",
    "section": "Both, and",
    "text": "Both, and\n\nSo what does this have to do with Rust?\n\nWell, unlike C, Rust is a safe programming language.\nBut, like C, Rust is an unsafe programming language.\n\nMore accurately, Rust contains both a safe and unsafe programming language.\n\n\nRust can be thought of as a combination of two programming languages: Safe Rust and Unsafe Rust."
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-rust",
    "href": "11_unsafe.rjs.html#safe-rust",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nThe default case\nWhat we’ve used to far, at least officially\n\nYou may have incidentally dabbled in unsafe.\nGood for you.\n\nSafe Rust only really makes one guarantee.\n\n\nRust’s memory safety guarantees enforced at compile time\n\n\nThat is, you can never try to read something that doesn’t exist."
  },
  {
    "objectID": "11_unsafe.rjs.html#unsafe-rust",
    "href": "11_unsafe.rjs.html#unsafe-rust",
    "title": "Unsafe",
    "section": "Unsafe Rust",
    "text": "Unsafe Rust\n\nSometimes, you may want to have two reference to an object that are both mutable.\n\nFor example, if you are implementing a suffix tree, a task I didn’t assign last term because it was miserable in safe Rust.\n\nSometimes, you want to do so in a way that can’t possibly break anything.\n\nFor example, you may only be using provably correct algorithms (whatever that means).\nBut of course, rustc isn’t a theorem prover…"
  },
  {
    "objectID": "11_unsafe.rjs.html#warning",
    "href": "11_unsafe.rjs.html#warning",
    "title": "Unsafe",
    "section": "Warning",
    "text": "Warning\n\nUnsafe Rust is, well, not (safe). In fact, Unsafe Rust lets us do some really unsafe things. Things the Rust authors will implore you not to do, but we’ll do anyway."
  },
  {
    "objectID": "11_unsafe.rjs.html#true-rust",
    "href": "11_unsafe.rjs.html#true-rust",
    "title": "Unsafe",
    "section": "True Rust",
    "text": "True Rust\n\nSafe Rust is the true Rust programming language.\nIf all you do is write Safe Rust, you will never have to worry about type-safety or memory-safety.\nYou will never endure\n\na dangling pointer,\na use-after-free, or\nany other kind of Undefined Behavior (a.k.a. UB)."
  },
  {
    "objectID": "11_unsafe.rjs.html#std",
    "href": "11_unsafe.rjs.html#std",
    "title": "Unsafe",
    "section": "std",
    "text": "std\n\nThe standard library also gives you enough utilities out of the box that you’ll be able to write high-performance applications and libraries in pure idiomatic Safe Rust.\nAssuming, of course, you are working on a system where std is already implemented.\nNot, you know, writing your own OS or own std."
  },
  {
    "objectID": "11_unsafe.rjs.html#twinsies",
    "href": "11_unsafe.rjs.html#twinsies",
    "title": "Unsafe",
    "section": "Twinsies",
    "text": "Twinsies\n\nUnsafe Rust is exactly like Safe Rust with all the same rules and semantics.\nIt just lets you do some extra things that are Definitely Not Safe."
  },
  {
    "objectID": "11_unsafe.rjs.html#payoffs",
    "href": "11_unsafe.rjs.html#payoffs",
    "title": "Unsafe",
    "section": "Payoffs",
    "text": "Payoffs\n\nThe value of this separation is that we gain the benefits of using an unsafe language like C\n\nlow level control over implementation details\n\n…without most (citation needed) of the problems that come with trying to integrate it with a completely different safe language."
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-rust-1",
    "href": "11_unsafe.rjs.html#safe-rust-1",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nSafe Rust guarantees certain things about your code.\n\nMost of these won’t even make sense to you unless you write C"
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-prevents",
    "href": "11_unsafe.rjs.html#safe-prevents",
    "title": "Unsafe",
    "section": "Safe Prevents",
    "text": "Safe Prevents\n\nDereferencing (using the * operator on) dangling or unaligned pointers (see below)\nBreaking the “pointer aliasing rules” using & (borrow) and mut\nCalling a function with the wrong call types\nCausing a data race when multithreading\nExecuting code compiled for hardware other than currently hosting the process not support\nProducing invalid values like something other than 0 or 1 for a boolean."
  },
  {
    "objectID": "11_unsafe.rjs.html#safe-allows",
    "href": "11_unsafe.rjs.html#safe-allows",
    "title": "Unsafe",
    "section": "Safe Allows",
    "text": "Safe Allows\n\nDeadlocks when multithreading\nLeaks of memory and other resources\nExiting without calling destructors\nExposing randomized base addresses through pointer leaks\nInteger overflow (recall SHA wrapping)\nLogic errors\n\nlet val = 7;\nlet val_is_even = if val % 2 == 1 { true } else { false };"
  },
  {
    "objectID": "11_unsafe.rjs.html#unsafe-allows",
    "href": "11_unsafe.rjs.html#unsafe-allows",
    "title": "Unsafe",
    "section": "Unsafe allows:",
    "text": "Unsafe allows:\n\nDereference a raw pointer.\nCall an unsafe function or method.\nAccess or modify a mutable static variable.\nImplement an unsafe trait.\nAccess fields of unions."
  },
  {
    "objectID": "11_unsafe.rjs.html#simply",
    "href": "11_unsafe.rjs.html#simply",
    "title": "Unsafe",
    "section": "Simply…",
    "text": "Simply…\n\nWrite Rust code normally.\nIf you are doing something unsafe, include it in an unsafe block."
  },
  {
    "objectID": "11_unsafe.rjs.html#unions",
    "href": "11_unsafe.rjs.html#unions",
    "title": "Unsafe",
    "section": "Unions",
    "text": "Unions\nunion MyUnion {\n    f: f32,\n    u: u32,\n}\n\nfn main() {\n    let mut u = MyUnion { f: 0.0 };\n\n    unsafe {\n        println!(\"Bits as float: {}\", u.f);\n        println!(\"Bits as integer: {:#x}\", u.u);\n    }\n\n    u.u = 0x3F800000; // This is the bit pattern for 1.0 in IEEE 754\n\n    unsafe {\n        println!(\"After manual bit update, float is: {}\", u.f);\n    }\n}"
  },
  {
    "objectID": "11_unsafe.rjs.html#dangling",
    "href": "11_unsafe.rjs.html#dangling",
    "title": "Unsafe",
    "section": "Dangling",
    "text": "Dangling\n\nThis worked fine for me, but technically isn’t supported.\n\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}"
  },
  {
    "objectID": "11_unsafe.rjs.html#the-reference",
    "href": "11_unsafe.rjs.html#the-reference",
    "title": "Unsafe",
    "section": "The Reference",
    "text": "The Reference\n\nThe reference is much more… verbose.\nIt’s here\n\n\nBreaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n\n\nViolating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented."
  },
  {
    "objectID": "11_unsafe.rjs.html#previously-in-rust",
    "href": "11_unsafe.rjs.html#previously-in-rust",
    "title": "Unsafe",
    "section": "Previously in Rust",
    "text": "Previously in Rust\n\nSafe Rust ensures that references are always valid\n\nThat is, borrows via &\nThese always have some plausible correct value in them (if the code compiles)"
  },
  {
    "objectID": "11_unsafe.rjs.html#the-frontier",
    "href": "11_unsafe.rjs.html#the-frontier",
    "title": "Unsafe",
    "section": "The Frontier",
    "text": "The Frontier\n\nAt the edge of Safe and Unsafe Rust are raw pointers.\n\nCan be immutable *const T or mutable *mut T.\nVs. C, the asterisk is part of the name and not an operator.\n\nThis is annoying.\n\n\nRaw pointers are inherently unsafe, so they can be created in safe Rust."
  },
  {
    "objectID": "11_unsafe.rjs.html#differences",
    "href": "11_unsafe.rjs.html#differences",
    "title": "Unsafe",
    "section": "Differences",
    "text": "Differences\n\nThese raw pointers:\n\nAre allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location\nAren’t guaranteed to point to valid memory\nAre allowed to be null\nDon’t implement any automatic cleanup"
  },
  {
    "objectID": "11_unsafe.rjs.html#example",
    "href": "11_unsafe.rjs.html#example",
    "title": "Unsafe",
    "section": "Example",
    "text": "Example\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;"
  },
  {
    "objectID": "11_unsafe.rjs.html#this-is-safe",
    "href": "11_unsafe.rjs.html#this-is-safe",
    "title": "Unsafe",
    "section": "This is safe!",
    "text": "This is safe!\n\nThere is nothing unsafe and creating a variable that refers to some value.\nAfter all, what’s the worst thing that can happen?\nThese lines of code only facilitate novel possible ways of interfacing with the underlying data.\nIn this case, we know these pointers are valid and point to 5."
  },
  {
    "objectID": "11_unsafe.rjs.html#casts",
    "href": "11_unsafe.rjs.html#casts",
    "title": "Unsafe",
    "section": "Casts",
    "text": "Casts\n\nWe can get a potentially invalid reference using “casts” with the as keyword.\n\nWe take a numeric value and treat it as a reference.\nThis numerical value represents a location in numerical organized computer memory.\n\n\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\nThis is still safe so far!"
  },
  {
    "objectID": "11_unsafe.rjs.html#dereference",
    "href": "11_unsafe.rjs.html#dereference",
    "title": "Unsafe",
    "section": "Dereference",
    "text": "Dereference\n\nWe now can use the dereference asterisk * operator.\nThis is decidedly unsafe.\n\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n\nUnsafe to Rust but we know it will work."
  },
  {
    "objectID": "11_unsafe.rjs.html#runtime-crash",
    "href": "11_unsafe.rjs.html#runtime-crash",
    "title": "Unsafe",
    "section": "Runtime Crash",
    "text": "Runtime Crash\n\nThis is both unsafe and (almost certainly) won’t work.\n\n\n\nsrc/main.rs\n\nfn main() {\n    let address = 0x0usize;\n    let r = address as *const i32;\n    unsafe {\n        dbg!(*r);\n    }\n}\n\n\nFun exercise: try to take the deferences out of the unsafe block."
  },
  {
    "objectID": "11_unsafe.rjs.html#announcements-1",
    "href": "11_unsafe.rjs.html#announcements-1",
    "title": "Unsafe",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept. at 1440 PT.\nJust a quick demo for HW this week, check it out whenever."
  },
  {
    "objectID": "11_unsafe.html",
    "href": "11_unsafe.html",
    "title": "Unsafe",
    "section": "",
    "text": "Welcome to OS in Rust\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept. at 1440 PT.\nJust a quick demo for HW this week, check it out whenever.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#announcements",
    "href": "11_unsafe.html#announcements",
    "title": "Unsafe",
    "section": "",
    "text": "Welcome to OS in Rust\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept. at 1440 PT.\nJust a quick demo for HW this week, check it out whenever.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#today",
    "href": "11_unsafe.html#today",
    "title": "Unsafe",
    "section": "Today",
    "text": "Today\n\nUnsafe\nUB\nDereferencing",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#the-dark-arts-of-unsafe-rust",
    "href": "11_unsafe.html#the-dark-arts-of-unsafe-rust",
    "title": "Unsafe",
    "section": "The Dark Arts of Unsafe Rust",
    "text": "The Dark Arts of Unsafe Rust\n\nTHE KNOWLEDGE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF UNLEASHING INDESCRIBABLE HORRORS THAT SHATTER YOUR PSYCHE AND SET YOUR MIND ADRIFT IN THE UNKNOWABLY INFINITE COSMOS.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#motivation",
    "href": "11_unsafe.html#motivation",
    "title": "Unsafe",
    "section": "Motivation",
    "text": "Motivation\n\nOften we don’t worry about low-level implementation details.\n\nHow many bits is an integer in Python?\nHow many bits is this array in Rust?\n\n\nlet mut array: [i32; 3] = [0; 3];\n\nWho could possibly care how much space the empty tuple occupies?",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#sometimes-it-matters",
    "href": "11_unsafe.html#sometimes-it-matters",
    "title": "Unsafe",
    "section": "Sometimes it matters…",
    "text": "Sometimes it matters…\n\nThe most common reason is performance, but\nMore importantly, these details can become a matter of correctness when interfacing directly with\n\nhardware,\noperating systems, or\nother languages (by which we mean C)",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#legacy",
    "href": "11_unsafe.html#legacy",
    "title": "Unsafe",
    "section": "Legacy",
    "text": "Legacy\nWhen implementation details start to matter in a safe programming language, programmers usually have three options:\n\nfiddle with the code to “encourage” the compiler/runtime to perform an optimization\nadopt a more unidiomatic or cumbersome design to get the desired implementation\nrewrite the implementation in a language that lets you deal with those details",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#rust-on-c",
    "href": "11_unsafe.html#rust-on-c",
    "title": "Unsafe",
    "section": "Rust on C",
    "text": "Rust on C\n\nUnfortunately, C is incredibly unsafe to use (sometimes for good reason), and this unsafety is magnified when trying to interoperate with another language. Care must be taken to ensure C and the other language agree on what’s happening, and that they don’t step on each other’s toes.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#both-and",
    "href": "11_unsafe.html#both-and",
    "title": "Unsafe",
    "section": "Both, and",
    "text": "Both, and\n\nSo what does this have to do with Rust?\n\nWell, unlike C, Rust is a safe programming language.\nBut, like C, Rust is an unsafe programming language.\n\nMore accurately, Rust contains both a safe and unsafe programming language.\n\n\nRust can be thought of as a combination of two programming languages: Safe Rust and Unsafe Rust.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-rust",
    "href": "11_unsafe.html#safe-rust",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nThe default case\nWhat we’ve used to far, at least officially\n\nYou may have incidentally dabbled in unsafe.\nGood for you.\n\nSafe Rust only really makes one guarantee.\n\n\nRust’s memory safety guarantees enforced at compile time\n\n\nThat is, you can never try to read something that doesn’t exist.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#unsafe-rust",
    "href": "11_unsafe.html#unsafe-rust",
    "title": "Unsafe",
    "section": "Unsafe Rust",
    "text": "Unsafe Rust\n\nSometimes, you may want to have two reference to an object that are both mutable.\n\nFor example, if you are implementing a suffix tree, a task I didn’t assign last term because it was miserable in safe Rust.\n\nSometimes, you want to do so in a way that can’t possibly break anything.\n\nFor example, you may only be using provably correct algorithms (whatever that means).\nBut of course, rustc isn’t a theorem prover…",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#warning",
    "href": "11_unsafe.html#warning",
    "title": "Unsafe",
    "section": "Warning",
    "text": "Warning\n\nUnsafe Rust is, well, not (safe). In fact, Unsafe Rust lets us do some really unsafe things. Things the Rust authors will implore you not to do, but we’ll do anyway.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#true-rust",
    "href": "11_unsafe.html#true-rust",
    "title": "Unsafe",
    "section": "True Rust",
    "text": "True Rust\n\nSafe Rust is the true Rust programming language.\nIf all you do is write Safe Rust, you will never have to worry about type-safety or memory-safety.\nYou will never endure\n\na dangling pointer,\na use-after-free, or\nany other kind of Undefined Behavior (a.k.a. UB).",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#std",
    "href": "11_unsafe.html#std",
    "title": "Unsafe",
    "section": "std",
    "text": "std\n\nThe standard library also gives you enough utilities out of the box that you’ll be able to write high-performance applications and libraries in pure idiomatic Safe Rust.\nAssuming, of course, you are working on a system where std is already implemented.\nNot, you know, writing your own OS or own std.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#twinsies",
    "href": "11_unsafe.html#twinsies",
    "title": "Unsafe",
    "section": "Twinsies",
    "text": "Twinsies\n\nUnsafe Rust is exactly like Safe Rust with all the same rules and semantics.\nIt just lets you do some extra things that are Definitely Not Safe.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#payoffs",
    "href": "11_unsafe.html#payoffs",
    "title": "Unsafe",
    "section": "Payoffs",
    "text": "Payoffs\n\nThe value of this separation is that we gain the benefits of using an unsafe language like C\n\nlow level control over implementation details\n\n…without most (citation needed) of the problems that come with trying to integrate it with a completely different safe language.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-rust-1",
    "href": "11_unsafe.html#safe-rust-1",
    "title": "Unsafe",
    "section": "Safe Rust",
    "text": "Safe Rust\n\nSafe Rust guarantees certain things about your code.\n\nMost of these won’t even make sense to you unless you write C",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-prevents",
    "href": "11_unsafe.html#safe-prevents",
    "title": "Unsafe",
    "section": "Safe Prevents",
    "text": "Safe Prevents\n\nDereferencing (using the * operator on) dangling or unaligned pointers (see below)\nBreaking the “pointer aliasing rules” using & (borrow) and mut\nCalling a function with the wrong call types\nCausing a data race when multithreading\nExecuting code compiled for hardware other than currently hosting the process not support\nProducing invalid values like something other than 0 or 1 for a boolean.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#safe-allows",
    "href": "11_unsafe.html#safe-allows",
    "title": "Unsafe",
    "section": "Safe Allows",
    "text": "Safe Allows\n\nDeadlocks when multithreading\nLeaks of memory and other resources\nExiting without calling destructors\nExposing randomized base addresses through pointer leaks\nInteger overflow (recall SHA wrapping)\nLogic errors\n\nlet val = 7;\nlet val_is_even = if val % 2 == 1 { true } else { false };",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#unsafe-allows",
    "href": "11_unsafe.html#unsafe-allows",
    "title": "Unsafe",
    "section": "Unsafe allows:",
    "text": "Unsafe allows:\n\nDereference a raw pointer.\nCall an unsafe function or method.\nAccess or modify a mutable static variable.\nImplement an unsafe trait.\nAccess fields of unions.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#simply",
    "href": "11_unsafe.html#simply",
    "title": "Unsafe",
    "section": "Simply…",
    "text": "Simply…\n\nWrite Rust code normally.\nIf you are doing something unsafe, include it in an unsafe block.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#unions",
    "href": "11_unsafe.html#unions",
    "title": "Unsafe",
    "section": "Unions",
    "text": "Unions\nunion MyUnion {\n    f: f32,\n    u: u32,\n}\n\nfn main() {\n    let mut u = MyUnion { f: 0.0 };\n\n    unsafe {\n        println!(\"Bits as float: {}\", u.f);\n        println!(\"Bits as integer: {:#x}\", u.u);\n    }\n\n    u.u = 0x3F800000; // This is the bit pattern for 1.0 in IEEE 754\n\n    unsafe {\n        println!(\"After manual bit update, float is: {}\", u.f);\n    }\n}",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#dangling",
    "href": "11_unsafe.html#dangling",
    "title": "Unsafe",
    "section": "Dangling",
    "text": "Dangling\n\nThis worked fine for me, but technically isn’t supported.\n\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#the-reference",
    "href": "11_unsafe.html#the-reference",
    "title": "Unsafe",
    "section": "The Reference",
    "text": "The Reference\n\nThe reference is much more… verbose.\nIt’s here\n\n\nBreaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n\n\nViolating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#previously-in-rust",
    "href": "11_unsafe.html#previously-in-rust",
    "title": "Unsafe",
    "section": "Previously in Rust",
    "text": "Previously in Rust\n\nSafe Rust ensures that references are always valid\n\nThat is, borrows via &\nThese always have some plausible correct value in them (if the code compiles)",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#the-frontier",
    "href": "11_unsafe.html#the-frontier",
    "title": "Unsafe",
    "section": "The Frontier",
    "text": "The Frontier\n\nAt the edge of Safe and Unsafe Rust are raw pointers.\n\nCan be immutable *const T or mutable *mut T.\nVs. C, the asterisk is part of the name and not an operator.\n\nThis is annoying.\n\n\nRaw pointers are inherently unsafe, so they can be created in safe Rust.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#differences",
    "href": "11_unsafe.html#differences",
    "title": "Unsafe",
    "section": "Differences",
    "text": "Differences\n\nThese raw pointers:\n\nAre allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location\nAren’t guaranteed to point to valid memory\nAre allowed to be null\nDon’t implement any automatic cleanup",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#example",
    "href": "11_unsafe.html#example",
    "title": "Unsafe",
    "section": "Example",
    "text": "Example\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#this-is-safe",
    "href": "11_unsafe.html#this-is-safe",
    "title": "Unsafe",
    "section": "This is safe!",
    "text": "This is safe!\n\nThere is nothing unsafe and creating a variable that refers to some value.\nAfter all, what’s the worst thing that can happen?\nThese lines of code only facilitate novel possible ways of interfacing with the underlying data.\nIn this case, we know these pointers are valid and point to 5.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#casts",
    "href": "11_unsafe.html#casts",
    "title": "Unsafe",
    "section": "Casts",
    "text": "Casts\n\nWe can get a potentially invalid reference using “casts” with the as keyword.\n\nWe take a numeric value and treat it as a reference.\nThis numerical value represents a location in numerical organized computer memory.\n\n\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\nThis is still safe so far!",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#dereference",
    "href": "11_unsafe.html#dereference",
    "title": "Unsafe",
    "section": "Dereference",
    "text": "Dereference\n\nWe now can use the dereference asterisk * operator.\nThis is decidedly unsafe.\n\n    let mut num = 5;\n\n    let r1 = &raw const num;\n    let r2 = &raw mut num;\n\n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n\nUnsafe to Rust but we know it will work.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#runtime-crash",
    "href": "11_unsafe.html#runtime-crash",
    "title": "Unsafe",
    "section": "Runtime Crash",
    "text": "Runtime Crash\n\nThis is both unsafe and (almost certainly) won’t work.\n\n\n\nsrc/main.rs\n\nfn main() {\n    let address = 0x0usize;\n    let r = address as *const i32;\n    unsafe {\n        dbg!(*r);\n    }\n}\n\n\nFun exercise: try to take the deferences out of the unsafe block.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "11_unsafe.html#announcements-1",
    "href": "11_unsafe.html#announcements-1",
    "title": "Unsafe",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nwc ongoing.\nDue Friday, 5 Sept. at 1440 PT.\nJust a quick demo for HW this week, check it out whenever.",
    "crumbs": [
      "Unsafe"
    ]
  },
  {
    "objectID": "20_os.rjs.html#announcements",
    "href": "20_os.rjs.html#announcements",
    "title": "OS",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to OS in Rust\n\nActual OS week.\n\nAction Items:\n\nFinish working through split_at\n\nForm a strong opinion on assert\nGood anecdote for job interviews.\n\nNominally ready for next homework after this lecture.\n\nCan wait for lab/section."
  },
  {
    "objectID": "20_os.rjs.html#today",
    "href": "20_os.rjs.html#today",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages"
  },
  {
    "objectID": "20_os.rjs.html#citations",
    "href": "20_os.rjs.html#citations",
    "title": "OS",
    "section": "Citations",
    "text": "Citations\n\nBorrowed a bit from:\n\nMIT via UIC\nMIT via OCW"
  },
  {
    "objectID": "20_os.rjs.html#arriving-at-os",
    "href": "20_os.rjs.html#arriving-at-os",
    "title": "OS",
    "section": "Arriving at OS",
    "text": "Arriving at OS\n\nWe can arrive at OS from two ways:\n\nWe can look at physical hardware an infer the need for a control system.\nWe can look at formal descriptions of computing, such as automata, and infer the need for abstractions to practically use the system."
  },
  {
    "objectID": "20_os.rjs.html#the-device",
    "href": "20_os.rjs.html#the-device",
    "title": "OS",
    "section": "The Device",
    "text": "The Device\n\nWe imagine some minimal device.\n\nWhat are the minimum requirements to be a computer?"
  },
  {
    "objectID": "20_os.rjs.html#architecture---alu",
    "href": "20_os.rjs.html#architecture---alu",
    "title": "OS",
    "section": "Architecture - ALU",
    "text": "Architecture - ALU\n\nWe imagine some minimal device.\n\nIt contains an arithmetic/logic unit (ALU).\n\nCan perform e.g. logical AND, bitwise AND, and numeric ADD\nCan load/store numeric values to/from numeric addresses"
  },
  {
    "objectID": "20_os.rjs.html#architecture---mmu",
    "href": "20_os.rjs.html#architecture---mmu",
    "title": "OS",
    "section": "Architecture - MMU",
    "text": "Architecture - MMU\n\nWe imagine some minimal device.\n\nIt contains “memory”, perhaps via a memory management unit (MMU)\n\nPersists numeric values associated with numeric addresses\nPhysically separated from the ALU\nGeniuses will say this is key-value storage"
  },
  {
    "objectID": "20_os.rjs.html#picture",
    "href": "20_os.rjs.html#picture",
    "title": "OS",
    "section": "Picture",
    "text": "Picture\n\n\n\n\n\n\n\ngraphgraph\n\n\nALU\n\nALU\n\n\n\nALU-&gt;ALU\n\n\nplus\n\n\n\nMMU\n\nMMU\n\n\n\nALU-&gt;MMU\n\n\nsave\n\n\n\nMMU-&gt;ALU\n\n\nload"
  },
  {
    "objectID": "20_os.rjs.html#architecture-1",
    "href": "20_os.rjs.html#architecture-1",
    "title": "OS",
    "section": "Architecture",
    "text": "Architecture\n\nThis is the now-legendary Von Neumann architecture."
  },
  {
    "objectID": "20_os.rjs.html#von-neumann-formally",
    "href": "20_os.rjs.html#von-neumann-formally",
    "title": "OS",
    "section": "Von Neumann, Formally",
    "text": "Von Neumann, Formally\n\nA central arithmetic unit to perform arithmetic operations;\nA central control unit to sequence operations performed by the machine;\nMemory that stores data and instructions;\nAn “outside recording medium” to store input to and output from the machine;\nInput and output mechanisms to transfer data between the memory and the outside recording medium."
  },
  {
    "objectID": "20_os.rjs.html#competing-formulation",
    "href": "20_os.rjs.html#competing-formulation",
    "title": "OS",
    "section": "Competing Formulation",
    "text": "Competing Formulation\nThe competing formulation known as the Harvard architecture differed in that information describing actions (say, executables or “stored memory programs” or “instructions”) and information for read-write (say data files or just “data”) had distinct storage mediums.\n\nAs far as I know, none of these were ever made.\nTheoretical idea."
  },
  {
    "objectID": "20_os.rjs.html#harvard-architecture",
    "href": "20_os.rjs.html#harvard-architecture",
    "title": "OS",
    "section": "Harvard Architecture",
    "text": "Harvard Architecture"
  },
  {
    "objectID": "20_os.rjs.html#historical-use-case",
    "href": "20_os.rjs.html#historical-use-case",
    "title": "OS",
    "section": "Historical use case",
    "text": "Historical use case\n\nHistorical computing devices had no onboard storage and programs lived on e.g. external tapes.\n\nThe Harvard architecture is a helpful model in this case.\n\nToday, everything lives on a SSD (OS, browser, audo/video files, debug logs, etc.)\n\nHence Von Neumann"
  },
  {
    "objectID": "20_os.rjs.html#von-neumann---aside",
    "href": "20_os.rjs.html#von-neumann---aside",
    "title": "OS",
    "section": "Von Neumann - Aside",
    "text": "Von Neumann - Aside\n\n\n\nBe advised this is a Manhattan Project member and form your own opinion about that."
  },
  {
    "objectID": "20_os.rjs.html#hardware-doesnt-matter",
    "href": "20_os.rjs.html#hardware-doesnt-matter",
    "title": "OS",
    "section": "Hardware “doesn’t matter”",
    "text": "Hardware “doesn’t matter”\n\nWe can regard as a historical accident that hardware exists in any particular form.\n\nPerhaps the first computers could’ve been biological vs. mechanical vs. electric.\n\nWe then regard the automata, principly the Turing Machine, as ground truth.\n\nTMs are out-of-scope for this class but probably should be a required topic in a post-Algorithms class, someday…\nRead more"
  },
  {
    "objectID": "20_os.rjs.html#thinking-about-a-tm",
    "href": "20_os.rjs.html#thinking-about-a-tm",
    "title": "OS",
    "section": "Thinking about a TM",
    "text": "Thinking about a TM\n\n\n\n\nHead can read and write\nHead is two-way\nTape is infinite\nInfinitely many blanks(0) follow input\nCan accept/reject at any time"
  },
  {
    "objectID": "20_os.rjs.html#vs.-hardware",
    "href": "20_os.rjs.html#vs.-hardware",
    "title": "OS",
    "section": "Vs. Hardware",
    "text": "Vs. Hardware\n\nThe TM assumes infinite memory\n\nNot a big deal, you’ll never actually use infinite memory.\n\nThe TM makes no considerations of performance\n\nTapes are slower than wires, but perhaps easier to imagine.\n\nThe TM does not necessarily use binary\n\nBut then again, before-Turing, neither did computers…"
  },
  {
    "objectID": "20_os.rjs.html#say-we-build-a-tm",
    "href": "20_os.rjs.html#say-we-build-a-tm",
    "title": "OS",
    "section": "Say we build a TM",
    "text": "Say we build a TM\n\nWell, someone we have to model an “infinite tape” of memory.\n\nPerhaps by… creating a bijection to the natural numbers.\nWe could then have numeric locations on the type correspond to written values (which may be numeric or linguistic)\nWait that is the same key-value storage as the MMU."
  },
  {
    "objectID": "20_os.rjs.html#all-roads",
    "href": "20_os.rjs.html#all-roads",
    "title": "OS",
    "section": "All Roads",
    "text": "All Roads\n\n…lead to a series of abstractions allowing higher-level users to use, but not implement, memory.\n\n\n\n\n\n\n\n\nG\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4"
  },
  {
    "objectID": "20_os.rjs.html#different-topics",
    "href": "20_os.rjs.html#different-topics",
    "title": "OS",
    "section": "Different Topics",
    "text": "Different Topics\n\nAs we layer abstractions, writing code is more efficent and running code is less efficient.\n\nUntil mature technologies outcompete humans.\n\n\n\n\n\n\n\n\n\nG\n\n\nm1\n\nElectrical\nEngineering\n\n\n\nm2\n\nArchitecture\nand OSes\n\n\n\nm1-&gt;m2\n\n\n\n\n\nm3\n\nCompilers\n(or std)\n\n\n\nm2-&gt;m3\n\n\n\n\n\nm4\n\nScripting\nLanguages\n\n\n\nm3-&gt;m4\n\n\n\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4"
  },
  {
    "objectID": "20_os.rjs.html#bus-1",
    "href": "20_os.rjs.html#bus-1",
    "title": "OS",
    "section": "Bus",
    "text": "Bus\n\nIn computer architecture, a bus (historically also called a data highway or databus) is a communication system that transfers data between components inside a computer or between computers. It encompasses both hardware (e.g., wires, optical fiber) and software, including communication protocols. At its core, a bus is a shared physical pathway, typically composed of wires, traces on a circuit board, or busbars, that allows multiple devices to communicate."
  },
  {
    "objectID": "20_os.rjs.html#shorter",
    "href": "20_os.rjs.html#shorter",
    "title": "OS",
    "section": "Shorter",
    "text": "Shorter\n\nA bus is a bundle of wires that transfers bits.\n\n\n\n\n\n\n\n\nG\n\n\ncpu\n\nCPU\n\n\n\nbus_middle\n\n\n\n\ncpu-&gt;bus_middle\n\n\n\n\n\nbus_right\n\n\n\n\nbus_middle-&gt;bus_right\n\n\n\n\nbus_left\n\n\n\n\nbus_left-&gt;bus_middle\n\n\n\n\nram\n\nRAM\n\n\n\nbus_left-&gt;ram\n\n\n\n\n\nio\n\nI/O\n\n\n\nbus_right-&gt;io"
  },
  {
    "objectID": "20_os.rjs.html#i-imagine",
    "href": "20_os.rjs.html#i-imagine",
    "title": "OS",
    "section": "I imagine…",
    "text": "I imagine…\n\nTwo registers (an ordered collection of bits) are populated by some device on a bus.\n\nOne for a numeric value.\nOne for a numeric address."
  },
  {
    "objectID": "20_os.rjs.html#i-imagine-1",
    "href": "20_os.rjs.html#i-imagine-1",
    "title": "OS",
    "section": "I imagine…",
    "text": "I imagine…\n\nThat device writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they “own” the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever."
  },
  {
    "objectID": "20_os.rjs.html#within-a-device",
    "href": "20_os.rjs.html#within-a-device",
    "title": "OS",
    "section": "Within a Device",
    "text": "Within a Device\n\nWithin devices, numerical values are separated spatially.\n\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0"
  },
  {
    "objectID": "20_os.rjs.html#within-a-bus",
    "href": "20_os.rjs.html#within-a-bus",
    "title": "OS",
    "section": "Within a Bus",
    "text": "Within a Bus\n\nOn the bus, the wire is either, say, “high” or “low” and these values are interpreted as “one” or “zero”.\n\nWe term this “digital”\n\n\n\ncomposed of data in the form of especially binary digits"
  },
  {
    "objectID": "20_os.rjs.html#signal-processing",
    "href": "20_os.rjs.html#signal-processing",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nE.g. sine wave with some recording window.\n\n Source"
  },
  {
    "objectID": "20_os.rjs.html#signal-processing-1",
    "href": "20_os.rjs.html#signal-processing-1",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nOut of scope\n\nPhysics/Electrical Engineering topic\nSeen in Data in the Cosmos and Computer Vision\nLudicrously radical\n\nWe handwave it here, and only introduce so you understand what the hardware/OS has to deal with."
  },
  {
    "objectID": "20_os.rjs.html#given-a-bus",
    "href": "20_os.rjs.html#given-a-bus",
    "title": "OS",
    "section": "Given a bus",
    "text": "Given a bus\n\nSay we have both a keyboard and an MMU on a bus with our ALU/CPU\n\nSay I input d, ASCII 100/0x64, on my keyboard\nThe keyboard broadcasts onto bus\nThe ALU and MMU read it\n\nHow is the signal interpreted?"
  },
  {
    "objectID": "20_os.rjs.html#throwback",
    "href": "20_os.rjs.html#throwback",
    "title": "OS",
    "section": "Throwback",
    "text": "Throwback\n\nDevice writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they “own” the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever."
  },
  {
    "objectID": "20_os.rjs.html#so",
    "href": "20_os.rjs.html#so",
    "title": "OS",
    "section": "So…",
    "text": "So…\n\nThe keyboard doesn’t just blast a `0b1100100’ onto bus.\nRather, it broadcasts some pre-determined “address” corresponding to keyboard input.\n\nThe ALU sees this and knows to prepare a register to store the incoming value.\nThe MMU sees this and knows to hit a snooze.\n\nSo the keyboard prepends the numeric value with a numeric address.\n\nThis is the importance of an address space."
  },
  {
    "objectID": "20_os.rjs.html#the-big-idea",
    "href": "20_os.rjs.html#the-big-idea",
    "title": "OS",
    "section": "The Big Idea",
    "text": "The Big Idea\n\nImagine the bus is an array.\nEach array element is some word size, say 8 (cringe), 32 (mid), 64 (based), or 128 (excessive) bits.\nEach array element has some numeric address."
  },
  {
    "objectID": "20_os.rjs.html#for-the-alu",
    "href": "20_os.rjs.html#for-the-alu",
    "title": "OS",
    "section": "For the ALU",
    "text": "For the ALU\n\nWhen the ALU wants to write to memory\n\nAddress the MMU, either as\n\nA region as large as physical memory\nOne address then a key-value pair\n\nThe ALU writes a value to an address\n\nThe MMU sees this on bus and acts accordingly\nThe keyboard does whatever"
  },
  {
    "objectID": "20_os.rjs.html#wrinkles",
    "href": "20_os.rjs.html#wrinkles",
    "title": "OS",
    "section": "Wrinkles",
    "text": "Wrinkles\n\nSounds easy?\nWe can optimize"
  },
  {
    "objectID": "20_os.rjs.html#gaps",
    "href": "20_os.rjs.html#gaps",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\nUsually address space is much larger than RAM\nAddresses that can be accessed are referred to as “mapped”\nAnd holes that can’t be accessed are “unmapped”\nWhat happens if the CPU loads or stores to an unmapped region"
  },
  {
    "objectID": "20_os.rjs.html#gaps-1",
    "href": "20_os.rjs.html#gaps-1",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\n0x0C\n\n0x08\n\n0x04\n\n0x00\n\n\n\nnode1\n\nMonitor\n\n \n\nGPU\n\nMemory\n\nKeyboard\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1"
  },
  {
    "objectID": "20_os.rjs.html#permissions",
    "href": "20_os.rjs.html#permissions",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\nUsually as RWX\n\nRead\nWrite\nEXecute\nThe dastardly von Neumann model rears its ugly head etc.\n\nWhy have these, and\nWhat if they are violated"
  },
  {
    "objectID": "20_os.rjs.html#permissions-1",
    "href": "20_os.rjs.html#permissions-1",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\n.ini\n\n.txt\n\n.exe\n\n.log\n\n.sh\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1"
  },
  {
    "objectID": "20_os.rjs.html#multiple-devices",
    "href": "20_os.rjs.html#multiple-devices",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\nTreat code and data as the same.\nBe unfathomably based.\nThe keyboard is just memory.\nSo is the CPU/GPU\nSo is the internet (Network interface controller)\n\nWe can execute the internet?"
  },
  {
    "objectID": "20_os.rjs.html#multiple-devices-1",
    "href": "20_os.rjs.html#multiple-devices-1",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\nI/O\n\nkeys\n\nMMU\n\n.txt\n\nMMU\n\n.exe\n\nNIC\n\n.htm\n\nNIC\n\n.jsx\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1"
  },
  {
    "objectID": "20_os.rjs.html#further",
    "href": "20_os.rjs.html#further",
    "title": "OS",
    "section": "Further",
    "text": "Further\n\nPhysical vs. virtual address\n\nUsually computers can describe more memory locations than the MMU can retain.\n\nCaching\n\nUsually read/write is slow but repeated, so save common requests to deload devices and bus\n\nBlock size\n\nBits and even words are are two small, usually pages (4KB) or blocks (cloud scale)"
  },
  {
    "objectID": "20_os.rjs.html#recall",
    "href": "20_os.rjs.html#recall",
    "title": "OS",
    "section": "Recall",
    "text": "Recall\n\nYou have already been a client of the stack/heap\n\nIn C\nIn Rust\n\nQuoth me:\n\n\nIt’s the OS’s problem. And therefore our problem next term."
  },
  {
    "objectID": "20_os.rjs.html#python",
    "href": "20_os.rjs.html#python",
    "title": "OS",
    "section": "Python",
    "text": "Python\nimport ctypes\nimport gc \n\ndi = lambda obj_id : _ctypes.PyObj_FromPtr(obj_id)\nfree = gc.collect"
  },
  {
    "objectID": "20_os.rjs.html#rust",
    "href": "20_os.rjs.html#rust",
    "title": "OS",
    "section": "Rust",
    "text": "Rust\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}"
  },
  {
    "objectID": "20_os.rjs.html#c",
    "href": "20_os.rjs.html#c",
    "title": "OS",
    "section": "C",
    "text": "C\n#include &lt;stdlib.h&gt;\n\nvoid main() {\n        int *p = (int *)malloc(sizeof(int));\n        int *q = (int *)malloc(sizeof(int));\n        free(p);\n        p = q;\n}"
  },
  {
    "objectID": "20_os.rjs.html#all-of-these",
    "href": "20_os.rjs.html#all-of-these",
    "title": "OS",
    "section": "All of these…",
    "text": "All of these…\n\nAre your problem now.\nThere is also a stack (less theoretically complicated, more implementation complicated) which we have also covered.\nOn to the lab/homework!"
  },
  {
    "objectID": "20_os.rjs.html#today-1",
    "href": "20_os.rjs.html#today-1",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages"
  },
  {
    "objectID": "20_os.html",
    "href": "20_os.html",
    "title": "OS",
    "section": "",
    "text": "Welcome to OS in Rust\n\nActual OS week.\n\nAction Items:\n\nFinish working through split_at\n\nForm a strong opinion on assert\nGood anecdote for job interviews.\n\nNominally ready for next homework after this lecture.\n\nCan wait for lab/section.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#announcements",
    "href": "20_os.html#announcements",
    "title": "OS",
    "section": "",
    "text": "Welcome to OS in Rust\n\nActual OS week.\n\nAction Items:\n\nFinish working through split_at\n\nForm a strong opinion on assert\nGood anecdote for job interviews.\n\nNominally ready for next homework after this lecture.\n\nCan wait for lab/section.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#today",
    "href": "20_os.html#today",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#citations",
    "href": "20_os.html#citations",
    "title": "OS",
    "section": "Citations",
    "text": "Citations\n\nBorrowed a bit from:\n\nMIT via UIC\nMIT via OCW",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#arriving-at-os",
    "href": "20_os.html#arriving-at-os",
    "title": "OS",
    "section": "Arriving at OS",
    "text": "Arriving at OS\n\nWe can arrive at OS from two ways:\n\nWe can look at physical hardware an infer the need for a control system.\nWe can look at formal descriptions of computing, such as automata, and infer the need for abstractions to practically use the system.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#the-device",
    "href": "20_os.html#the-device",
    "title": "OS",
    "section": "The Device",
    "text": "The Device\n\nWe imagine some minimal device.\n\nWhat are the minimum requirements to be a computer?",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#architecture---alu",
    "href": "20_os.html#architecture---alu",
    "title": "OS",
    "section": "Architecture - ALU",
    "text": "Architecture - ALU\n\nWe imagine some minimal device.\n\nIt contains an arithmetic/logic unit (ALU).\n\nCan perform e.g. logical AND, bitwise AND, and numeric ADD\nCan load/store numeric values to/from numeric addresses",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#architecture---mmu",
    "href": "20_os.html#architecture---mmu",
    "title": "OS",
    "section": "Architecture - MMU",
    "text": "Architecture - MMU\n\nWe imagine some minimal device.\n\nIt contains “memory”, perhaps via a memory management unit (MMU)\n\nPersists numeric values associated with numeric addresses\nPhysically separated from the ALU\nGeniuses will say this is key-value storage",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#picture",
    "href": "20_os.html#picture",
    "title": "OS",
    "section": "Picture",
    "text": "Picture\n\n\n\n\n\n\n\ngraphgraph\n\n\nALU\n\nALU\n\n\n\nALU-&gt;ALU\n\n\nplus\n\n\n\nMMU\n\nMMU\n\n\n\nALU-&gt;MMU\n\n\nsave\n\n\n\nMMU-&gt;ALU\n\n\nload",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#architecture-1",
    "href": "20_os.html#architecture-1",
    "title": "OS",
    "section": "Architecture",
    "text": "Architecture\n\nThis is the now-legendary Von Neumann architecture.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#von-neumann-formally",
    "href": "20_os.html#von-neumann-formally",
    "title": "OS",
    "section": "Von Neumann, Formally",
    "text": "Von Neumann, Formally\n\nA central arithmetic unit to perform arithmetic operations;\nA central control unit to sequence operations performed by the machine;\nMemory that stores data and instructions;\nAn “outside recording medium” to store input to and output from the machine;\nInput and output mechanisms to transfer data between the memory and the outside recording medium.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#competing-formulation",
    "href": "20_os.html#competing-formulation",
    "title": "OS",
    "section": "Competing Formulation",
    "text": "Competing Formulation\nThe competing formulation known as the Harvard architecture differed in that information describing actions (say, executables or “stored memory programs” or “instructions”) and information for read-write (say data files or just “data”) had distinct storage mediums.\n\nAs far as I know, none of these were ever made.\nTheoretical idea.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#harvard-architecture",
    "href": "20_os.html#harvard-architecture",
    "title": "OS",
    "section": "Harvard Architecture",
    "text": "Harvard Architecture",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#historical-use-case",
    "href": "20_os.html#historical-use-case",
    "title": "OS",
    "section": "Historical use case",
    "text": "Historical use case\n\nHistorical computing devices had no onboard storage and programs lived on e.g. external tapes.\n\nThe Harvard architecture is a helpful model in this case.\n\nToday, everything lives on a SSD (OS, browser, audo/video files, debug logs, etc.)\n\nHence Von Neumann",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#von-neumann---aside",
    "href": "20_os.html#von-neumann---aside",
    "title": "OS",
    "section": "Von Neumann - Aside",
    "text": "Von Neumann - Aside\n\n\n\nBe advised this is a Manhattan Project member and form your own opinion about that.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#hardware-doesnt-matter",
    "href": "20_os.html#hardware-doesnt-matter",
    "title": "OS",
    "section": "Hardware “doesn’t matter”",
    "text": "Hardware “doesn’t matter”\n\nWe can regard as a historical accident that hardware exists in any particular form.\n\nPerhaps the first computers could’ve been biological vs. mechanical vs. electric.\n\nWe then regard the automata, principly the Turing Machine, as ground truth.\n\nTMs are out-of-scope for this class but probably should be a required topic in a post-Algorithms class, someday…\nRead more",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#thinking-about-a-tm",
    "href": "20_os.html#thinking-about-a-tm",
    "title": "OS",
    "section": "Thinking about a TM",
    "text": "Thinking about a TM\n\n\n\n\nHead can read and write\nHead is two-way\nTape is infinite\nInfinitely many blanks(0) follow input\nCan accept/reject at any time",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#vs.-hardware",
    "href": "20_os.html#vs.-hardware",
    "title": "OS",
    "section": "Vs. Hardware",
    "text": "Vs. Hardware\n\nThe TM assumes infinite memory\n\nNot a big deal, you’ll never actually use infinite memory.\n\nThe TM makes no considerations of performance\n\nTapes are slower than wires, but perhaps easier to imagine.\n\nThe TM does not necessarily use binary\n\nBut then again, before-Turing, neither did computers…",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#say-we-build-a-tm",
    "href": "20_os.html#say-we-build-a-tm",
    "title": "OS",
    "section": "Say we build a TM",
    "text": "Say we build a TM\n\nWell, someone we have to model an “infinite tape” of memory.\n\nPerhaps by… creating a bijection to the natural numbers.\nWe could then have numeric locations on the type correspond to written values (which may be numeric or linguistic)\nWait that is the same key-value storage as the MMU.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#all-roads",
    "href": "20_os.html#all-roads",
    "title": "OS",
    "section": "All Roads",
    "text": "All Roads\n\n…lead to a series of abstractions allowing higher-level users to use, but not implement, memory.\n\n\n\n\n\n\n\n\nG\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#different-topics",
    "href": "20_os.html#different-topics",
    "title": "OS",
    "section": "Different Topics",
    "text": "Different Topics\n\nAs we layer abstractions, writing code is more efficent and running code is less efficient.\n\nUntil mature technologies outcompete humans.\n\n\n\n\n\n\n\n\n\nG\n\n\nm1\n\nElectrical\nEngineering\n\n\n\nm2\n\nArchitecture\nand OSes\n\n\n\nm1-&gt;m2\n\n\n\n\n\nm3\n\nCompilers\n(or std)\n\n\n\nm2-&gt;m3\n\n\n\n\n\nm4\n\nScripting\nLanguages\n\n\n\nm3-&gt;m4\n\n\n\n\n\nn1\n\nPhysical\nMemory\n\n\n\nn2\n\nAddress\nSpaces\n\n\n\nn1-&gt;n2\n\n\n\n\n\nn3\n\nStack and\nHeap\n\n\n\nn2-&gt;n3\n\n\n\n\n\nn4\n\nGarbage\nCollection\n\n\n\nn3-&gt;n4",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#bus-1",
    "href": "20_os.html#bus-1",
    "title": "OS",
    "section": "Bus",
    "text": "Bus\n\nIn computer architecture, a bus (historically also called a data highway or databus) is a communication system that transfers data between components inside a computer or between computers. It encompasses both hardware (e.g., wires, optical fiber) and software, including communication protocols. At its core, a bus is a shared physical pathway, typically composed of wires, traces on a circuit board, or busbars, that allows multiple devices to communicate.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#shorter",
    "href": "20_os.html#shorter",
    "title": "OS",
    "section": "Shorter",
    "text": "Shorter\n\nA bus is a bundle of wires that transfers bits.\n\n\n\n\n\n\n\n\nG\n\n\ncpu\n\nCPU\n\n\n\nbus_middle\n\n\n\n\ncpu-&gt;bus_middle\n\n\n\n\n\nbus_right\n\n\n\n\nbus_middle-&gt;bus_right\n\n\n\n\nbus_left\n\n\n\n\nbus_left-&gt;bus_middle\n\n\n\n\nram\n\nRAM\n\n\n\nbus_left-&gt;ram\n\n\n\n\n\nio\n\nI/O\n\n\n\nbus_right-&gt;io",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#i-imagine",
    "href": "20_os.html#i-imagine",
    "title": "OS",
    "section": "I imagine…",
    "text": "I imagine…\n\nTwo registers (an ordered collection of bits) are populated by some device on a bus.\n\nOne for a numeric value.\nOne for a numeric address.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#i-imagine-1",
    "href": "20_os.html#i-imagine-1",
    "title": "OS",
    "section": "I imagine…",
    "text": "I imagine…\n\nThat device writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they “own” the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#within-a-device",
    "href": "20_os.html#within-a-device",
    "title": "OS",
    "section": "Within a Device",
    "text": "Within a Device\n\nWithin devices, numerical values are separated spatially.\n\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#within-a-bus",
    "href": "20_os.html#within-a-bus",
    "title": "OS",
    "section": "Within a Bus",
    "text": "Within a Bus\n\nOn the bus, the wire is either, say, “high” or “low” and these values are interpreted as “one” or “zero”.\n\nWe term this “digital”\n\n\n\ncomposed of data in the form of especially binary digits",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#signal-processing",
    "href": "20_os.html#signal-processing",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nE.g. sine wave with some recording window.\n\n Source",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#signal-processing-1",
    "href": "20_os.html#signal-processing-1",
    "title": "OS",
    "section": "Signal Processing",
    "text": "Signal Processing\n\nOut of scope\n\nPhysics/Electrical Engineering topic\nSeen in Data in the Cosmos and Computer Vision\nLudicrously radical\n\nWe handwave it here, and only introduce so you understand what the hardware/OS has to deal with.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#given-a-bus",
    "href": "20_os.html#given-a-bus",
    "title": "OS",
    "section": "Given a bus",
    "text": "Given a bus\n\nSay we have both a keyboard and an MMU on a bus with our ALU/CPU\n\nSay I input d, ASCII 100/0x64, on my keyboard\nThe keyboard broadcasts onto bus\nThe ALU and MMU read it\n\nHow is the signal interpreted?",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#throwback",
    "href": "20_os.html#throwback",
    "title": "OS",
    "section": "Throwback",
    "text": "Throwback\n\nDevice writes:\n\nA numerical address to bus\n\nAll other devices listen, and see if they “own” the address\n\nA numerical value to the bus\n\nThe relevant device records the bits to an internal register\n\nThen saves or loads or displays or whatever.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#so",
    "href": "20_os.html#so",
    "title": "OS",
    "section": "So…",
    "text": "So…\n\nThe keyboard doesn’t just blast a `0b1100100’ onto bus.\nRather, it broadcasts some pre-determined “address” corresponding to keyboard input.\n\nThe ALU sees this and knows to prepare a register to store the incoming value.\nThe MMU sees this and knows to hit a snooze.\n\nSo the keyboard prepends the numeric value with a numeric address.\n\nThis is the importance of an address space.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#the-big-idea",
    "href": "20_os.html#the-big-idea",
    "title": "OS",
    "section": "The Big Idea",
    "text": "The Big Idea\n\nImagine the bus is an array.\nEach array element is some word size, say 8 (cringe), 32 (mid), 64 (based), or 128 (excessive) bits.\nEach array element has some numeric address.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#for-the-alu",
    "href": "20_os.html#for-the-alu",
    "title": "OS",
    "section": "For the ALU",
    "text": "For the ALU\n\nWhen the ALU wants to write to memory\n\nAddress the MMU, either as\n\nA region as large as physical memory\nOne address then a key-value pair\n\nThe ALU writes a value to an address\n\nThe MMU sees this on bus and acts accordingly\nThe keyboard does whatever",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#wrinkles",
    "href": "20_os.html#wrinkles",
    "title": "OS",
    "section": "Wrinkles",
    "text": "Wrinkles\n\nSounds easy?\nWe can optimize",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#gaps",
    "href": "20_os.html#gaps",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\nUsually address space is much larger than RAM\nAddresses that can be accessed are referred to as “mapped”\nAnd holes that can’t be accessed are “unmapped”\nWhat happens if the CPU loads or stores to an unmapped region",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#gaps-1",
    "href": "20_os.html#gaps-1",
    "title": "OS",
    "section": "Gaps",
    "text": "Gaps\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\n0x0C\n\n0x08\n\n0x04\n\n0x00\n\n\n\nnode1\n\nMonitor\n\n \n\nGPU\n\nMemory\n\nKeyboard\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#permissions",
    "href": "20_os.html#permissions",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\nUsually as RWX\n\nRead\nWrite\nEXecute\nThe dastardly von Neumann model rears its ugly head etc.\n\nWhy have these, and\nWhat if they are violated",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#permissions-1",
    "href": "20_os.html#permissions-1",
    "title": "OS",
    "section": "Permissions",
    "text": "Permissions\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\n.ini\n\n.txt\n\n.exe\n\n.log\n\n.sh\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#multiple-devices",
    "href": "20_os.html#multiple-devices",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\nTreat code and data as the same.\nBe unfathomably based.\nThe keyboard is just memory.\nSo is the CPU/GPU\nSo is the internet (Network interface controller)\n\nWe can execute the internet?",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#multiple-devices-1",
    "href": "20_os.html#multiple-devices-1",
    "title": "OS",
    "section": "Multiple Devices",
    "text": "Multiple Devices\n\n\n\n\n\n\n\nG\n\n\nnode0\n\n0x10\n\nR__\n\n0x0C\n\nRW_\n\n0x08\n\nR_X\n\n0x04\n\nR__\n\n0x00\n\nRWX\n\n\n\nnode1\n\nI/O\n\nkeys\n\nMMU\n\n.txt\n\nMMU\n\n.exe\n\nNIC\n\n.htm\n\nNIC\n\n.jsx\n\n\n\nnode0:5-&gt;node1:5\n\n\n\n\n\nnode0:4-&gt;node1:4\n\n\n\n\n\nnode0:3-&gt;node1:3\n\n\n\n\n\nnode0:2-&gt;node1:2\n\n\n\n\n\nnode0:1-&gt;node1:1",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#further",
    "href": "20_os.html#further",
    "title": "OS",
    "section": "Further",
    "text": "Further\n\nPhysical vs. virtual address\n\nUsually computers can describe more memory locations than the MMU can retain.\n\nCaching\n\nUsually read/write is slow but repeated, so save common requests to deload devices and bus\n\nBlock size\n\nBits and even words are are two small, usually pages (4KB) or blocks (cloud scale)",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#recall",
    "href": "20_os.html#recall",
    "title": "OS",
    "section": "Recall",
    "text": "Recall\n\nYou have already been a client of the stack/heap\n\nIn C\nIn Rust\n\nQuoth me:\n\n\nIt’s the OS’s problem. And therefore our problem next term.",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#python",
    "href": "20_os.html#python",
    "title": "OS",
    "section": "Python",
    "text": "Python\nimport ctypes\nimport gc \n\ndi = lambda obj_id : _ctypes.PyObj_FromPtr(obj_id)\nfree = gc.collect",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#rust",
    "href": "20_os.html#rust",
    "title": "OS",
    "section": "Rust",
    "text": "Rust\n\n\nsrc/main.rs\n\nfn main() {    \n    let ptr: *const i32;\n\n    {\n        let x = 1234;\n        ptr = &x as *const i32;\n        unsafe {\n            println!(\"Value at ptr: {}\", *ptr);\n        }\n    }\n\n    unsafe {\n        println!(\"Value at ptr: {}\", *ptr);\n    }\n}",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#c",
    "href": "20_os.html#c",
    "title": "OS",
    "section": "C",
    "text": "C\n#include &lt;stdlib.h&gt;\n\nvoid main() {\n        int *p = (int *)malloc(sizeof(int));\n        int *q = (int *)malloc(sizeof(int));\n        free(p);\n        p = q;\n}",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#all-of-these",
    "href": "20_os.html#all-of-these",
    "title": "OS",
    "section": "All of these…",
    "text": "All of these…\n\nAre your problem now.\nThere is also a stack (less theoretically complicated, more implementation complicated) which we have also covered.\nOn to the lab/homework!",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "20_os.html#today-1",
    "href": "20_os.html#today-1",
    "title": "OS",
    "section": "Today",
    "text": "Today\n\nMotivation\n\nArchitecture\nAbstraction level\n\nOS\n\nBus\nAddress space\nStack/heap\nLanguages",
    "crumbs": [
      "OS"
    ]
  },
  {
    "objectID": "22_malloc.html",
    "href": "22_malloc.html",
    "title": "malloc",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#homework",
    "href": "22_malloc.html#homework",
    "title": "malloc",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#requirements",
    "href": "22_malloc.html#requirements",
    "title": "malloc",
    "section": "Requirements",
    "text": "Requirements\n\n371rs/22 crate; I named mine “malloc”\nYou write src/lib.rs that implements functions in the src/main.rs I provide.\nRegard it as “unsporting” to use Vec&lt;T&gt; or any other Rust built-in data structure.\n\nUnless you are storing it (e.g. as an argument to setter).\nUse arrays and raw pointers.\nIf you can’t solve it without them, use them, but…\n…at least understand why it’s hard and that there’s an alternative.\nIf you hand-implement a vector-like on top of static mut within the overhead allowance, you may use your own vectors",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#code",
    "href": "22_malloc.html#code",
    "title": "malloc",
    "section": "Code",
    "text": "Code\n\n\n\n\n\n\nUpdate: Don’t Assume i32\n\n\n\nAn early submitted solution trivialized the autograder by assuming all provided values to getter and setter would be of type i32.\nThis assumption side-steps the core learning objective of working with memory objects of arbitrary size.\nEnsure your solution does not assume i32, and make some effort to test. You may want to test collection types as well (like Vec&lt;T&gt; and String).\n\n\n\n\nsrc/main.rs\n\nuse malloc::*; // crate name\n\nfn main() {\n    let p0 = malloc(16).unwrap();\n    let p1 = malloc(32).unwrap();\n    let x = 0x44332211;\n    let y = 0x12345678;\n    setter(x, p0);\n    setter(y, p1);\n    let z: i32 = getter(p0);\n    let w: i32 = getter(p1);\n    assert!(x == z);\n    assert!(y == w);\n    println!(\"A+\");\n    // Advanced topics.\n\n    // Big alloc should fail\n\n    assert!(malloc(2048).is_none());\n    println!(\"A++\");\n\n    // Allocs totaling &gt; SIZE should fail\n\n    // We have alloc (16 + 32) * 8 = 384 of 1024\n    // Try annother small malloc\n    malloc(32).unwrap();\n    // And then one too large.\n    assert!(malloc(64).is_none());\n    println!(\"A+++\");\n\n    // Easiest to test these together:\n    //  - Gets to uninitialized memory should fail\n    //  - You should write free()\n    // No graceful way to autotest these. Left as an exercise to the interested student.\n}",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "22_malloc.html#explanation",
    "href": "22_malloc.html#explanation",
    "title": "malloc",
    "section": "Explanation",
    "text": "Explanation\n\nThis is based on the C language malloc function.\n\nProbably the most important function.\nMy slides on C\n\n\n\nMalloc\n\nWe begin with calls to our own malloc:\n\n\n\nsrc/main.rs\n\n    let p0 = malloc(16).unwrap();\n    let p1 = malloc(32).unwrap();\n\n\nmalloc takes one argument, a usize, the number of bytes to allocate.\n\nIt returns a Option&lt;usize&gt;, the “offset” of those bytes from general reference point.\nWe can regard this as the address.\nWe can ask malloc for more memory then is available, and then we get None.\n\nHere is my malloc, with code removed.\n\n\n\nsrc/lib.rs\n\n// Return an index in BUS of s reserved bytes\npub fn malloc(s: usize) -&gt; Option&lt;usize&gt; {\n    unsafe {\n        // Ensure BUS is initialized.\n        &lt; 3 lines snipped &gt; \n\n        // Reserve a block of s bytes\n        &lt; 4 lines snipped &gt; \n\n        // Scan for a contigious region of size s\n        // In s &gt; 8, word level allocation\n        // \"Could be more efficient\" it's an exercise!\n        &lt; ~20 lines snipped&gt; \n    }\n    return None;\n}\n\n\nSome interest things here:\n\nThis relies on a new Rust “thing”, a static mut.\n\nThey may hold the record for being the most unsafe.\nThink of it maybe as a Python global.\nI named mine BUS.\n\nThis relies on a helper function to initialize BUS\n\nI am requiring the following implementation for your BUS:\nFor me, declared at the beginning of lib\n\n\n\n\n\nStatic mut\n\n\nsrc/lib.rs\n\n// Treat ourselves to a kb (1024 bits)\n// 1024 &gt;&gt; 3 == 128 == 0x80\npub const SIZE: usize = 0x80;\n\n// Not really a BUS but we gotta call it something.\nstatic mut BUS: [u8; SIZE] = [0u8; SIZE];\n\n\nThe requirements are:\n\nA static mut of a fixed size u8 array.\nMust support any size which is a power of 2.\nMay not use any other static mut\n\nAn astute observer will note that then any tracking information related to BUS must be stored within BUS itself\nThis is non-trivial\n\n\nI am not aware of high quality reference materials on static mut, here is an example use apparently.\n\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_counter(inc: u32) {\n    // SAFETY: There are no other threads which could be accessing `COUNTER`.\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_counter(42);\n\n    // SAFETY: There are no other threads which could be accessing `COUNTER`.\n    unsafe {\n        dbg!(COUNTER);\n    }\n}\n\nThis fixed-size array of bits is meant to be consistent with underlying hardware, at least theoretically.\n\n\n\nInitialization\n\nYou are not required to use a helper for this, but I did.\nI am permitting/encouraging an assert! that enforced power-of-two sizing.\nNaively using BUS didn’t work well for me.\n\nI had to check to make sure I wasn’t giving away bits already in use.\nSo I had to persist some state\n\nI had to use memory to provide memory.\n\nI just reserved some bits at the beginning of the array as a validity bitmask\n\nIf a bit is set to 1, the corresponding byte is in use.\nSo a 1-in-8 overhead cost.\nThis is why 64 bit words are popular.\nYou are permitted have overhead costs as high as 1-in-4 if you need them.\n\nHowever, I had to mark within that bitmask that the bitmask was already using memory.\nThis formed my init.\n\n\n\n\nsrc/lib.rs\n\n// Zero the array except the mask.\nfn init() {\n    unsafe {\n        // Initialize mask\n        // The following explodes if SIZE isn't a power of 2\n        assert!(SIZE & (SIZE - 1) == 0);\n        // First SIZE &gt;&gt; 3 bits are reserved as a validty byte/bit mask\n        &lt; snip &gt;\n        // Which has to reserve enough bytes for itself.\n        &lt; snip &gt;\n        // Set to 1\n        &lt; snip &gt;\n\n        // Initialize memory\n        // Set to zero.\n        &lt; snip &gt;\n    }\n    return;\n}\n\n\n\nSetter\n\nAfter the calls to malloc within main, we use a wrapping function setter to set memory at the location reserved by the malloc to have certain values.\n\n\n\nsrc/main.rs\n\n    let x = 0x44332211;\n    let y = 0x12345678;\n    setter(x, p0);\n    setter(y, p1);\n\n\nThis maybe isn’t the most typical way to access memory.\n\nA more common metaphor is lw and sw more\nI found this metaphor more interesting.\n\nWords are fixed size, and felt quite trivial.\n\n\nGiven some value returned by malloc, store up to that many bytes of information within the BUS.\n\nmalloc and setter together are responsible for ensuring the correctness and consistency of these bytes.\nIn this case, I malloc much more than I needed (16 and 32 bytes, respectively, for 4 byte words).\n\nThis is allowed, but wasteful.\nIt also makes testing easier.\n\n\nWe note that setter does not ask have an argument for the size of memory being set.\n\nIt is your responsibility to infer this size using the type of the arguments.\nThis is to learn Rust, not to learn about memory, so a secondary objective but one I found worthwhile.\n\n\n\n\nsrc/lib.rs\n\n// Place val at loc\n// No safety checks so good luck out there.\npub fn setter&lt;T&gt;(val: T, loc: usize) {\n    unsafe {\n        &lt; 4 lines &gt;\n    }\n    return;\n}\n\n\nThe instructional staff is diligently working to infer the most graceful way to handle this operation, and many current solutions potentially introduce undefined behavior.\nI summarize my approach as follows:\n\nI cast a reference to the value as a raw pointer.\nI cast that raw pointer to usize.\nI use a for loop to performing an assignment operation.\n\nI use size_of_val to determine how many times to loop.\nI assign a location in the BUS to be equal to something.\n\nThat something is the relevant byte, which I reach through a combination of casts and arithmetic.\n\n\n\n\n\n\nGetter\n\nAfter the calls to “set” values, there are calls to retrieve the values (for latter inspection).\n\n\n\nsrc/main.rs\n\n// Should check the validity bitmask here...\npub fn getter&lt;T&gt;(loc: usize) -&gt; T {\n    unsafe {\n        &lt; 5 lines &gt;\n    }\n}\n\n\nMy code was quite similar to setting, but with the updates in the opposite direction.",
    "crumbs": [
      "malloc"
    ]
  },
  {
    "objectID": "31_linker.html",
    "href": "31_linker.html",
    "title": "Linker",
    "section": "",
    "text": "This is continued directly from the Bare Metal lecture.\n\n\n\n\nWe left off with the following code:\n\n\n\nsrc/main.rs\n\n#![no_std]\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n\n\n\n\nWe modified the configuration with a few new lines about panics.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"\n\n\n\n\n\nWe encountered the following error:\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-code",
    "href": "31_linker.html#the-code",
    "title": "Linker",
    "section": "",
    "text": "We left off with the following code:\n\n\n\nsrc/main.rs\n\n#![no_std]\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-configuration",
    "href": "31_linker.html#the-configuration",
    "title": "Linker",
    "section": "",
    "text": "We modified the configuration with a few new lines about panics.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-state-of-play",
    "href": "31_linker.html#the-state-of-play",
    "title": "Linker",
    "section": "",
    "text": "We encountered the following error:\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: using `fn main` requires the standard library\n  |\n  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-start-attribute",
    "href": "31_linker.html#the-start-attribute",
    "title": "Linker",
    "section": "The start attribute",
    "text": "The start attribute\n\nOne might think that the main function is the first function called when you run a program.\n\nUsually because that is how main is taught.\nIt isn’t entirely wrong - main is the first thing that you write that is called when you run a program.\nBut there’s often some setup first!\n\nMost languages have a “runtime system”\n\nFor e.g. Java garbage collection (e.g. in Java)\nFor e.g. Go software threads (goroutines)\nFor e.g. Python, Pyodide runs in WebAssembly/Emscripten within your browser engine which itself runs on top of an OS.\n\nThis runtime needs to be called before main, since it needs to initialize itself.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#c-again",
    "href": "31_linker.html#c-again",
    "title": "Linker",
    "section": "C, again",
    "text": "C, again\n\nIn a typical Rust executable that links the standard library, execution starts in a C runtime library\n\ncrt0 for “C runtime zero”\nC stands for “cool”\n\nThis creates a stack and places the arguments in the right hardware registers.\n\nWe recall even in our earliest mentions of C and Rust we always assume there just happens to be a stack we can push/pop fixed-size variables onto.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#getting-_started",
    "href": "31_linker.html#getting-_started",
    "title": "Linker",
    "section": "Getting _started",
    "text": "Getting _started\n\nThe C runtime then invokes the entry point of the Rust runtime, which is marked by the start language item.\nI detect a great deal of hand-waving around the term “language item”.\nI think “language item” is how Rust people describe (some subset of) things that don’t make sense with the language implementation.\nMostly, they are not expressions.\nRead more",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#example",
    "href": "31_linker.html#example",
    "title": "Linker",
    "section": "Example",
    "text": "Example\nSome features provided by lang items:\n\noverloadable operators via traits: the traits corresponding to the ==, &lt;, dereferencing (*) and + (etc.) operators are all marked with lang items; those specific four are eq, partial_ord, deref/deref_mut, and add respectively.\n\nWe recall Calvin Deutschbein Thought on both overloading and traits (they’re bad).",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#example-1",
    "href": "31_linker.html#example-1",
    "title": "Linker",
    "section": "Example",
    "text": "Example\nSome features provided by lang items:\n\npanicking: the panic and panic_impl lang items, among others.\n\nWe have already been bamboozled into using #[panic_handler]",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#example-2",
    "href": "31_linker.html#example-2",
    "title": "Linker",
    "section": "Example",
    "text": "Example\nSome features provided by lang items:\n\nstack unwinding: the lang item eh_personality is a function used by the failure mechanisms of the compiler.\n\nThe eh_personality item is cut content present in the reference material. We recall Calvin Deutschbein Thought on unwinding (it’s bad).",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#back-to-rust",
    "href": "31_linker.html#back-to-rust",
    "title": "Linker",
    "section": "Back to Rust",
    "text": "Back to Rust\n\nRust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic.\n\nWe should approach the claim of minimal with some skeptism, but it isn’t relevant to us for now.\n\nThe runtime then finally calls the main function.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#crt0-is-cheating",
    "href": "31_linker.html#crt0-is-cheating",
    "title": "Linker",
    "section": "crt0 is cheating",
    "text": "crt0 is cheating\n\nOur freestanding executable does not have access to the Rust runtime and crt0\nWe need to define our own entry point. = Implementing the start language item wouldn’t help, since it would still require crt0.\nInstead, we need to overwrite the crt0 entry point directly.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#overwriting",
    "href": "31_linker.html#overwriting",
    "title": "Linker",
    "section": "Overwriting",
    "text": "Overwriting\n\nTo tell the Rust compiler that we don’t want to use the normal entry point chain, we add the #![no_main] attribute.\n\n\n\nsrc/main.rs\n\n// main.rs\n\n#![no_std]\n#![no_main]\n\n/// This function is called on panic.\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#no-main-in-main",
    "href": "31_linker.html#no-main-in-main",
    "title": "Linker",
    "section": "No main in main",
    "text": "No main in main\n\nAt this point we can also remove the main function.\n\nBut notably still term our file main.rs\nWe also pretend this is not confusing.\n\nAbsent a compatible runtime, main is meaningless!\nIf you cargo build at this point, by the way, you will get some fun errors.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#start-in-main",
    "href": "31_linker.html#start-in-main",
    "title": "Linker",
    "section": "Start in main",
    "text": "Start in main\n\nInstead, overwrite the entry point with our own _start function:\n\n\n\nsrc/main.rs\n\nfn _start() -&gt; ! {\n    // Code\n}\n\n\nThis also won’t work.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#manglin",
    "href": "31_linker.html#manglin",
    "title": "Linker",
    "section": "Manglin’",
    "text": "Manglin’\n\nBy using the #[unsafe(no_mangle)] attribute, we disable “name mangling”\n\nThe function must be named _start.\n\nOtherwise, compiler generates unique symbols like _start_imarandomstr_1234 to avoid namespace collisons.\n\nFolks… it’s key-value storage.\n\nThe attribute is required for the linker in the next step.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#start-in-main-1",
    "href": "31_linker.html#start-in-main-1",
    "title": "Linker",
    "section": "Start in main",
    "text": "Start in main\n\nWrite your own mangle-free _start.:\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\nfn _start() -&gt; ! {\n    // Code\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#c-you-again",
    "href": "31_linker.html#c-you-again",
    "title": "Linker",
    "section": "C you again",
    "text": "C you again\n\nMark the function as extern \"C\" to tell the compiler that it should use the “C calling convention”\nThe reason for naming the function _start is that this is the default entry point name for most systems.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#a-hardware-reality",
    "href": "31_linker.html#a-hardware-reality",
    "title": "Linker",
    "section": "A Hardware Reality",
    "text": "A Hardware Reality\n\nThe C calling convention is a hardware reality\nIt is the implementation of a physical device that assumes C code is running on it,\nIt assumes the C runs in an expected, consistent, historical way.\nThis consistency leads to a usable heap and viable return.\nIt could be possible to e.g. implement stack-less C\n\nBut that would not have hardware support.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#start-in-main-2",
    "href": "31_linker.html#start-in-main-2",
    "title": "Linker",
    "section": "Start in main",
    "text": "Start in main\n\nInstead, overwrite the entry point with our own _start function:\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    // Code\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#c-you-later",
    "href": "31_linker.html#c-you-later",
    "title": "Linker",
    "section": "C you later",
    "text": "C you later\n\nWe don’t have a great way to test this at this stage.\n\nIn fact, most formulations will lead to similar errors…\nWe just put it in now for forwards compatability.\n\nThat said, I got this working without pub extern \"C\"\n\nYou can try it out soon.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#read-more",
    "href": "31_linker.html#read-more",
    "title": "Linker",
    "section": "Read more",
    "text": "Read more\n\nname mangling\nC calling convention",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#divergence",
    "href": "31_linker.html#divergence",
    "title": "Linker",
    "section": "Divergence",
    "text": "Divergence\n\nThe ! return type returns!\nThis is required because the entry point is not called by any function, but invoked directly by the operating system or bootloader.\n\nIt can’t return anywhere!\n\nCowards use loop(), heroes use recursion.\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    _start()\n}",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#allowance",
    "href": "31_linker.html#allowance",
    "title": "Linker",
    "section": "Allowance",
    "text": "Allowance\n\nAs you are aware, cargo is counted among the cowards that expect loop.\n\nWe still haven’t shown the trick to compile this yet, but if you knew the trick you would see the following.\n\n\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nwarning: function cannot return without recursing\n --&gt; src/main.rs:5:1\n  |\n5 | pub extern \"C\" fn _start() -&gt; ! {\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n6 |     _start()\n  |     -------- recursive call site\n  |\n  = help: a `loop` may express intention better if this is on purpose\n  = note: `#[warn(unconditional_recursion)]` on by default\n\nwarning: `osirs` (bin \"osirs\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.16s",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#hash-and-hash-bang",
    "href": "31_linker.html#hash-and-hash-bang",
    "title": "Linker",
    "section": "Hash and Hash Bang",
    "text": "Hash and Hash Bang\n\nWe applied function-level allowances to our panic to allow infinite recursion as follows:\n\nImmediately prepending, octothorpe/hash prefixed “language items”\n\n\n\n\nsrc/main.rs\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n\nWe applied file-level allowances to our src/main.rs as follows:\n\nFree-floating, octothorpe+exclamation point (hash+bang)\n\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#the-code-1",
    "href": "31_linker.html#the-code-1",
    "title": "Linker",
    "section": "The Code",
    "text": "The Code\n\nI promoted the recursion allowance to file-level, with the following resultant code:\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n#![allow(unconditional_recursion)]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! { _start() }\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! { panic(info) }\n\n\nPut a pin in this.\n\nWe’ll be back latter.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#exit",
    "href": "31_linker.html#exit",
    "title": "Linker",
    "section": "Exit",
    "text": "Exit\n\nBefore I go out to the clubs I always “X it up” (put X’s on my hands) because I’m straight edge.\nOperating systems are similar.\nSo instead of returning, the entry point should e.g. invoke the exit system call of the operating system.\nexit system call\nFor now, we fulfill the requirement by recursing endlessly.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#now-it-works",
    "href": "31_linker.html#now-it-works",
    "title": "Linker",
    "section": "Now it works!",
    "text": "Now it works!\n\nIt doesn’t.\n\n$ cargo build\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/tmp/rustcheyGtM/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib\" \"-L\" \"/tmp/rustcheyGtM/raw-dylibs\" \"-Wl,-Bdynamic\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/32/target/debug/deps/osirs-80f8eb3240ba748e\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: /usr/bin/ld: /home/user/tmp/32/target/debug/deps/osirs-80f8eb3240ba748e.9chdw59nqscmfe0ef1hrxy2nb.rcgu.o: in function `_start':\n          /home/user/tmp/32/src/main.rs:14: multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here\n          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':\n          (.text+0x1b): undefined reference to `main'\n          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'\n          collect2: error: ld returned 1 exit status\n\n  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n  = note: use the `-l` flag to specify native libraries to link\n  = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib)\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#linker-errors",
    "href": "31_linker.html#linker-errors",
    "title": "Linker",
    "section": "Linker Errors",
    "text": "Linker Errors\n\nThe linker is a program that combines the generated code into an executable.\n\nCould be the subject of an entire course.\nExtremely compiler-relevant.\n\nSince the executable format differs between Linux, Windows, and macOS, each system has its own linker that throws a different error.\nThe fundamental cause of the errors is the same: the default configuration of the linker assumes that our program depends on the C runtime, which it does not.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#solution",
    "href": "31_linker.html#solution",
    "title": "Linker",
    "section": "Solution",
    "text": "Solution\n\nTo solve the errors, we need to tell the linker that it should not include the C runtime.\nWe can do this either by passing a certain set of arguments to the linker or by building for a bare metal target.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#building-for-a-bare-metal-target",
    "href": "31_linker.html#building-for-a-bare-metal-target",
    "title": "Linker",
    "section": "Building for a Bare Metal Target",
    "text": "Building for a Bare Metal Target\n\nBy default Rust tries to build an executable that is able to run in your current system environment.\nFor example, if you’re using Linux on x86_64, Rust tries to build an ELF that uses x86_64 instructions.\nThis environment is called your “host” system.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#target-triple",
    "href": "31_linker.html#target-triple",
    "title": "Linker",
    "section": "Target Triple",
    "text": "Target Triple\n\nTo describe different environments, Rust uses a string called target triple.\nYou can see the target triple for your host system by running rustc --version --verbose:\n\n$ rustc --version --verbose\nrustc 1.87.0 (17067e9ac 2025-05-09)\nbinary: rustc\ncommit-hash: 17067e9ac6d7ecb70e50f92c1944e545188d2359\ncommit-date: 2025-05-09\nhost: x86_64-unknown-linux-gnu\nrelease: 1.87.0\nLLVM version: 20.1.1",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#comments",
    "href": "31_linker.html#comments",
    "title": "Linker",
    "section": "Comments",
    "text": "Comments\n\nThe above output is from a x86_64 Linux system.\nWe see that the host triple is x86_64-unknown-linux-gnu\n\nCPU architecture (x86_64),\nVendor (unknown) - It’s Intel #Portland\nOperating system (linux)\nThe ABI (gnu).",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#on-triples",
    "href": "31_linker.html#on-triples",
    "title": "Linker",
    "section": "On Triples",
    "text": "On Triples\n\nFor triple, rustc and the linker (for me gcc, often clang is recommended). assume an OS and C runtime.\nWe turned both of those things off.\nSo, to avoid the linker errors, we can compile for a different environment with no underlying operating system.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#bare-metal",
    "href": "31_linker.html#bare-metal",
    "title": "Linker",
    "section": "Bare Metal",
    "text": "Bare Metal\n\nOne bare metal environment is the thumbv7em-none-eabi target triple\nA embedded ARM system. Used for teaching.\nThe details are not important; it has no underlying operating system.\n\nThat is the none in the target triple.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#rustup",
    "href": "31_linker.html#rustup",
    "title": "Linker",
    "section": "Rustup",
    "text": "Rustup\n\nTo be able to compile for this target, we need to add it in rustup:\n\nrustup target add thumbv7em-none-eabihf\nThis downloads a copy of the standard (and core) library for the system. Now we can build our freestanding executable for this target:\ncargo build --target thumbv7em-none-eabihf",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#explanation",
    "href": "31_linker.html#explanation",
    "title": "Linker",
    "section": "Explanation",
    "text": "Explanation\n\nBy passing a --target argument we cross-compile\n\nBare metal compilation!\n\nSince the target system has no operating system, the linker does not try to link the C runtime and our build succeeds without any linker errors.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#looking-ahead",
    "href": "31_linker.html#looking-ahead",
    "title": "Linker",
    "section": "Looking Ahead",
    "text": "Looking Ahead\n\nThis is the approach that we will use for building our OS kernel.\nInstead of thumbv7em-none-eabihf, we will use a custom target that describes a x86_64 bare metal environment.\n\nI don’t know how this will work for the Apple Silicon folks.\nBut I am excited to find out!\n\nThe details will be explained next week.",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#summary",
    "href": "31_linker.html#summary",
    "title": "Linker",
    "section": "Summary",
    "text": "Summary\nA minimal freestanding Rust executable looks like this:\n\nCode\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n#![allow(unconditional_recursion)]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    _start()\n}\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n\nConfiguration\n\nWe made no changes to this during the lab.\n\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#to-build",
    "href": "31_linker.html#to-build",
    "title": "Linker",
    "section": "To build",
    "text": "To build\nTo build this binary, we need to compile for a bare metal target such as thumbv7em-none-eabi:\ncargo build --target thumbv7em-none-eabi\nAlternatively, we can compile it for Linux by passing additional linker arguments to rustc:\ncargo rustc -- -C link-arg=-nostartfiles",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#to-run",
    "href": "31_linker.html#to-run",
    "title": "Linker",
    "section": "To run",
    "text": "To run\n\nIf you build, you can run it!\n\n$ cargo rustc -- -C link-arg=-nostartfiles\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.14s\nuser@cd-desk:~/tmp/32$ ./target/debug/osirs\nSegmentation fault (core dumped)\n\nWait a minute!",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "31_linker.html#re-cursed",
    "href": "31_linker.html#re-cursed",
    "title": "Linker",
    "section": "RE: cursed",
    "text": "RE: cursed\n\nThe C calling convention segfaults on infinite recursion.\nSwitch to loop to get an infinite loop.\nThese two things are equally bad in my view.\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\nPop the pin",
    "crumbs": [
      "Linker"
    ]
  },
  {
    "objectID": "40_kernel.rjs.html#announcements",
    "href": "40_kernel.rjs.html#announcements",
    "title": "Kernel",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nIs qemu working at all.\n\nThe coolest assignment ever for a second week in a row.\nI’m glad you all love it"
  },
  {
    "objectID": "40_kernel.rjs.html#today",
    "href": "40_kernel.rjs.html#today",
    "title": "Kernel",
    "section": "Today",
    "text": "Today\n\nBackground\nKernel"
  },
  {
    "objectID": "40_kernel.rjs.html#citations",
    "href": "40_kernel.rjs.html#citations",
    "title": "Kernel",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nA Minimal Rust Kernel"
  },
  {
    "objectID": "40_kernel.rjs.html#the-boot-process",
    "href": "40_kernel.rjs.html#the-boot-process",
    "title": "Kernel",
    "section": "The Boot Process",
    "text": "The Boot Process\n\nPOV: You are an inanimate piece of silicon.\n\nYou contain wires connected to logic gates.\nSomewhere, a switch is flipped.\nElectrons flow into some of your wires, through some gates."
  },
  {
    "objectID": "40_kernel.rjs.html#first-steps",
    "href": "40_kernel.rjs.html#first-steps",
    "title": "Kernel",
    "section": "First Steps",
    "text": "First Steps\n\nWhat determines the initial arrangement of gates?\nWhere do electrons flow?\nThis is determined by the boot process\n\nOccurs on every power-up\nDetermined by hardware design\nMore fundamental than the OS"
  },
  {
    "objectID": "40_kernel.rjs.html#firmware",
    "href": "40_kernel.rjs.html#firmware",
    "title": "Kernel",
    "section": "Firmware",
    "text": "Firmware\n\nWhat is between hardware and software?\n\nFirmware.\n\nOn power-up, devices execute code embedded in physical read only memory (ROM).\n\nRead more: ROM\n\nIs it software? Is it hardware? Who can say."
  },
  {
    "objectID": "40_kernel.rjs.html#enter-the-cpu",
    "href": "40_kernel.rjs.html#enter-the-cpu",
    "title": "Kernel",
    "section": "Enter the CPU",
    "text": "Enter the CPU\n\nUsually, power-up occurs on a “motherboard” hosting, among other things, the bus.\n\nNamed “mother” after the “MU/TH/UR” on ship computer in Alien (1979)\nThis is a lie."
  },
  {
    "objectID": "40_kernel.rjs.html#not-code-but-ware",
    "href": "40_kernel.rjs.html#not-code-but-ware",
    "title": "Kernel",
    "section": "Not “code” but “ware”",
    "text": "Not “code” but “ware”\n\nSo firmware isn’t really like CPU code (like Rust or C), but it does:\n\nTell circuitry where to direct electrons within the CPU.\nAlso wake up e.g. the MMU."
  },
  {
    "objectID": "40_kernel.rjs.html#enter-the-os",
    "href": "40_kernel.rjs.html#enter-the-os",
    "title": "Kernel",
    "section": "Enter the OS",
    "text": "Enter the OS\n\nWith the CPU primed but not yet ticking through clock cycles, all that remains is to either\n\nExecute a bare metal executable, or\nBoot an operating system to enable the next higher-level task."
  },
  {
    "objectID": "40_kernel.rjs.html#what-it-sounds-like",
    "href": "40_kernel.rjs.html#what-it-sounds-like",
    "title": "Kernel",
    "section": "What it sounds like",
    "text": "What it sounds like\n\nWe regard, then, the operating system as a system which operates the hardware on behalf of higher level software.\n\nHence, “systems computing”.\nHopefully the contrast to software is a bit more clear here."
  },
  {
    "objectID": "40_kernel.rjs.html#aside",
    "href": "40_kernel.rjs.html#aside",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nI am supposed to teach you about the “power-on self-test”.\nA bit electrical engineering for me.\n\n\nA power-on self-test (POST) is a process performed by firmware or software routines immediately after a computer or other digital electronic device is powered on.\n\n\nNeat! Moving on."
  },
  {
    "objectID": "40_kernel.rjs.html#competing-standards",
    "href": "40_kernel.rjs.html#competing-standards",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nLucky us, there is no widely agreed upon way to do firmware.\nThere’s the cool, old way that doesn’t work well but is easy.\n\n“Basic Input/Output System“ BIOS\n1981"
  },
  {
    "objectID": "40_kernel.rjs.html#competing-standards-1",
    "href": "40_kernel.rjs.html#competing-standards-1",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nThere’s the new way that is too hard to use for normal people like us.\n\nAs in people who do anything else ever.\nIt’s good though we promise.\n“Unified Extensible Firmware Interface” UEFI.\nMay make you use it for a lab. More.\n2006"
  },
  {
    "objectID": "40_kernel.rjs.html#bios-boot",
    "href": "40_kernel.rjs.html#bios-boot",
    "title": "Kernel",
    "section": "BIOS Boot",
    "text": "BIOS Boot\n\nI actually started fooling around with the BIOS before UEFI even existed.\n\nI was a normal kid though 100%.\n\nFortunately it’s still basically around. Quoth Blog:\n\n\nThis is great, because you can use the same boot logic across all machines from the last century."
  },
  {
    "objectID": "40_kernel.rjs.html#upsides",
    "href": "40_kernel.rjs.html#upsides",
    "title": "Kernel",
    "section": "Upsides",
    "text": "Upsides\n\nBlog says it’s a downside that this means you have to do 16-bit mode.\n\nI say: that’s cool.\nI can’t count higher than about 0xFFFF anyways.\n\nThe blog impolitely calls 1980s bootloaders “archaic” instead of “vintage”, “retro”, or “foundational”."
  },
  {
    "objectID": "40_kernel.rjs.html#bootable-disks",
    "href": "40_kernel.rjs.html#bootable-disks",
    "title": "Kernel",
    "section": "Bootable Disks",
    "text": "Bootable Disks\n\nI should also tell you about bootable disks\nNowadays we all boot from SSD or rarely HDD.\nBut you have probably at some point booted from USB.\n\nUsually when removing a virus like Microsoft Windows from your system.\n\nOlden days computers could boot from floppy disks, etc."
  },
  {
    "objectID": "40_kernel.rjs.html#bootlaoder",
    "href": "40_kernel.rjs.html#bootlaoder",
    "title": "Kernel",
    "section": "Bootlaoder",
    "text": "Bootlaoder\n\nI mentioned 1980s bootloaders.\n\nNo relation to bootleggers or boatloaders.\n\n512-byte portion of executable code stored at the bootable disk’s “beginning”.\n\nOn a HDD this is physically the outermost ring of addressable magnetic regions.\nI don’t know how SSDs work as Samsung, SK Hynix, or Micron (shout out Boise)."
  },
  {
    "objectID": "40_kernel.rjs.html#data-structures",
    "href": "40_kernel.rjs.html#data-structures",
    "title": "Kernel",
    "section": "Data Structures",
    "text": "Data Structures\n\nMost bootloaders are larger than 512 bytes.\nSo bootloaders are commonly split into a 512 byte first stage that loads a latter stage.\n\nThis is why we should still be teaching linked lists, basically."
  },
  {
    "objectID": "40_kernel.rjs.html#location-location",
    "href": "40_kernel.rjs.html#location-location",
    "title": "Kernel",
    "section": "Location, Location",
    "text": "Location, Location\n\nThe bootloader lives in a reserved physical (HDD) or logical (SSD) location.\nDoes the OS?\n\nWith respect to itself, yes, the OS probably says it lives at memory location zero.\nWith respect to underlying hardware? Probably not.\n\nGotta find it."
  },
  {
    "objectID": "40_kernel.rjs.html#booting-the-os",
    "href": "40_kernel.rjs.html#booting-the-os",
    "title": "Kernel",
    "section": "Booting the OS",
    "text": "Booting the OS\n\nThe bootloader has to determine the location of the kernel image on disk and load it into memory.\n\nBasically this is the definition of the kernel, the minimal OS internal that runs first.\nImage here means we have physical bits capturing some information, so copies of the bits may live in different places.\n\nSSD and RAM, for example."
  },
  {
    "objectID": "40_kernel.rjs.html#switcheroo",
    "href": "40_kernel.rjs.html#switcheroo",
    "title": "Kernel",
    "section": "Switcheroo",
    "text": "Switcheroo\n\nThe OS probably is not a 16-bit OS.\n\nUnless? Lab idea? Hold me back!\n\nBig OS wants me to tell you that:\n\n16-bit mode is called “real mode”\n32-bit mode is called “protected mode”\n64-bit mode is called “long mode”.\n\nRecall we were writing 64-bit bare metal."
  },
  {
    "objectID": "40_kernel.rjs.html#hand-wave",
    "href": "40_kernel.rjs.html#hand-wave",
    "title": "Kernel",
    "section": "Hand-wave",
    "text": "Hand-wave\n\nWriting a bootloader is a bit cumbersome as it requires assembly language and “write this magic value to this processor register”.\n\n\nInstead use a bootimage that automatically prepends a bootloader to your kernel.\n\n\nThis is called “cheating” and is a good way to get ahead in life."
  },
  {
    "objectID": "40_kernel.rjs.html#a-minimal-kernel",
    "href": "40_kernel.rjs.html#a-minimal-kernel",
    "title": "Kernel",
    "section": "A Minimal Kernel",
    "text": "A Minimal Kernel\n\nLet’s make a kernel.\nSpecifically, a disk image that prints a “Hello World!” to the screen when booted.\nWe extending our bare metal executable."
  },
  {
    "objectID": "40_kernel.rjs.html#target-triple",
    "href": "40_kernel.rjs.html#target-triple",
    "title": "Kernel",
    "section": "Target Triple",
    "text": "Target Triple\n\nWe recall the “target triple”\nImagine host triple is x86_64-unknown-linux-gnu\n\nCPU architecture (x86_64),\nVendor (unknown) - It’s Intel #Portland\nOperating system (linux)\nThe ABI (gnu)."
  },
  {
    "objectID": "40_kernel.rjs.html#our-target",
    "href": "40_kernel.rjs.html#our-target",
    "title": "Kernel",
    "section": "Our Target",
    "text": "Our Target\n\nI am aware of no existing target triple suitable for this course.\nSo, make our own.\nIt’s not too bad, just JSON.\n\nWe’ll specify some easy stuff, like architecture.\nSome weird stuff, like manual memory layouts.\nAnd get on with things."
  },
  {
    "objectID": "40_kernel.rjs.html#json",
    "href": "40_kernel.rjs.html#json",
    "title": "Kernel",
    "section": "JSON",
    "text": "JSON\n\nJSON rules by the way.\n\n{\n    \"llvm-target\": \"x86_64-unknown-linux-gnu\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"linux\",\n    \"executables\": true,\n    \"linker-flavor\": \"gcc\",\n    \"pre-link-args\": [\"-m64\"],\n    \"morestack\": false\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#some-context",
    "href": "40_kernel.rjs.html#some-context",
    "title": "Kernel",
    "section": "Some context",
    "text": "Some context\n\nMost fields are required by LLVM.\nData layout field defines the size of integer, float (ew), and pointer types.\nRust uses conditional compilation, such as via target-pointer-width.\nThe pre-link-args field specifies arguments passed to the linker."
  },
  {
    "objectID": "40_kernel.rjs.html#arm64-take-notes",
    "href": "40_kernel.rjs.html#arm64-take-notes",
    "title": "Kernel",
    "section": "ARM64 Take Notes",
    "text": "ARM64 Take Notes\n\nWe also target x86_64.\nStart here:\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#changes",
    "href": "40_kernel.rjs.html#changes",
    "title": "Kernel",
    "section": "Changes",
    "text": "Changes\n\nNote that we changed the OS in the llvm-target and the os field to none, because we will run on bare metal.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    ...\n    \"os\": \"none\",\n    ...\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#linking",
    "href": "40_kernel.rjs.html#linking",
    "title": "Kernel",
    "section": "Linking",
    "text": "Linking\n\nWe’ll add the following build-related entries:\n\n\n\nx86_64-osirs.json\n\n{\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n}\n\n\nFor OS-agnosticism, we use the cross-platform “LLD” linker that is shipped with Rust for linking our kernel.\n\nMore."
  },
  {
    "objectID": "40_kernel.rjs.html#panic-abort",
    "href": "40_kernel.rjs.html#panic-abort",
    "title": "Kernel",
    "section": "Panic Abort",
    "text": "Panic Abort\n\nYou know how I feel about unwinding.\n\nI have never relaxed in my life.\nI’ve only panicked and given up.\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"panic-strategy\": \"abort\",\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#target-vs.-toml",
    "href": "40_kernel.rjs.html#target-vs.-toml",
    "title": "Kernel",
    "section": "Target vs. TOML",
    "text": "Target vs. TOML\n\nThis has the same effect as the panic = \"abort\" option in our Cargo.toml\nSo we can remove it from there!\nThis is better though:\n\nWe will use core, an architecture specific library, and we need core to also panic abort.\n“It is the portable glue between the language and its libraries, defining the intrinsic and primitive building blocks of all Rust code.”"
  },
  {
    "objectID": "40_kernel.rjs.html#red-zone",
    "href": "40_kernel.rjs.html#red-zone",
    "title": "Kernel",
    "section": "Red Zone",
    "text": "Red Zone\n\nOkay red zone is not particularly relevant to this class.\nBut it is extremely cool.\n\n\n\nx86_64-osirs.json\n\n{\n    \"disable-redzone\": true,\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#ancient-nemesis",
    "href": "40_kernel.rjs.html#ancient-nemesis",
    "title": "Kernel",
    "section": "Ancient Nemesis",
    "text": "Ancient Nemesis\n\nYou all know I love floating point numbers.\n\nAnd with good reason!\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"features\": \"-mmx,-sse,+soft-float\",\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#turn-off-floats",
    "href": "40_kernel.rjs.html#turn-off-floats",
    "title": "Kernel",
    "section": "Turn off floats",
    "text": "Turn off floats\n\nfeatures enables/disables target features.\nWe disable the mmx and sse features by prefixing them with a minus\nWe enable the soft-float feature by prefixing it with a plus.\nNote that there must be no spaces between different flags!"
  },
  {
    "objectID": "40_kernel.rjs.html#mmxsse",
    "href": "40_kernel.rjs.html#mmxsse",
    "title": "Kernel",
    "section": "MMX/SSE",
    "text": "MMX/SSE\n\nThe mmx and sse features are performance optimizing vector operations from when Intel though they’d be able to hold off NVIDIA in the 90s.\nThese are braodly called Single Instruction Multiple Data (SIMD) instructions and are historically important.\n\nFoundation of numpy\n\nWe aren’t using data frames in our kernel."
  },
  {
    "objectID": "40_kernel.rjs.html#soft-float",
    "href": "40_kernel.rjs.html#soft-float",
    "title": "Kernel",
    "section": "Soft Float",
    "text": "Soft Float\n\nFloating point operations on x86_64 require SIMD registers by default.\n\nThat’s right - floats are worse than you thought!\n\nTo solve this problem, we add the soft-float feature, which emulates all floating point operations through software functions based on normal integers.\n\nJust like f16"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-1",
    "href": "40_kernel.rjs.html#aside-1",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nWe also need to tell the Rust compiler rustc that we want to use the corresponding ABI.\n\n\n\nx86_64-osirs.json\n\n{\n    \"rustc-abi\": \"x86-softfloat\"\n}\n\n\nI am 100% sure I can write an OS without hard or soft floats but I haven’t worked far enough ahead to be absolutely certain."
  },
  {
    "objectID": "40_kernel.rjs.html#altogether",
    "href": "40_kernel.rjs.html#altogether",
    "title": "Kernel",
    "section": "Altogether",
    "text": "Altogether\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true,\n    \"features\": \"-mmx,-sse,+soft-float\",\n    \"rustc-abi\": \"x86-softfloat\"\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#i-just-curl",
    "href": "40_kernel.rjs.html#i-just-curl",
    "title": "Kernel",
    "section": "I just curl",
    "text": "I just curl\ncurl https://raw.githubusercontent.com/phil-opp/blog_os/refs/heads/post-02/x86_64-blog_os.json -o x86_64-osirs.json"
  },
  {
    "objectID": "40_kernel.rjs.html#tree",
    "href": "40_kernel.rjs.html#tree",
    "title": "Kernel",
    "section": "Tree",
    "text": "Tree\n\nFor me looks like this.\n\n$ tree\n.\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   ├── main.rs\n│   └── old.rs\n└── x86_64-osirs.json\n\n1 directory, 5 files"
  },
  {
    "objectID": "40_kernel.rjs.html#back-to-loops",
    "href": "40_kernel.rjs.html#back-to-loops",
    "title": "Kernel",
    "section": "Back to loops",
    "text": "Back to loops\n\nBy the way, I’ve switched from cool, good recursion back to unexciting, drab loops\nInfinite recursion blows up the call stack and instantly segmentation faults.\n\nThis is because someone other than me wrote rustc.\nI am not about to write rustc!"
  },
  {
    "objectID": "40_kernel.rjs.html#current-main",
    "href": "40_kernel.rjs.html#current-main",
    "title": "Kernel",
    "section": "Current main",
    "text": "Current main\n\n\nsrc/main.rs\n\n\u0016#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#a-note",
    "href": "40_kernel.rjs.html#a-note",
    "title": "Kernel",
    "section": "A note",
    "text": "A note\n\nRemember the earlier mention of core\n\nHow we need core to also panic abort?\nWe note when looking at src/main.rs we do have a core reference."
  },
  {
    "objectID": "40_kernel.rjs.html#linux-everywhere",
    "href": "40_kernel.rjs.html#linux-everywhere",
    "title": "Kernel",
    "section": "Linux Everywhere",
    "text": "Linux Everywhere\n\nOkay so we aren’t going to use Linux on our device.\nBut we are going to use Linux conventions\n\nNot Linux software, but Linux as a social technology.\n\nThe ld.lld “linker-flavor” instructs LLVM to compile with the -flavor gnu flag.\nThis means that we need an entry point named _start - same as before!"
  },
  {
    "objectID": "40_kernel.rjs.html#build-it",
    "href": "40_kernel.rjs.html#build-it",
    "title": "Kernel",
    "section": "Build it",
    "text": "Build it\n\nI bet it will work now.\n\nUse our new target by passing the name of the JSON file as --target:\n\n\n$ cargo b --target x86_64-osirs.json\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: Error loading target specification: Field target-pointer-width in target specification is required. Run `rustc --print target-list` for a list of built-in targets"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-2",
    "href": "40_kernel.rjs.html#aside-2",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip two slides!"
  },
  {
    "objectID": "40_kernel.rjs.html#okay-so",
    "href": "40_kernel.rjs.html#okay-so",
    "title": "Kernel",
    "section": "Okay so",
    "text": "Okay so\n\nHuh?\n\nField target-pointer-width in target specification is required.\n\nWe very explicitly included that.\nIn the most annoying thing in the universe, rustc expect pointer width as a JSON string and not a JSON integer.\n\nRead more\nIt’s fixed in Nightly, but I sleep at night, so I’m busy."
  },
  {
    "objectID": "40_kernel.rjs.html#fix-it",
    "href": "40_kernel.rjs.html#fix-it",
    "title": "Kernel",
    "section": "Fix it?",
    "text": "Fix it?\n\nI kid you not this is the solution.\n\n“Rust has a type system!”\nSure it does.\n\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\","
  },
  {
    "objectID": "40_kernel.rjs.html#now-it-works",
    "href": "40_kernel.rjs.html#now-it-works",
    "title": "Kernel",
    "section": "Now it works",
    "text": "Now it works\n\nThis time it will work.\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nOkay I was bamboozled."
  },
  {
    "objectID": "40_kernel.rjs.html#the-core",
    "href": "40_kernel.rjs.html#the-core",
    "title": "Kernel",
    "section": "The Core",
    "text": "The Core\n\n\n\nThe Core is a 2003 American science fiction disaster film directed by Jon Amiel with screenplay written by Cooper Layne and John Rogers.\n\n\nI haven’t seen it but it apparently passes the Bechdel Test"
  },
  {
    "objectID": "40_kernel.rjs.html#wrong-core",
    "href": "40_kernel.rjs.html#wrong-core",
    "title": "Kernel",
    "section": "Wrong Core",
    "text": "Wrong Core\n\nWe actually meant the Rust compiler core library.\n\nRead more\n\nThis library contains basic Rust types such as Result, Option, and iterators, and is implicitly linked to all no_std crates."
  },
  {
    "objectID": "40_kernel.rjs.html#the-problem",
    "href": "40_kernel.rjs.html#the-problem",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\ncore is usually pre-compiled (and then, of course, linked).\nBut we made a new target which needs a new core.\nNo problem, we’ll just tell rustc to do some compilation."
  },
  {
    "objectID": "40_kernel.rjs.html#config",
    "href": "40_kernel.rjs.html#config",
    "title": "Kernel",
    "section": "Config",
    "text": "Config\n\nThe most graceful to do this that I am aware of is with a .cargo/config.toml\nBasically, we can write down some things we always want cargo to do, and store them in TOML file in the hidden .cargo folder.\nI just made the folder then opened it up in my most beloved neon vimothy.\n\nmdkir .cargo\nnvim .cargo/config.toml"
  },
  {
    "objectID": "40_kernel.rjs.html#check-in",
    "href": "40_kernel.rjs.html#check-in",
    "title": "Kernel",
    "section": "Check in",
    "text": "Check in\nmdkir .cargo\nnvim .cargo/config.toml\n\nUnderstanding check - what happens if you don’t make .cargo first?"
  },
  {
    "objectID": "40_kernel.rjs.html#the-build-std-option",
    "href": "40_kernel.rjs.html#the-build-std-option",
    "title": "Kernel",
    "section": "The build-std Option",
    "text": "The build-std Option\n\nbuild-std is a feature of Cargo.\nWe can recompile core and other standard library crates on demand.\n\nVs. using the precompiled versions shipped with the Rust installation.\n\nRead more."
  },
  {
    "objectID": "40_kernel.rjs.html#my-config",
    "href": "40_kernel.rjs.html#my-config",
    "title": "Kernel",
    "section": "My Config",
    "text": "My Config\n\nWe can use a pretty sparse config though we’ll want to add more latter.\nI specify the “build-std” option in TOML.\nWe want to build-std\nWe want to build the core\n\n\n\n.cargo/config.toml\n\n\u0016build-std = [\"core\"]\n\n\nI bet this will work."
  },
  {
    "objectID": "40_kernel.rjs.html#oh.",
    "href": "40_kernel.rjs.html#oh.",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "40_kernel.rjs.html#unstable",
    "href": "40_kernel.rjs.html#unstable",
    "title": "Kernel",
    "section": "Unstable",
    "text": "Unstable\n\nSo apparently build-std is not a stable feature of the Rust language.\n\nThis means the Rust designers can change or remove it at any time.\n\nTo use unstable features, we have to tell cargo they are unstable."
  },
  {
    "objectID": "40_kernel.rjs.html#mental-model",
    "href": "40_kernel.rjs.html#mental-model",
    "title": "Kernel",
    "section": "Mental model",
    "text": "Mental model\n\nThink of it a bit like unsafe, but for the language instead of the executables.\n\nWhen an executable is unsafe, it may crash or leak your private key.\nWhen a language is unstable, it may not compile or may compile then leak your private key."
  },
  {
    "objectID": "40_kernel.rjs.html#update-config",
    "href": "40_kernel.rjs.html#update-config",
    "title": "Kernel",
    "section": "Update config",
    "text": "Update config\n\nWe prepend an [unstable] label to our build-std configuration.\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nI bet it will work now (it won’t)."
  },
  {
    "objectID": "40_kernel.rjs.html#oh.-1",
    "href": "40_kernel.rjs.html#oh.-1",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "40_kernel.rjs.html#nightly",
    "href": "40_kernel.rjs.html#nightly",
    "title": "Kernel",
    "section": "Nightly",
    "text": "Nightly\n\nOkay folks here’s the deal.\nI’m not happy about it either.\nbuild-std - which we need - is unstable and\n[unstable] is only available in nightly Rust.\n\nThe version of Rust for nerds.\n\nNot to worry, we are nerds and can use it.\n\nSimply add a +nightly right after cargo."
  },
  {
    "objectID": "40_kernel.rjs.html#try-two-things",
    "href": "40_kernel.rjs.html#try-two-things",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere’s two things that also still won’t work.\n\ncargo +nightly b --target x86_64-osirs.json\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec"
  },
  {
    "objectID": "40_kernel.rjs.html#try-two-things-1",
    "href": "40_kernel.rjs.html#try-two-things-1",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere’s two things that also still won’t work.\n\ncargo +nightly b\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"/home/user/tmp/32/target/debug/deps/{libcore-0c26ef2bd74962c1,libcompiler_builtins-40a77a01cbdbd500}.rlib\" \"-L\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/raw-dylibs\" \"-Wl,-Bdynamic\" \"-B&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld\" \"-fuse-ld=lld\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: rust-lld: error: duplicate symbol: _start\n          &gt;&gt;&gt; defined at /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(_start)\n          &gt;&gt;&gt; defined at main.rs:6 (src/main.rs:6)\n          &gt;&gt;&gt;            /home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391.3hpwl9lytayxk9wu897na7tu0.0wpyfaj.rcgu.o:(.text._start+0x0)\n          collect2: error: ld returned 1 exit status\n\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error"
  },
  {
    "objectID": "40_kernel.rjs.html#the-problem-1",
    "href": "40_kernel.rjs.html#the-problem-1",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\nNot everything works the same way with nightly and stable rust.\n\nThat’s why it’s not stable.\n\nWe will encounter two examples immediately, both related to JSON.\nLet’s look at this:\n\n$ cargo +nightly b --target x86_64-osirs.json\nerror: `.json` target specs require -Zjson-target-spec"
  },
  {
    "objectID": "40_kernel.rjs.html#one-solution",
    "href": "40_kernel.rjs.html#one-solution",
    "title": "Kernel",
    "section": "One Solution",
    "text": "One Solution\n\nWe can of course just put -Zjson-target-spec in there.\nWe get an error, but one we are clever enough to handle.\n\n$ cargo +nightly b --target x86_64-osirs.json -Zjson-target-spec\n\nGives this:\n\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets"
  },
  {
    "objectID": "40_kernel.rjs.html#another-solution",
    "href": "40_kernel.rjs.html#another-solution",
    "title": "Kernel",
    "section": "Another Solution",
    "text": "Another Solution\n\nHowever, that -Zjson-target-spec looks an awful lot like a .cargo/config.toml option…\n\nI believe that is also unstable…\n… after all, it works fine on stable!\n\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nWe can then get the same error with less typing:\n\ncargo +nightly b --target x86_64-osirs.json"
  },
  {
    "objectID": "40_kernel.rjs.html#the-error",
    "href": "40_kernel.rjs.html#the-error",
    "title": "Kernel",
    "section": "The error",
    "text": "The error\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets\n\nDoes that remind you of anything?\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\","
  },
  {
    "objectID": "40_kernel.rjs.html#aside-3",
    "href": "40_kernel.rjs.html#aside-3",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip one slide!"
  },
  {
    "objectID": "40_kernel.rjs.html#revert",
    "href": "40_kernel.rjs.html#revert",
    "title": "Kernel",
    "section": "Revert!",
    "text": "Revert!\n\nChange the string integers back to integer integers in your JSON file and you will be living a charmed and blessed life.\n\nA long one, compilation is 10+ seconds for me.\n\n\n$ cargo +nightly b --target x86_64-osirs.json\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n^[[A    Building [==========&gt;                  ] 2/5: core, compiler_builtins                                                                Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 10.18s"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-4",
    "href": "40_kernel.rjs.html#aside-4",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nBy the way, are you tired of specifying the target every time?\n\nSounds like a problem for .cargo/config.toml!\n\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\""
  },
  {
    "objectID": "40_kernel.rjs.html#run-again",
    "href": "40_kernel.rjs.html#run-again",
    "title": "Kernel",
    "section": "Run again",
    "text": "Run again\n\nBy the way it will be fast now.\n\n$ cargo +nightly b\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-nightly",
    "href": "40_kernel.rjs.html#aside-nightly",
    "title": "Kernel",
    "section": "Aside: Nightly",
    "text": "Aside: Nightly\n\nSurely you can also update .cargo/config.toml to use nightly!\n\nYou can’t. You can solve the problem other ways though.\nLeft as an exercise to the interested student."
  },
  {
    "objectID": "40_kernel.rjs.html#aside-notfutureproofing",
    "href": "40_kernel.rjs.html#aside-notfutureproofing",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I can make a kernel without floats.\nSo I removed the two soft-float lines and it still worked for now.\n\n$ diff old.boring x86_64-osirs.json\n13,15c13\n&lt;     \"disable-redzone\": true,\n&lt;     \"features\": \"-mmx,-sse,+soft-float\",\n&lt;     \"rustc-abi\": \"x86-softfloat\"\n---\n&gt;     \"disable-redzone\": true"
  },
  {
    "objectID": "40_kernel.rjs.html#aside-notfutureproofing-1",
    "href": "40_kernel.rjs.html#aside-notfutureproofing-1",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I could make a kernel without compiler-builtins\nThese are memory related functions where Rust often uses linked C implementations.\nI’m leaving them out for now and will add them in when I need them.\n\nbuild-std-features = [\"compiler-builtins-mem\"]\nbuild-std = [\"core\", \"compiler_builtins\"]"
  },
  {
    "objectID": "40_kernel.rjs.html#boot-it",
    "href": "40_kernel.rjs.html#boot-it",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n\nAnd with that, I bet this will totally work.\nLet’s break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed “misc” qemu\n\nReal ones will use apt\n\nsudo apt install qemu-system-x86"
  },
  {
    "objectID": "40_kernel.rjs.html#boot-it-1",
    "href": "40_kernel.rjs.html#boot-it-1",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab."
  },
  {
    "objectID": "40_kernel.rjs.html#main-file",
    "href": "40_kernel.rjs.html#main-file",
    "title": "Kernel",
    "section": "Main File",
    "text": "Main File\n\nUnaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#config-file",
    "href": "40_kernel.rjs.html#config-file",
    "title": "Kernel",
    "section": "Config File",
    "text": "Config File\n\nAll new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\""
  },
  {
    "objectID": "40_kernel.rjs.html#target-file",
    "href": "40_kernel.rjs.html#target-file",
    "title": "Kernel",
    "section": "Target File",
    "text": "Target File\n\nAll new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}"
  },
  {
    "objectID": "40_kernel.rjs.html#cargo-file",
    "href": "40_kernel.rjs.html#cargo-file",
    "title": "Kernel",
    "section": "Cargo File",
    "text": "Cargo File\n\nMove panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]"
  },
  {
    "objectID": "40_kernel.html",
    "href": "40_kernel.html",
    "title": "Kernel",
    "section": "",
    "text": "Action Items:\n\nIs qemu working at all.\n\nThe coolest assignment ever for a second week in a row.\nI’m glad you all love it",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#announcements",
    "href": "40_kernel.html#announcements",
    "title": "Kernel",
    "section": "",
    "text": "Action Items:\n\nIs qemu working at all.\n\nThe coolest assignment ever for a second week in a row.\nI’m glad you all love it",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#today",
    "href": "40_kernel.html#today",
    "title": "Kernel",
    "section": "Today",
    "text": "Today\n\nBackground\nKernel",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#citations",
    "href": "40_kernel.html#citations",
    "title": "Kernel",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nA Minimal Rust Kernel",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-boot-process",
    "href": "40_kernel.html#the-boot-process",
    "title": "Kernel",
    "section": "The Boot Process",
    "text": "The Boot Process\n\nPOV: You are an inanimate piece of silicon.\n\nYou contain wires connected to logic gates.\nSomewhere, a switch is flipped.\nElectrons flow into some of your wires, through some gates.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#first-steps",
    "href": "40_kernel.html#first-steps",
    "title": "Kernel",
    "section": "First Steps",
    "text": "First Steps\n\nWhat determines the initial arrangement of gates?\nWhere do electrons flow?\nThis is determined by the boot process\n\nOccurs on every power-up\nDetermined by hardware design\nMore fundamental than the OS",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#firmware",
    "href": "40_kernel.html#firmware",
    "title": "Kernel",
    "section": "Firmware",
    "text": "Firmware\n\nWhat is between hardware and software?\n\nFirmware.\n\nOn power-up, devices execute code embedded in physical read only memory (ROM).\n\nRead more: ROM\n\nIs it software? Is it hardware? Who can say.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#enter-the-cpu",
    "href": "40_kernel.html#enter-the-cpu",
    "title": "Kernel",
    "section": "Enter the CPU",
    "text": "Enter the CPU\n\nUsually, power-up occurs on a “motherboard” hosting, among other things, the bus.\n\nNamed “mother” after the “MU/TH/UR” on ship computer in Alien (1979)\nThis is a lie.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#not-code-but-ware",
    "href": "40_kernel.html#not-code-but-ware",
    "title": "Kernel",
    "section": "Not “code” but “ware”",
    "text": "Not “code” but “ware”\n\nSo firmware isn’t really like CPU code (like Rust or C), but it does:\n\nTell circuitry where to direct electrons within the CPU.\nAlso wake up e.g. the MMU.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#enter-the-os",
    "href": "40_kernel.html#enter-the-os",
    "title": "Kernel",
    "section": "Enter the OS",
    "text": "Enter the OS\n\nWith the CPU primed but not yet ticking through clock cycles, all that remains is to either\n\nExecute a bare metal executable, or\nBoot an operating system to enable the next higher-level task.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#what-it-sounds-like",
    "href": "40_kernel.html#what-it-sounds-like",
    "title": "Kernel",
    "section": "What it sounds like",
    "text": "What it sounds like\n\nWe regard, then, the operating system as a system which operates the hardware on behalf of higher level software.\n\nHence, “systems computing”.\nHopefully the contrast to software is a bit more clear here.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside",
    "href": "40_kernel.html#aside",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nI am supposed to teach you about the “power-on self-test”.\nA bit electrical engineering for me.\n\n\nA power-on self-test (POST) is a process performed by firmware or software routines immediately after a computer or other digital electronic device is powered on.\n\n\nNeat! Moving on.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#competing-standards",
    "href": "40_kernel.html#competing-standards",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nLucky us, there is no widely agreed upon way to do firmware.\nThere’s the cool, old way that doesn’t work well but is easy.\n\n“Basic Input/Output System“ BIOS\n1981",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#competing-standards-1",
    "href": "40_kernel.html#competing-standards-1",
    "title": "Kernel",
    "section": "Competing Standards",
    "text": "Competing Standards\n\nThere’s the new way that is too hard to use for normal people like us.\n\nAs in people who do anything else ever.\nIt’s good though we promise.\n“Unified Extensible Firmware Interface” UEFI.\nMay make you use it for a lab. More.\n2006",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#bios-boot",
    "href": "40_kernel.html#bios-boot",
    "title": "Kernel",
    "section": "BIOS Boot",
    "text": "BIOS Boot\n\nI actually started fooling around with the BIOS before UEFI even existed.\n\nI was a normal kid though 100%.\n\nFortunately it’s still basically around. Quoth Blog:\n\n\nThis is great, because you can use the same boot logic across all machines from the last century.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#upsides",
    "href": "40_kernel.html#upsides",
    "title": "Kernel",
    "section": "Upsides",
    "text": "Upsides\n\nBlog says it’s a downside that this means you have to do 16-bit mode.\n\nI say: that’s cool.\nI can’t count higher than about 0xFFFF anyways.\n\nThe blog impolitely calls 1980s bootloaders “archaic” instead of “vintage”, “retro”, or “foundational”.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#bootable-disks",
    "href": "40_kernel.html#bootable-disks",
    "title": "Kernel",
    "section": "Bootable Disks",
    "text": "Bootable Disks\n\nI should also tell you about bootable disks\nNowadays we all boot from SSD or rarely HDD.\nBut you have probably at some point booted from USB.\n\nUsually when removing a virus like Microsoft Windows from your system.\n\nOlden days computers could boot from floppy disks, etc.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#bootlaoder",
    "href": "40_kernel.html#bootlaoder",
    "title": "Kernel",
    "section": "Bootlaoder",
    "text": "Bootlaoder\n\nI mentioned 1980s bootloaders.\n\nNo relation to bootleggers or boatloaders.\n\n512-byte portion of executable code stored at the bootable disk’s “beginning”.\n\nOn a HDD this is physically the outermost ring of addressable magnetic regions.\nI don’t know how SSDs work as Samsung, SK Hynix, or Micron (shout out Boise).",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#data-structures",
    "href": "40_kernel.html#data-structures",
    "title": "Kernel",
    "section": "Data Structures",
    "text": "Data Structures\n\nMost bootloaders are larger than 512 bytes.\nSo bootloaders are commonly split into a 512 byte first stage that loads a latter stage.\n\nThis is why we should still be teaching linked lists, basically.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#location-location",
    "href": "40_kernel.html#location-location",
    "title": "Kernel",
    "section": "Location, Location",
    "text": "Location, Location\n\nThe bootloader lives in a reserved physical (HDD) or logical (SSD) location.\nDoes the OS?\n\nWith respect to itself, yes, the OS probably says it lives at memory location zero.\nWith respect to underlying hardware? Probably not.\n\nGotta find it.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#booting-the-os",
    "href": "40_kernel.html#booting-the-os",
    "title": "Kernel",
    "section": "Booting the OS",
    "text": "Booting the OS\n\nThe bootloader has to determine the location of the kernel image on disk and load it into memory.\n\nBasically this is the definition of the kernel, the minimal OS internal that runs first.\nImage here means we have physical bits capturing some information, so copies of the bits may live in different places.\n\nSSD and RAM, for example.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#switcheroo",
    "href": "40_kernel.html#switcheroo",
    "title": "Kernel",
    "section": "Switcheroo",
    "text": "Switcheroo\n\nThe OS probably is not a 16-bit OS.\n\nUnless? Lab idea? Hold me back!\n\nBig OS wants me to tell you that:\n\n16-bit mode is called “real mode”\n32-bit mode is called “protected mode”\n64-bit mode is called “long mode”.\n\nRecall we were writing 64-bit bare metal.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#hand-wave",
    "href": "40_kernel.html#hand-wave",
    "title": "Kernel",
    "section": "Hand-wave",
    "text": "Hand-wave\n\nWriting a bootloader is a bit cumbersome as it requires assembly language and “write this magic value to this processor register”.\n\n\nInstead use a bootimage that automatically prepends a bootloader to your kernel.\n\n\nThis is called “cheating” and is a good way to get ahead in life.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#a-minimal-kernel",
    "href": "40_kernel.html#a-minimal-kernel",
    "title": "Kernel",
    "section": "A Minimal Kernel",
    "text": "A Minimal Kernel\n\nLet’s make a kernel.\nSpecifically, a disk image that prints a “Hello World!” to the screen when booted.\nWe extending our bare metal executable.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#target-triple",
    "href": "40_kernel.html#target-triple",
    "title": "Kernel",
    "section": "Target Triple",
    "text": "Target Triple\n\nWe recall the “target triple”\nImagine host triple is x86_64-unknown-linux-gnu\n\nCPU architecture (x86_64),\nVendor (unknown) - It’s Intel #Portland\nOperating system (linux)\nThe ABI (gnu).",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#our-target",
    "href": "40_kernel.html#our-target",
    "title": "Kernel",
    "section": "Our Target",
    "text": "Our Target\n\nI am aware of no existing target triple suitable for this course.\nSo, make our own.\nIt’s not too bad, just JSON.\n\nWe’ll specify some easy stuff, like architecture.\nSome weird stuff, like manual memory layouts.\nAnd get on with things.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#json",
    "href": "40_kernel.html#json",
    "title": "Kernel",
    "section": "JSON",
    "text": "JSON\n\nJSON rules by the way.\n\n{\n    \"llvm-target\": \"x86_64-unknown-linux-gnu\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"linux\",\n    \"executables\": true,\n    \"linker-flavor\": \"gcc\",\n    \"pre-link-args\": [\"-m64\"],\n    \"morestack\": false\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#some-context",
    "href": "40_kernel.html#some-context",
    "title": "Kernel",
    "section": "Some context",
    "text": "Some context\n\nMost fields are required by LLVM.\nData layout field defines the size of integer, float (ew), and pointer types.\nRust uses conditional compilation, such as via target-pointer-width.\nThe pre-link-args field specifies arguments passed to the linker.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#arm64-take-notes",
    "href": "40_kernel.html#arm64-take-notes",
    "title": "Kernel",
    "section": "ARM64 Take Notes",
    "text": "ARM64 Take Notes\n\nWe also target x86_64.\nStart here:\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#changes",
    "href": "40_kernel.html#changes",
    "title": "Kernel",
    "section": "Changes",
    "text": "Changes\n\nNote that we changed the OS in the llvm-target and the os field to none, because we will run on bare metal.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    ...\n    \"os\": \"none\",\n    ...\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#linking",
    "href": "40_kernel.html#linking",
    "title": "Kernel",
    "section": "Linking",
    "text": "Linking\n\nWe’ll add the following build-related entries:\n\n\n\nx86_64-osirs.json\n\n{\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n}\n\n\nFor OS-agnosticism, we use the cross-platform “LLD” linker that is shipped with Rust for linking our kernel.\n\nMore.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#panic-abort",
    "href": "40_kernel.html#panic-abort",
    "title": "Kernel",
    "section": "Panic Abort",
    "text": "Panic Abort\n\nYou know how I feel about unwinding.\n\nI have never relaxed in my life.\nI’ve only panicked and given up.\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"panic-strategy\": \"abort\",\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#target-vs.-toml",
    "href": "40_kernel.html#target-vs.-toml",
    "title": "Kernel",
    "section": "Target vs. TOML",
    "text": "Target vs. TOML\n\nThis has the same effect as the panic = \"abort\" option in our Cargo.toml\nSo we can remove it from there!\nThis is better though:\n\nWe will use core, an architecture specific library, and we need core to also panic abort.\n“It is the portable glue between the language and its libraries, defining the intrinsic and primitive building blocks of all Rust code.”",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#red-zone",
    "href": "40_kernel.html#red-zone",
    "title": "Kernel",
    "section": "Red Zone",
    "text": "Red Zone\n\nOkay red zone is not particularly relevant to this class.\nBut it is extremely cool.\n\n\n\nx86_64-osirs.json\n\n{\n    \"disable-redzone\": true,\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#ancient-nemesis",
    "href": "40_kernel.html#ancient-nemesis",
    "title": "Kernel",
    "section": "Ancient Nemesis",
    "text": "Ancient Nemesis\n\nYou all know I love floating point numbers.\n\nAnd with good reason!\n\n\n\n\nx86_64-osirs.json\n\n{\n    \"features\": \"-mmx,-sse,+soft-float\",\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#turn-off-floats",
    "href": "40_kernel.html#turn-off-floats",
    "title": "Kernel",
    "section": "Turn off floats",
    "text": "Turn off floats\n\nfeatures enables/disables target features.\nWe disable the mmx and sse features by prefixing them with a minus\nWe enable the soft-float feature by prefixing it with a plus.\nNote that there must be no spaces between different flags!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#mmxsse",
    "href": "40_kernel.html#mmxsse",
    "title": "Kernel",
    "section": "MMX/SSE",
    "text": "MMX/SSE\n\nThe mmx and sse features are performance optimizing vector operations from when Intel though they’d be able to hold off NVIDIA in the 90s.\nThese are braodly called Single Instruction Multiple Data (SIMD) instructions and are historically important.\n\nFoundation of numpy\n\nWe aren’t using data frames in our kernel.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#soft-float",
    "href": "40_kernel.html#soft-float",
    "title": "Kernel",
    "section": "Soft Float",
    "text": "Soft Float\n\nFloating point operations on x86_64 require SIMD registers by default.\n\nThat’s right - floats are worse than you thought!\n\nTo solve this problem, we add the soft-float feature, which emulates all floating point operations through software functions based on normal integers.\n\nJust like f16",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-1",
    "href": "40_kernel.html#aside-1",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nWe also need to tell the Rust compiler rustc that we want to use the corresponding ABI.\n\n\n\nx86_64-osirs.json\n\n{\n    \"rustc-abi\": \"x86-softfloat\"\n}\n\n\nI am 100% sure I can write an OS without hard or soft floats but I haven’t worked far enough ahead to be absolutely certain.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#altogether",
    "href": "40_kernel.html#altogether",
    "title": "Kernel",
    "section": "Altogether",
    "text": "Altogether\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true,\n    \"features\": \"-mmx,-sse,+soft-float\",\n    \"rustc-abi\": \"x86-softfloat\"\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#i-just-curl",
    "href": "40_kernel.html#i-just-curl",
    "title": "Kernel",
    "section": "I just curl",
    "text": "I just curl\ncurl https://raw.githubusercontent.com/phil-opp/blog_os/refs/heads/post-02/x86_64-blog_os.json -o x86_64-osirs.json",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#tree",
    "href": "40_kernel.html#tree",
    "title": "Kernel",
    "section": "Tree",
    "text": "Tree\n\nFor me looks like this.\n\n$ tree\n.\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   ├── main.rs\n│   └── old.rs\n└── x86_64-osirs.json\n\n1 directory, 5 files",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#back-to-loops",
    "href": "40_kernel.html#back-to-loops",
    "title": "Kernel",
    "section": "Back to loops",
    "text": "Back to loops\n\nBy the way, I’ve switched from cool, good recursion back to unexciting, drab loops\nInfinite recursion blows up the call stack and instantly segmentation faults.\n\nThis is because someone other than me wrote rustc.\nI am not about to write rustc!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#current-main",
    "href": "40_kernel.html#current-main",
    "title": "Kernel",
    "section": "Current main",
    "text": "Current main\n\n\nsrc/main.rs\n\n\u0016#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#a-note",
    "href": "40_kernel.html#a-note",
    "title": "Kernel",
    "section": "A note",
    "text": "A note\n\nRemember the earlier mention of core\n\nHow we need core to also panic abort?\nWe note when looking at src/main.rs we do have a core reference.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#linux-everywhere",
    "href": "40_kernel.html#linux-everywhere",
    "title": "Kernel",
    "section": "Linux Everywhere",
    "text": "Linux Everywhere\n\nOkay so we aren’t going to use Linux on our device.\nBut we are going to use Linux conventions\n\nNot Linux software, but Linux as a social technology.\n\nThe ld.lld “linker-flavor” instructs LLVM to compile with the -flavor gnu flag.\nThis means that we need an entry point named _start - same as before!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#build-it",
    "href": "40_kernel.html#build-it",
    "title": "Kernel",
    "section": "Build it",
    "text": "Build it\n\nI bet it will work now.\n\nUse our new target by passing the name of the JSON file as --target:\n\n\n$ cargo b --target x86_64-osirs.json\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: Error loading target specification: Field target-pointer-width in target specification is required. Run `rustc --print target-list` for a list of built-in targets",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-2",
    "href": "40_kernel.html#aside-2",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip two slides!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#okay-so",
    "href": "40_kernel.html#okay-so",
    "title": "Kernel",
    "section": "Okay so",
    "text": "Okay so\n\nHuh?\n\nField target-pointer-width in target specification is required.\n\nWe very explicitly included that.\nIn the most annoying thing in the universe, rustc expect pointer width as a JSON string and not a JSON integer.\n\nRead more\nIt’s fixed in Nightly, but I sleep at night, so I’m busy.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#fix-it",
    "href": "40_kernel.html#fix-it",
    "title": "Kernel",
    "section": "Fix it?",
    "text": "Fix it?\n\nI kid you not this is the solution.\n\n“Rust has a type system!”\nSure it does.\n\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\",",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#now-it-works",
    "href": "40_kernel.html#now-it-works",
    "title": "Kernel",
    "section": "Now it works",
    "text": "Now it works\n\nThis time it will work.\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error\n\nOkay I was bamboozled.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-core",
    "href": "40_kernel.html#the-core",
    "title": "Kernel",
    "section": "The Core",
    "text": "The Core\n\n\n\nThe Core is a 2003 American science fiction disaster film directed by Jon Amiel with screenplay written by Cooper Layne and John Rogers.\n\n\nI haven’t seen it but it apparently passes the Bechdel Test",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#wrong-core",
    "href": "40_kernel.html#wrong-core",
    "title": "Kernel",
    "section": "Wrong Core",
    "text": "Wrong Core\n\nWe actually meant the Rust compiler core library.\n\nRead more\n\nThis library contains basic Rust types such as Result, Option, and iterators, and is implicitly linked to all no_std crates.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-problem",
    "href": "40_kernel.html#the-problem",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\ncore is usually pre-compiled (and then, of course, linked).\nBut we made a new target which needs a new core.\nNo problem, we’ll just tell rustc to do some compilation.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#config",
    "href": "40_kernel.html#config",
    "title": "Kernel",
    "section": "Config",
    "text": "Config\n\nThe most graceful to do this that I am aware of is with a .cargo/config.toml\nBasically, we can write down some things we always want cargo to do, and store them in TOML file in the hidden .cargo folder.\nI just made the folder then opened it up in my most beloved neon vimothy.\n\nmdkir .cargo\nnvim .cargo/config.toml",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#check-in",
    "href": "40_kernel.html#check-in",
    "title": "Kernel",
    "section": "Check in",
    "text": "Check in\nmdkir .cargo\nnvim .cargo/config.toml\n\nUnderstanding check - what happens if you don’t make .cargo first?",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-build-std-option",
    "href": "40_kernel.html#the-build-std-option",
    "title": "Kernel",
    "section": "The build-std Option",
    "text": "The build-std Option\n\nbuild-std is a feature of Cargo.\nWe can recompile core and other standard library crates on demand.\n\nVs. using the precompiled versions shipped with the Rust installation.\n\nRead more.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#my-config",
    "href": "40_kernel.html#my-config",
    "title": "Kernel",
    "section": "My Config",
    "text": "My Config\n\nWe can use a pretty sparse config though we’ll want to add more latter.\nI specify the “build-std” option in TOML.\nWe want to build-std\nWe want to build the core\n\n\n\n.cargo/config.toml\n\n\u0016build-std = [\"core\"]\n\n\nI bet this will work.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#oh.",
    "href": "40_kernel.html#oh.",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#unstable",
    "href": "40_kernel.html#unstable",
    "title": "Kernel",
    "section": "Unstable",
    "text": "Unstable\n\nSo apparently build-std is not a stable feature of the Rust language.\n\nThis means the Rust designers can change or remove it at any time.\n\nTo use unstable features, we have to tell cargo they are unstable.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#mental-model",
    "href": "40_kernel.html#mental-model",
    "title": "Kernel",
    "section": "Mental model",
    "text": "Mental model\n\nThink of it a bit like unsafe, but for the language instead of the executables.\n\nWhen an executable is unsafe, it may crash or leak your private key.\nWhen a language is unstable, it may not compile or may compile then leak your private key.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#update-config",
    "href": "40_kernel.html#update-config",
    "title": "Kernel",
    "section": "Update config",
    "text": "Update config\n\nWe prepend an [unstable] label to our build-std configuration.\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nI bet it will work now (it won’t).",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#oh.-1",
    "href": "40_kernel.html#oh.-1",
    "title": "Kernel",
    "section": "Oh.",
    "text": "Oh.\n\nThe exact same error as before?\n\n$ cargo b --target x86_64-osirs.json\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `x86_64-osirs` target may not be installed\n  = help: consider downloading the target with `rustup target add x86_64-osirs`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#nightly",
    "href": "40_kernel.html#nightly",
    "title": "Kernel",
    "section": "Nightly",
    "text": "Nightly\n\nOkay folks here’s the deal.\nI’m not happy about it either.\nbuild-std - which we need - is unstable and\n[unstable] is only available in nightly Rust.\n\nThe version of Rust for nerds.\n\nNot to worry, we are nerds and can use it.\n\nSimply add a +nightly right after cargo.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#try-two-things",
    "href": "40_kernel.html#try-two-things",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere’s two things that also still won’t work.\n\ncargo +nightly b --target x86_64-osirs.json\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#try-two-things-1",
    "href": "40_kernel.html#try-two-things-1",
    "title": "Kernel",
    "section": "Try Two Things",
    "text": "Try Two Things\n\nHere’s two things that also still won’t work.\n\ncargo +nightly b\n\nGives this:\n\nerror: `.json` target specs require -Zjson-target-spec\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n   Compiling osirs v0.1.0 (/home/user/tmp/32)\nerror: linking with `cc` failed: exit status: 1\n  |\n  = note:  \"cc\" \"-m64\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/symbols.o\" \"&lt;1 object files omitted&gt;\" \"-Wl,--as-needed\" \"-Wl,-Bstatic\" \"/home/user/tmp/32/target/debug/deps/{libcore-0c26ef2bd74962c1,libcompiler_builtins-40a77a01cbdbd500}.rlib\" \"-L\" \"/home/user/tmp/32/target/debug/deps/rustcMmXrbF/raw-dylibs\" \"-Wl,-Bdynamic\" \"-B&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld\" \"-fuse-ld=lld\" \"-Wl,--eh-frame-hdr\" \"-Wl,-z,noexecstack\" \"-L\" \"&lt;sysroot&gt;/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-z,relro,-z,now\" \"-nodefaultlibs\"\n  = note: some arguments are omitted. use `--verbose` to show all linker arguments\n  = note: rust-lld: error: duplicate symbol: _start\n          &gt;&gt;&gt; defined at /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(_start)\n          &gt;&gt;&gt; defined at main.rs:6 (src/main.rs:6)\n          &gt;&gt;&gt;            /home/user/tmp/32/target/debug/deps/osirs-62b17f4aa5d3b391.3hpwl9lytayxk9wu897na7tu0.0wpyfaj.rcgu.o:(.text._start+0x0)\n          collect2: error: ld returned 1 exit status\n\n\nerror: could not compile `osirs` (bin \"osirs\") due to 1 previous error",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-problem-1",
    "href": "40_kernel.html#the-problem-1",
    "title": "Kernel",
    "section": "The Problem",
    "text": "The Problem\n\nNot everything works the same way with nightly and stable rust.\n\nThat’s why it’s not stable.\n\nWe will encounter two examples immediately, both related to JSON.\nLet’s look at this:\n\n$ cargo +nightly b --target x86_64-osirs.json\nerror: `.json` target specs require -Zjson-target-spec",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#one-solution",
    "href": "40_kernel.html#one-solution",
    "title": "Kernel",
    "section": "One Solution",
    "text": "One Solution\n\nWe can of course just put -Zjson-target-spec in there.\nWe get an error, but one we are clever enough to handle.\n\n$ cargo +nightly b --target x86_64-osirs.json -Zjson-target-spec\n\nGives this:\n\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#another-solution",
    "href": "40_kernel.html#another-solution",
    "title": "Kernel",
    "section": "Another Solution",
    "text": "Another Solution\n\nHowever, that -Zjson-target-spec looks an awful lot like a .cargo/config.toml option…\n\nI believe that is also unstable…\n… after all, it works fine on stable!\n\n\n\n\n.cargo/config.toml\n\n\u0016[unstable]\nbuild-std = [\"core\"]\n\n\nWe can then get the same error with less typing:\n\ncargo +nightly b --target x86_64-osirs.json",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#the-error",
    "href": "40_kernel.html#the-error",
    "title": "Kernel",
    "section": "The error",
    "text": "The error\nerror: failed to run `rustc` to learn about target-specific information\n\nCaused by:\n  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json -Zunstable-options --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)\n  --- stderr\n  error: error loading target specification: target-pointer-width: invalid type: string \"64\", expected u16 at line 6 column 32\n    |\n    = help: run `rustc --print target-list` for a list of built-in targets\n\nDoes that remind you of anything?\n\n$ diff bad.wrong x86_64-osirs.json\n6,7c6,7\n&lt;     \"target-pointer-width\": 64,\n&lt;     \"target-c-int-width\": 32,\n---\n&gt;     \"target-pointer-width\": \"64\",\n&gt;     \"target-c-int-width\": \"32\",",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-3",
    "href": "40_kernel.html#aside-3",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nIf you did not see that error, that is okay!\nIt concerns an unstable language feature and may differ.\nJust skip one slide!",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#revert",
    "href": "40_kernel.html#revert",
    "title": "Kernel",
    "section": "Revert!",
    "text": "Revert!\n\nChange the string integers back to integer integers in your JSON file and you will be living a charmed and blessed life.\n\nA long one, compilation is 10+ seconds for me.\n\n\n$ cargo +nightly b --target x86_64-osirs.json\n   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)\n   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)\n^[[A    Building [==========&gt;                  ] 2/5: core, compiler_builtins                                                                Compiling osirs v0.1.0 (/home/user/tmp/32)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 10.18s",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-4",
    "href": "40_kernel.html#aside-4",
    "title": "Kernel",
    "section": "Aside",
    "text": "Aside\n\nBy the way, are you tired of specifying the target every time?\n\nSounds like a problem for .cargo/config.toml!\n\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#run-again",
    "href": "40_kernel.html#run-again",
    "title": "Kernel",
    "section": "Run again",
    "text": "Run again\n\nBy the way it will be fast now.\n\n$ cargo +nightly b\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-nightly",
    "href": "40_kernel.html#aside-nightly",
    "title": "Kernel",
    "section": "Aside: Nightly",
    "text": "Aside: Nightly\n\nSurely you can also update .cargo/config.toml to use nightly!\n\nYou can’t. You can solve the problem other ways though.\nLeft as an exercise to the interested student.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-notfutureproofing",
    "href": "40_kernel.html#aside-notfutureproofing",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I can make a kernel without floats.\nSo I removed the two soft-float lines and it still worked for now.\n\n$ diff old.boring x86_64-osirs.json\n13,15c13\n&lt;     \"disable-redzone\": true,\n&lt;     \"features\": \"-mmx,-sse,+soft-float\",\n&lt;     \"rustc-abi\": \"x86-softfloat\"\n---\n&gt;     \"disable-redzone\": true",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#aside-notfutureproofing-1",
    "href": "40_kernel.html#aside-notfutureproofing-1",
    "title": "Kernel",
    "section": "Aside: \\(\\not\\)Futureproofing",
    "text": "Aside: \\(\\not\\)Futureproofing\n\nI was pretty sure I could make a kernel without compiler-builtins\nThese are memory related functions where Rust often uses linked C implementations.\nI’m leaving them out for now and will add them in when I need them.\n\nbuild-std-features = [\"compiler-builtins-mem\"]\nbuild-std = [\"core\", \"compiler_builtins\"]",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#boot-it",
    "href": "40_kernel.html#boot-it",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n\nAnd with that, I bet this will totally work.\nLet’s break out qemu\n\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nCommand 'qemu-system-x86_64' not found, but can be installed with:\nsudo apt install qemu-system-x86      # version 1:6.2+dfsg-2ubuntu6.27, or\nsudo apt install qemu-system-x86-xen  # version 1:6.2+dfsg-2ubuntu6.27\n\nOh right, we only installed “misc” qemu\n\nReal ones will use apt\n\nsudo apt install qemu-system-x86",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#boot-it-1",
    "href": "40_kernel.html#boot-it-1",
    "title": "Kernel",
    "section": "Boot it",
    "text": "Boot it\n$ qemu-system-x86_64 -kernel target/x86_64-osirs/debug/osirs\nqemu-system-x86_64: Error loading uncompressed kernel without PVH ELF Note\n\nOh right, we did precisely nothing with the BIOS and the bootloader and all that and still need to do those things.\n\nI bet that would be a fun topic for a lab.",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#main-file",
    "href": "40_kernel.html#main-file",
    "title": "Kernel",
    "section": "Main File",
    "text": "Main File\n\nUnaltered except loops for stability.\n\n\n\nsrc/main.rs\n\n#![no_std]\n#![no_main]\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    loop {}\n}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -&gt; ! {\n    loop {}\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#config-file",
    "href": "40_kernel.html#config-file",
    "title": "Kernel",
    "section": "Config File",
    "text": "Config File\n\nAll new, only works with nightly.\n\n\n\n.cargo/config.toml\n\n[unstable]\nbuild-std = [\"core\"]\njson-target-spec = true\n\n[build]\ntarget = \"x86_64-osirs.json\"",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#target-file",
    "href": "40_kernel.html#target-file",
    "title": "Kernel",
    "section": "Target File",
    "text": "Target File\n\nAll new, this is the nightly version.\n\n\n\nx86_64-osirs.json\n\n{\n    \"llvm-target\": \"x86_64-unknown-none\",\n    \"data-layout\": \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\",\n    \"arch\": \"x86_64\",\n    \"target-endian\": \"little\",\n    \"target-pointer-width\": 64,\n    \"target-c-int-width\": 32,\n    \"os\": \"none\",\n    \"executables\": true,\n    \"linker-flavor\": \"ld.lld\",\n    \"linker\": \"rust-lld\",\n    \"panic-strategy\": \"abort\",\n    \"disable-redzone\": true\n}",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "40_kernel.html#cargo-file",
    "href": "40_kernel.html#cargo-file",
    "title": "Kernel",
    "section": "Cargo File",
    "text": "Cargo File\n\nMove panic specification to target.\n\n\n\nCargo.toml\n\n[package]\nname = \"osirs\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "42_hello.html",
    "href": "42_hello.html",
    "title": "Hello",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#homework",
    "href": "42_hello.html#homework",
    "title": "Hello",
    "section": "",
    "text": "Homeworks are due on the Friday after the week they correspond to lecture.\nSo 9 days after the corresponding lab.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#requirements",
    "href": "42_hello.html#requirements",
    "title": "Hello",
    "section": "Requirements",
    "text": "Requirements\n\n371rs/42 crate; I named mine “osirs”\nModify src/main.rs from the boot lab.\nDo not modify other files.\nRun on emulated x86-64 in QEMU.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#printing-to-screen",
    "href": "42_hello.html#printing-to-screen",
    "title": "Hello",
    "section": "Printing to Screen",
    "text": "Printing to Screen\n\nThe easiest way to print text to the screen at this stage is the VGA text buffer.\n\nI regard VGA as an aspect ratio like SD (standard definition), 480p, 1080p, 4k, etc.\nIn practice, means “Video Graphics Array”\nIBM standard for 1987 that is widely adotped.\n640 \\(\\times\\) 480.\n“lowest common denominator that virtually all post-1990 PC graphics hardware”\n\nThe text buffer is a special memory area.\n\nIt maps memory locations to screen locations.\nIt normally consists of 25 lines that each contain 80 character cells.\n\nThis is why I sometimes require line lengths less than 80 for backwards compatability.\nThis is why legacy assignment “snek.c” assumed a 24-by-80 screen (to allow I/O on the last line).\n\nEach character cell displays an ASCII character with some foreground and background colors.\n\nThe screen output looks like this:\n\n\n\n\nscreen output for common ASCII characters\n\n\n\nWe will discuss the exact layout of the VGA buffer next week.\n\nWe write a first small driver for it.\n\nFor printing “Hello World!”, we just need to know:\n\nThe buffer is located at address 0xb8000, and\nEach character cell consists of an ASCII byte and a color byte.\n\n\n\n\n\n\n\n\nEmphasis “a byte and a byte”\n\n\n\nYou must write two bytes per character.\n\nAn ASCII value, like 72.\n\n$ python3 -c \"print(ord('H'))\"\n72\n\nA color value, for which you can review Wordle or just use 0xF or 0xF0.\n\nObviously I used 0x0 and then nothing showed up because that was the existing background color.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#recall",
    "href": "42_hello.html#recall",
    "title": "Hello",
    "section": "Recall",
    "text": "Recall\n\nWe recall the solution to the Transmute lab.\n\n\n\nsrc/main.rs\n\nfn main() {\n    unsafe {\n        println!(\"{}\", std::mem::transmute::&lt;&[u8], &str&gt;(&std::mem::transmute::&lt;[i32; 3], [u8; 12]&gt;([1819043144, 1870078063, 560229490])));\n    }\n}\n\n\nI will urge that you use this [i32; 3] as your payload and regard other solutions as “unsporting”.\n\nWe regard the failure of that solution to fit in 80 horizontal characters as a personal moral failing of the course instructor.\nWe will regard specification of those numerical values in hexadecimal as acceptable.\n\nHere is a bit more information about my source code.\n\n$ python3 -c \"print(ord('H'))\"\n72\n$ wc src/main.rs\n 23  88 565 src/main.rs\n$ grep ello src/main.rs\n$ grep tranmute src/main.rs\n$ grep 1819043144 src/main.rs\n        let ints: [i32; 3] = [1819043144, 1870078063, 560229490];\n\nThere is a solution on the blog (which I will not link) that I find banal and uninteresting, but to be of idiomatic Rust.\n\nIt is the “blog” solution, which an interested student can find and consult.\n\nI found this a much better opportunity to practice working with memory.\n\nI used no Rust functions or methods.\nI exclusively used casts and arithmetic on raw pointers.\n\nI did not use transmute but do not regard its usage as unsporting.\n\nI used the same number of unsafe lines (2) as the blog.\n\nBut in typical fashion, I just enclosed the entire function body in unsafe out of pure spite.\nDo not do that in a job interview.\n\nI also turned my panic back to recursion because that sounded fun.\n\nThis required an addition line of code to quell the compiler.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "42_hello.html#bonus",
    "href": "42_hello.html#bonus",
    "title": "Hello",
    "section": "Bonus",
    "text": "Bonus\n\nPrecompute a [u32; 6] with color data and write it in a block.\n\nFor extra fun, color letters uniquely, perhaps by lexicographical order or consonant/vowel classification.",
    "crumbs": [
      "Hello"
    ]
  },
  {
    "objectID": "50_text.html",
    "href": "50_text.html",
    "title": "Text",
    "section": "",
    "text": "Action Items:\n\nDo you text output yet?\n\nThe coolest assignment ever for a third week in a row.\nHow do I keep getting away with it.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#announcements",
    "href": "50_text.html#announcements",
    "title": "Text",
    "section": "",
    "text": "Action Items:\n\nDo you text output yet?\n\nThe coolest assignment ever for a third week in a row.\nHow do I keep getting away with it.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#today",
    "href": "50_text.html#today",
    "title": "Text",
    "section": "Today",
    "text": "Today\n\nBackground\nKernel",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#citations",
    "href": "50_text.html#citations",
    "title": "Text",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nVGA Text Mode\nAnd I mean theft - I do not care about I/O.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#vga-text-mode",
    "href": "50_text.html#vga-text-mode",
    "title": "Text",
    "section": "VGA Text Mode",
    "text": "VGA Text Mode\n\nWe recall VGA text mode from the homework.\n\nA simple way to print text to the screen.\n\nWe recall that Rust prints via a “macro”\nNow we:\n\nCreate an interface to encapsulating all unsafety in a separate module.\nWe also implement support for Rust’s formatting macros",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#the-buffer",
    "href": "50_text.html#the-buffer",
    "title": "Text",
    "section": "The Buffer",
    "text": "The Buffer\n\nTo print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware.\n\nA byte passing over a bus to fixed location will render as ASCII on a screen.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#format",
    "href": "50_text.html#format",
    "title": "Text",
    "section": "Format",
    "text": "Format\n\nDescribes a single screen character through the following format:\n\n\n\n\nBit(s)\nValue\n\n\n\n\n0-7\nASCII code point\n\n\n8-11\nForeground color\n\n\n12-14\nBackground color\n\n\n15\nBlink\n\n\n\n\nI did not see blinking.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#first-byte",
    "href": "50_text.html#first-byte",
    "title": "Text",
    "section": "First Byte",
    "text": "First Byte\n\nThe first byte represents the character that should be printed in the [ASCII encoding].\n\nWe recall we say many mentions of Python in firmware jobs.\n\npython3 -c \"[print(chr(a), ':', a) for a in range(ord('A'), ord('z')+1)]\"",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#except",
    "href": "50_text.html#except",
    "title": "Text",
    "section": "Except",
    "text": "Except\n\nOkay it isn’t actually ASCII.\nIt’s code page 437\nWe think of it as an IBM specific ASCII extension and just use the ASCII subset.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#second-byte",
    "href": "50_text.html#second-byte",
    "title": "Text",
    "section": "Second Byte",
    "text": "Second Byte\n\nThe second byte defines how the character is displayed.\n\nThe first four bits define the foreground color.\nThe next three bits the background color\nNominally the last bit whether the character should blink.\n\nI did not see blinking.\nMay be a qemu thing I’m not sure.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#some-colors",
    "href": "50_text.html#some-colors",
    "title": "Text",
    "section": "Some colors",
    "text": "Some colors\nThe following colors are available:\n\n\n\nNumber\nColor\nNumber + Bright Bit\nBright Color\n\n\n\n\n0x0\nBlack\n0x8\nDark Gray\n\n\n0x1\nBlue\n0x9\nLight Blue\n\n\n0x2\nGreen\n0xa\nLight Green\n\n\n0x3\nCyan\n0xb\nLight Cyan\n\n\n0x4\nRed\n0xc\nLight Red\n\n\n0x5\nMagenta\n0xd\nPink\n\n\n0x6\nBrown\n0xe\nYellow\n\n\n0x7\nLight Gray\n0xf\nWhite",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#brightblink",
    "href": "50_text.html#brightblink",
    "title": "Text",
    "section": "Bright/Blink",
    "text": "Bright/Blink\n\nBit 4 is the bright bit.\n\nFor example, blue into light blue.\n\nFor the background color, this bit is nominally repurposed as the blink bit.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#memory-mapped-io",
    "href": "50_text.html#memory-mapped-io",
    "title": "Text",
    "section": "Memory-mapped I/O",
    "text": "Memory-mapped I/O\n\nOkay so this is cool.\nRecall the bus!\nWe are going to steal some diagrams.\n\nThanks Geeks for Geeks",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#isolated-io",
    "href": "50_text.html#isolated-io",
    "title": "Text",
    "section": "Isolated I/O",
    "text": "Isolated I/O\n\nImagine a form of I/O that isn’t cool.\nIt may have separate address spaces.\n\nSo there may be a 0x64 memory location and also 0x64 device.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#a-rust-module",
    "href": "50_text.html#a-rust-module",
    "title": "Text",
    "section": "A Rust Module",
    "text": "A Rust Module\n\nNow we “know” how the VGA buffer works.\nWe can create a Rust module to handle print and standard out:\n\n\n\nsrc/main.rs\n\nmod vga;\n\n\nWe also must create a new src/vga.rs file.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#a-global-interface",
    "href": "50_text.html#a-global-interface",
    "title": "Text",
    "section": "A Global Interface",
    "text": "A Global Interface\nTo provide a global writer that can be used as an interface from other modules without carrying a Writer instance around, we try to create a static WRITER:\n// in src/vga.rs\n\npub static WRITER: Writer = Writer {\n    column_position: 0,\n    color_code: ColorCode::new(Color::Yellow, Color::Black),\n    buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n};\nHowever, if we try to compile it now, the following errors occur:\nerror[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n --&gt; src/vga.rs:7:17\n  |\n7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0396]: raw pointers cannot be dereferenced in statics\n --&gt; src/vga.rs:8:22\n  |\n8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer in constant\n\nerror[E0017]: references in statics may only refer to immutable values\n --&gt; src/vga.rs:8:22\n  |\n8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n\nerror[E0017]: references in statics may only refer to immutable values\n --&gt; src/vga.rs:8:13\n  |\n8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values\nTo understand what’s happening here, we need to know that statics are initialized at compile time, in contrast to normal variables that are initialized at run time. The component of the Rust compiler that evaluates such initialization expressions is called the “const evaluator”. Its functionality is still limited, but there is ongoing work to expand it, for example in the “Allow panicking in constants” RFC.\nThe issue with ColorCode::new would be solvable by using const functions, but the fundamental problem here is that Rust’s const evaluator is not able to convert raw pointers to references at compile time. Maybe it will work someday, but until then, we have to find another solution.\n\nLazy Statics\nThe one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named lazy_static. This crate provides a lazy_static! macro that defines a lazily initialized static. Instead of computing its value at compile time, the static lazily initializes itself when accessed for the first time. Thus, the initialization happens at runtime, so arbitrarily complex initialization code is possible.\nLet’s add the lazy_static crate to our project:\n# in Cargo.toml\n\n[dependencies.lazy_static]\nversion = \"1.0\"\nfeatures = [\"spin_no_std\"]\nWe need the spin_no_std feature, since we don’t link the standard library.\nWith lazy_static, we can define our static WRITER without problems:\n// in src/vga.rs\n\nuse lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref WRITER: Writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n}\nHowever, this WRITER is pretty useless since it is immutable. This means that we can’t write anything to it (since all the write methods take &mut self). One possible solution would be to use a mutable static. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using static mut is highly discouraged. There were even proposals to remove it. But what are the alternatives? We could try to use an immutable static with a cell type like RefCell or even UnsafeCell that provides interior mutability. But these types aren’t Sync (with good reason), so we can’t use them in statics.\n\n\nSpinlocks\nTo get synchronized interior mutability, users of the standard library can use Mutex. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can’t use it either. However, there is a really basic kind of mutex in computer science that requires no operating system features: the spinlock. Instead of blocking, the threads simply try to lock it again and again in a tight loop, thus burning CPU time until the mutex is free again.\nTo use a spinning mutex, we can add the spin crate as a dependency:\n# in Cargo.toml\n[dependencies]\nspin = \"0.5.2\"\nThen we can use the spinning mutex to add safe interior mutability to our static WRITER:\n// in src/vga.rs\n\nuse spin::Mutex;\n...\nlazy_static! {\n    pub static ref WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    });\n}\nNow we can delete the print_something function and print directly from our _start function:\n// in src/main.rs\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    use core::fmt::Write;\n    vga::WRITER.lock().write_str(\"Hello again\").unwrap();\n    write!(vga::WRITER.lock(), \", some numbers: {} {}\", 42, 1.337).unwrap();\n\n    loop {}\n}\nWe need to import the fmt::Write trait in order to be able to use its functions.\n\n\nSafety\nNote that we only have a single unsafe block in our code, which is needed to create a Buffer reference pointing to 0xb8000. Afterwards, all operations are safe. Rust uses bounds checking for array accesses by default, so we can’t accidentally write outside the buffer. Thus, we encoded the required conditions in the type system and are able to provide a safe interface to the outside.\n\n\nA println Macro\nNow that we have a global writer, we can add a println macro that can be used from anywhere in the codebase. Rust’s macro syntax is a bit strange, so we won’t try to write a macro from scratch. Instead, we look at the source of the println! macro in the standard library:\n#[macro_export]\nmacro_rules! println {\n    () =&gt; (print!(\"\\n\"));\n    ($($arg:tt)*) =&gt; (print!(\"{}\\n\", format_args!($($arg)*)));\n}\nMacros are defined through one or more rules, similar to match arms. The println macro has two rules: The first rule is for invocations without arguments, e.g., println!(), which is expanded to print!(\"\\n\") and thus just prints a newline. The second rule is for invocations with parameters such as println!(\"Hello\") or println!(\"Number: {}\", 4). It is also expanded to an invocation of the print! macro, passing all arguments and an additional newline \\n at the end.\nThe #[macro_export] attribute makes the macro available to the whole crate (not just the module it is defined in) and external crates. It also places the macro at the crate root, which means we have to import the macro through use std::println instead of std::macros::println.\nThe print! macro is defined as:\n#[macro_export]\nmacro_rules! print {\n    ($($arg:tt)*) =&gt; ($crate::io::_print(format_args!($($arg)*)));\n}\nThe macro expands to a call of the _print function in the io module. The $crate variable ensures that the macro also works from outside the std crate by expanding to std when it’s used in other crates.\nThe format_args macro builds a fmt::Arguments type from the passed arguments, which is passed to _print. The _print function of libstd calls print_to, which is rather complicated because it supports different Stdout devices. We don’t need that complexity since we just want to print to the VGA buffer.\nTo print to the VGA buffer, we just copy the println! and print! macros, but modify them to use our own _print function:\n// in src/vga.rs\n\n#[macro_export]\nmacro_rules! print {\n    ($($arg:tt)*) =&gt; ($crate::vga::_print(format_args!($($arg)*)));\n}\n\n#[macro_export]\nmacro_rules! println {\n    () =&gt; ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) =&gt; ($crate::print!(\"{}\\n\", format_args!($($arg)*)));\n}\n\n#[doc(hidden)]\npub fn _print(args: fmt::Arguments) {\n    use core::fmt::Write;\n    WRITER.lock().write_fmt(args).unwrap();\n}\nOne thing that we changed from the original println definition is that we prefixed the invocations of the print! macro with $crate too. This ensures that we don’t need to import the print! macro too if we only want to use println.\nLike in the standard library, we add the #[macro_export] attribute to both macros to make them available everywhere in our crate. Note that this places the macros in the root namespace of the crate, so importing them via use crate::vga::println does not work. Instead, we have to do use crate::println.\nThe _print function locks our static WRITER and calls the write_fmt method on it. This method is from the Write trait, which we need to import. The additional unwrap() at the end panics if printing isn’t successful. But since we always return Ok in write_str, that should not happen.\nSince the macros need to be able to call _print from outside of the module, the function needs to be public. However, since we consider this a private implementation detail, we add the doc(hidden) attribute to hide it from the generated documentation.\n\n\nHello World using println\nNow we can use println in our _start function:\n// in src/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello World{}\", \"!\");\n\n    loop {}\n}\nNote that we don’t have to import the macro in the main function, because it already lives in the root namespace.\nAs expected, we now see a “Hello World!” on the screen:\n\n\n\nQEMU printing “Hello World!”\n\n\n\n\nPrinting Panic Messages\nNow that we have a println macro, we can use it in our panic function to print the panic message and the location of the panic:\n// in main.rs\n\n/// This function is called on panic.\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\nWhen we now insert panic!(\"Some panic message\"); in our _start function, we get the following output:\n\n\n\nQEMU printing “panicked at ‘Some panic message’, src/main.rs:28:5\n\n\nSo we know not only that a panic has occurred, but also the panic message and where in the code it happened.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#summary",
    "href": "50_text.html#summary",
    "title": "Text",
    "section": "Summary",
    "text": "Summary\nIn this post, we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address 0xb8000. We created a Rust module that encapsulates the unsafety of writing to this memory-mapped buffer and presents a safe and convenient interface to the outside.\nThanks to cargo, we also saw how easy it is to add dependencies on third-party libraries. The two dependencies that we added, lazy_static and spin, are very useful in OS development and we will use them in more places in future posts.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#whats-next",
    "href": "50_text.html#whats-next",
    "title": "Text",
    "section": "What’s next?",
    "text": "What’s next?\nThe next post explains how to set up Rust’s built-in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#announcements",
    "href": "50_text.rjs.html#announcements",
    "title": "Text",
    "section": "Announcements",
    "text": "Announcements\n\nAction Items:\n\nDo you text output yet?\n\nThe coolest assignment ever for a third week in a row.\nHow do I keep getting away with it."
  },
  {
    "objectID": "50_text.rjs.html#today",
    "href": "50_text.rjs.html#today",
    "title": "Text",
    "section": "Today",
    "text": "Today\n\nBackground\nKernel"
  },
  {
    "objectID": "50_text.rjs.html#citations",
    "href": "50_text.rjs.html#citations",
    "title": "Text",
    "section": "Citations",
    "text": "Citations\n\nOutright theft:\n\nVGA Text Mode\nAnd I mean theft - I do not care about I/O."
  },
  {
    "objectID": "50_text.rjs.html#vga-text-mode",
    "href": "50_text.rjs.html#vga-text-mode",
    "title": "Text",
    "section": "VGA Text Mode",
    "text": "VGA Text Mode\n\nWe recall VGA text mode from the homework.\n\nA simple way to print text to the screen.\n\nWe recall that Rust prints via a “macro”\nNow we:\n\nCreate an interface to encapsulating all unsafety in a separate module.\nWe also implement support for Rust’s formatting macros"
  },
  {
    "objectID": "50_text.rjs.html#the-buffer",
    "href": "50_text.rjs.html#the-buffer",
    "title": "Text",
    "section": "The Buffer",
    "text": "The Buffer\n\nTo print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware.\n\nA byte passing over a bus to fixed location will render as ASCII on a screen."
  },
  {
    "objectID": "50_text.rjs.html#format",
    "href": "50_text.rjs.html#format",
    "title": "Text",
    "section": "Format",
    "text": "Format\n\nDescribes a single screen character through the following format:\n\n\n\n\nBit(s)\nValue\n\n\n\n\n0-7\nASCII code point\n\n\n8-11\nForeground color\n\n\n12-14\nBackground color\n\n\n15\nBlink\n\n\n\n\nI did not see blinking."
  },
  {
    "objectID": "50_text.rjs.html#first-byte",
    "href": "50_text.rjs.html#first-byte",
    "title": "Text",
    "section": "First Byte",
    "text": "First Byte\n\nThe first byte represents the character that should be printed in the [ASCII encoding].\n\nWe recall we say many mentions of Python in firmware jobs.\n\npython3 -c \"[print(chr(a), ':', a) for a in range(ord('A'), ord('z')+1)]\""
  },
  {
    "objectID": "50_text.rjs.html#except",
    "href": "50_text.rjs.html#except",
    "title": "Text",
    "section": "Except",
    "text": "Except\n\nOkay it isn’t actually ASCII.\nIt’s code page 437\nWe think of it as an IBM specific ASCII extension and just use the ASCII subset."
  },
  {
    "objectID": "50_text.rjs.html#second-byte",
    "href": "50_text.rjs.html#second-byte",
    "title": "Text",
    "section": "Second Byte",
    "text": "Second Byte\n\nThe second byte defines how the character is displayed.\n\nThe first four bits define the foreground color.\nThe next three bits the background color\nNominally the last bit whether the character should blink.\n\nI did not see blinking.\nMay be a qemu thing I’m not sure."
  },
  {
    "objectID": "50_text.rjs.html#some-colors",
    "href": "50_text.rjs.html#some-colors",
    "title": "Text",
    "section": "Some colors",
    "text": "Some colors\nThe following colors are available:\n\n\n\nNumber\nColor\nNumber + Bright Bit\nBright Color\n\n\n\n\n0x0\nBlack\n0x8\nDark Gray\n\n\n0x1\nBlue\n0x9\nLight Blue\n\n\n0x2\nGreen\n0xa\nLight Green\n\n\n0x3\nCyan\n0xb\nLight Cyan\n\n\n0x4\nRed\n0xc\nLight Red\n\n\n0x5\nMagenta\n0xd\nPink\n\n\n0x6\nBrown\n0xe\nYellow\n\n\n0x7\nLight Gray\n0xf\nWhite"
  },
  {
    "objectID": "50_text.rjs.html#brightblink",
    "href": "50_text.rjs.html#brightblink",
    "title": "Text",
    "section": "Bright/Blink",
    "text": "Bright/Blink\n\nBit 4 is the bright bit.\n\nFor example, blue into light blue.\n\nFor the background color, this bit is nominally repurposed as the blink bit."
  },
  {
    "objectID": "50_text.rjs.html#memory-mapped-io",
    "href": "50_text.rjs.html#memory-mapped-io",
    "title": "Text",
    "section": "Memory-mapped I/O",
    "text": "Memory-mapped I/O\n\nOkay so this is cool.\nRecall the bus!\nWe are going to steal some diagrams.\n\nThanks Geeks for Geeks"
  },
  {
    "objectID": "50_text.rjs.html#isolated-io",
    "href": "50_text.rjs.html#isolated-io",
    "title": "Text",
    "section": "Isolated I/O",
    "text": "Isolated I/O\n\nImagine a form of I/O that isn’t cool.\nIt may have separate address spaces.\n\nSo there may be a 0x64 memory location and also 0x64 device."
  },
  {
    "objectID": "50_text.rjs.html#a-rust-module",
    "href": "50_text.rjs.html#a-rust-module",
    "title": "Text",
    "section": "A Rust Module",
    "text": "A Rust Module\n\nNow we “know” how the VGA buffer works.\nWe can create a Rust module to handle print and standard out:\n\n\n\nsrc/main.rs\n\nmod vga;\n\n\nWe also must create a new src/vga.rs file."
  },
  {
    "objectID": "50_text.rjs.html#a-global-interface",
    "href": "50_text.rjs.html#a-global-interface",
    "title": "Text",
    "section": "A Global Interface",
    "text": "A Global Interface\nTo provide a global writer that can be used as an interface from other modules without carrying a Writer instance around, we try to create a static WRITER:\n// in src/vga.rs\n\npub static WRITER: Writer = Writer {\n    column_position: 0,\n    color_code: ColorCode::new(Color::Yellow, Color::Black),\n    buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n};\nHowever, if we try to compile it now, the following errors occur:\nerror[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n --&gt; src/vga.rs:7:17\n  |\n7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0396]: raw pointers cannot be dereferenced in statics\n --&gt; src/vga.rs:8:22\n  |\n8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer in constant\n\nerror[E0017]: references in statics may only refer to immutable values\n --&gt; src/vga.rs:8:22\n  |\n8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n\nerror[E0017]: references in statics may only refer to immutable values\n --&gt; src/vga.rs:8:13\n  |\n8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values\nTo understand what’s happening here, we need to know that statics are initialized at compile time, in contrast to normal variables that are initialized at run time. The component of the Rust compiler that evaluates such initialization expressions is called the “const evaluator”. Its functionality is still limited, but there is ongoing work to expand it, for example in the “Allow panicking in constants” RFC.\nThe issue with ColorCode::new would be solvable by using const functions, but the fundamental problem here is that Rust’s const evaluator is not able to convert raw pointers to references at compile time. Maybe it will work someday, but until then, we have to find another solution.\nLazy Statics\nThe one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named lazy_static. This crate provides a lazy_static! macro that defines a lazily initialized static. Instead of computing its value at compile time, the static lazily initializes itself when accessed for the first time. Thus, the initialization happens at runtime, so arbitrarily complex initialization code is possible.\nLet’s add the lazy_static crate to our project:\n# in Cargo.toml\n\n[dependencies.lazy_static]\nversion = \"1.0\"\nfeatures = [\"spin_no_std\"]\nWe need the spin_no_std feature, since we don’t link the standard library.\nWith lazy_static, we can define our static WRITER without problems:\n// in src/vga.rs\n\nuse lazy_static::lazy_static;\n\nlazy_static! {\n    pub static ref WRITER: Writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n}\nHowever, this WRITER is pretty useless since it is immutable. This means that we can’t write anything to it (since all the write methods take &mut self). One possible solution would be to use a mutable static. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using static mut is highly discouraged. There were even proposals to remove it. But what are the alternatives? We could try to use an immutable static with a cell type like RefCell or even UnsafeCell that provides interior mutability. But these types aren’t Sync (with good reason), so we can’t use them in statics.\nSpinlocks\nTo get synchronized interior mutability, users of the standard library can use Mutex. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can’t use it either. However, there is a really basic kind of mutex in computer science that requires no operating system features: the spinlock. Instead of blocking, the threads simply try to lock it again and again in a tight loop, thus burning CPU time until the mutex is free again.\nTo use a spinning mutex, we can add the spin crate as a dependency:\n# in Cargo.toml\n[dependencies]\nspin = \"0.5.2\"\nThen we can use the spinning mutex to add safe interior mutability to our static WRITER:\n// in src/vga.rs\n\nuse spin::Mutex;\n...\nlazy_static! {\n    pub static ref WRITER: Mutex&lt;Writer&gt; = Mutex::new(Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    });\n}\nNow we can delete the print_something function and print directly from our _start function:\n// in src/main.rs\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    use core::fmt::Write;\n    vga::WRITER.lock().write_str(\"Hello again\").unwrap();\n    write!(vga::WRITER.lock(), \", some numbers: {} {}\", 42, 1.337).unwrap();\n\n    loop {}\n}\nWe need to import the fmt::Write trait in order to be able to use its functions.\nSafety\nNote that we only have a single unsafe block in our code, which is needed to create a Buffer reference pointing to 0xb8000. Afterwards, all operations are safe. Rust uses bounds checking for array accesses by default, so we can’t accidentally write outside the buffer. Thus, we encoded the required conditions in the type system and are able to provide a safe interface to the outside.\nA println Macro\nNow that we have a global writer, we can add a println macro that can be used from anywhere in the codebase. Rust’s macro syntax is a bit strange, so we won’t try to write a macro from scratch. Instead, we look at the source of the println! macro in the standard library:\n#[macro_export]\nmacro_rules! println {\n    () =&gt; (print!(\"\\n\"));\n    ($($arg:tt)*) =&gt; (print!(\"{}\\n\", format_args!($($arg)*)));\n}\nMacros are defined through one or more rules, similar to match arms. The println macro has two rules: The first rule is for invocations without arguments, e.g., println!(), which is expanded to print!(\"\\n\") and thus just prints a newline. The second rule is for invocations with parameters such as println!(\"Hello\") or println!(\"Number: {}\", 4). It is also expanded to an invocation of the print! macro, passing all arguments and an additional newline \\n at the end.\nThe #[macro_export] attribute makes the macro available to the whole crate (not just the module it is defined in) and external crates. It also places the macro at the crate root, which means we have to import the macro through use std::println instead of std::macros::println.\nThe print! macro is defined as:\n#[macro_export]\nmacro_rules! print {\n    ($($arg:tt)*) =&gt; ($crate::io::_print(format_args!($($arg)*)));\n}\nThe macro expands to a call of the _print function in the io module. The $crate variable ensures that the macro also works from outside the std crate by expanding to std when it’s used in other crates.\nThe format_args macro builds a fmt::Arguments type from the passed arguments, which is passed to _print. The _print function of libstd calls print_to, which is rather complicated because it supports different Stdout devices. We don’t need that complexity since we just want to print to the VGA buffer.\nTo print to the VGA buffer, we just copy the println! and print! macros, but modify them to use our own _print function:\n// in src/vga.rs\n\n#[macro_export]\nmacro_rules! print {\n    ($($arg:tt)*) =&gt; ($crate::vga::_print(format_args!($($arg)*)));\n}\n\n#[macro_export]\nmacro_rules! println {\n    () =&gt; ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) =&gt; ($crate::print!(\"{}\\n\", format_args!($($arg)*)));\n}\n\n#[doc(hidden)]\npub fn _print(args: fmt::Arguments) {\n    use core::fmt::Write;\n    WRITER.lock().write_fmt(args).unwrap();\n}\nOne thing that we changed from the original println definition is that we prefixed the invocations of the print! macro with $crate too. This ensures that we don’t need to import the print! macro too if we only want to use println.\nLike in the standard library, we add the #[macro_export] attribute to both macros to make them available everywhere in our crate. Note that this places the macros in the root namespace of the crate, so importing them via use crate::vga::println does not work. Instead, we have to do use crate::println.\nThe _print function locks our static WRITER and calls the write_fmt method on it. This method is from the Write trait, which we need to import. The additional unwrap() at the end panics if printing isn’t successful. But since we always return Ok in write_str, that should not happen.\nSince the macros need to be able to call _print from outside of the module, the function needs to be public. However, since we consider this a private implementation detail, we add the doc(hidden) attribute to hide it from the generated documentation.\nHello World using println\nNow we can use println in our _start function:\n// in src/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    println!(\"Hello World{}\", \"!\");\n\n    loop {}\n}\nNote that we don’t have to import the macro in the main function, because it already lives in the root namespace.\nAs expected, we now see a “Hello World!” on the screen:\n\n\n\nQEMU printing “Hello World!”\n\n\nPrinting Panic Messages\nNow that we have a println macro, we can use it in our panic function to print the panic message and the location of the panic:\n// in main.rs\n\n/// This function is called on panic.\n#[panic_handler]\nfn panic(info: &PanicInfo) -&gt; ! {\n    println!(\"{}\", info);\n    loop {}\n}\nWhen we now insert panic!(\"Some panic message\"); in our _start function, we get the following output:\n\n\n\nQEMU printing “panicked at ‘Some panic message’, src/main.rs:28:5\n\n\nSo we know not only that a panic has occurred, but also the panic message and where in the code it happened."
  },
  {
    "objectID": "50_text.rjs.html#summary",
    "href": "50_text.rjs.html#summary",
    "title": "Text",
    "section": "Summary",
    "text": "Summary\nIn this post, we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address 0xb8000. We created a Rust module that encapsulates the unsafety of writing to this memory-mapped buffer and presents a safe and convenient interface to the outside.\nThanks to cargo, we also saw how easy it is to add dependencies on third-party libraries. The two dependencies that we added, lazy_static and spin, are very useful in OS development and we will use them in more places in future posts."
  },
  {
    "objectID": "50_text.rjs.html#whats-next",
    "href": "50_text.rjs.html#whats-next",
    "title": "Text",
    "section": "What’s next?",
    "text": "What’s next?\nThe next post explains how to set up Rust’s built-in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post."
  },
  {
    "objectID": "50_text.html#d-or-2d",
    "href": "50_text.html#d-or-2d",
    "title": "Text",
    "section": "1d or 2d",
    "text": "1d or 2d\n\nThe VGA text buffer renders as two-dimensional array.\n\nAddressed as a one dimensional array.\nSafe to assume 25 rows and 80 columns.\nEach position is an ASCII (not unicode) character.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#d-or-2d",
    "href": "50_text.rjs.html#d-or-2d",
    "title": "Text",
    "section": "1d or 2d",
    "text": "1d or 2d\n\nThe VGA text buffer renders as two-dimensional array.\n\nAddressed as a one dimensional array.\nSafe to assume 25 rows and 80 columns.\nEach position is an ASCII (not unicode) character."
  },
  {
    "objectID": "50_text.html#section",
    "href": "50_text.html#section",
    "title": "Text",
    "section": "",
    "text": "The VGA text buffer is accessible via memory-mapped I/O to the address 0xb8000. This means that reads and writes to that address don’t access the RAM but directly access the text buffer on the VGA hardware. This means we can read and write it through normal memory operations to that address.\nNote that memory-mapped hardware might not support all normal RAM operations. For example, a device could only support byte-wise reads and return junk when a u64 is read. Fortunately, the text buffer supports normal reads and writes, so we don’t have to treat it in a special way.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#section",
    "href": "50_text.rjs.html#section",
    "title": "Text",
    "section": "",
    "text": "The VGA text buffer is accessible via memory-mapped I/O to the address 0xb8000. This means that reads and writes to that address don’t access the RAM but directly access the text buffer on the VGA hardware. This means we can read and write it through normal memory operations to that address.\nNote that memory-mapped hardware might not support all normal RAM operations. For example, a device could only support byte-wise reads and return junk when a u64 is read. Fortunately, the text buffer supports normal reads and writes, so we don’t have to treat it in a special way."
  },
  {
    "objectID": "50_text.html#colors",
    "href": "50_text.html#colors",
    "title": "Text",
    "section": "Colors",
    "text": "Colors\n\nUsing octal.\n\n\n\n\nNumber\nColor\nBright\nBright Color\n\n\n\n\n0o00\nBlack\n0o10\nDark Gray\n\n\n0o01\nBlue\n0o11\nLight Blue\n\n\n0o02\nGreen\n0o12\nLight Green\n\n\n0o03\nCyan\n0o13\nLight Cyan\n\n\n0o04\nRed\n0o14\nLight Red\n\n\n0o05\nMagenta\n0o15\nPink\n\n\n0o06\nBrown\n0o16\nYellow\n\n\n0o07\nLight Gray\n0o17\nWhite",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#colors",
    "href": "50_text.rjs.html#colors",
    "title": "Text",
    "section": "Colors",
    "text": "Colors\n\nUsing octal.\n\n\n\n\nNumber\nColor\nBright\nBright Color\n\n\n\n\n0o00\nBlack\n0o10\nDark Gray\n\n\n0o01\nBlue\n0o11\nLight Blue\n\n\n0o02\nGreen\n0o12\nLight Green\n\n\n0o03\nCyan\n0o13\nLight Cyan\n\n\n0o04\nRed\n0o14\nLight Red\n\n\n0o05\nMagenta\n0o15\nPink\n\n\n0o06\nBrown\n0o16\nYellow\n\n\n0o07\nLight Gray\n0o17\nWhite"
  },
  {
    "objectID": "50_text.html#this-isnt-cool",
    "href": "50_text.html#this-isnt-cool",
    "title": "Text",
    "section": "This isn’t cool",
    "text": "This isn’t cool\n\nWe already discussed Harvard vs. von Neumann architecture.\nHaving two memory spaces is not at all cool.\nSo we don’t do it.\nThere’s also port-mapped I/O (similarly not cool.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#memory-mapped-io-1",
    "href": "50_text.html#memory-mapped-io-1",
    "title": "Text",
    "section": "Memory-Mapped I/O",
    "text": "Memory-Mapped I/O\n\nImagine the following.\n\nThe bootloader lives at 0x0\nThe OS lives at 0x1\nThe keyboard lives at 0x2\nThe internet (via a network card) at 0x3\nThe monitor at 0x4\n\nThis obviously cool.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#altogether",
    "href": "50_text.html#altogether",
    "title": "Text",
    "section": "Altogether",
    "text": "Altogether\n\nOne Big Happy Memory Space",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#downsides",
    "href": "50_text.html#downsides",
    "title": "Text",
    "section": "Downsides",
    "text": "Downsides\n\nMMIO is a helpful abstraction - we already know how to think about memory, so we don’t need to learn much to do I/O.\n\nThere’s downsides.\nWe shouldn’t be able to write to keyboard, probably.\nOr read from a monitor.\n\nBut its fast and easy, like BIOS vs. UEFI.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#this-isnt-cool",
    "href": "50_text.rjs.html#this-isnt-cool",
    "title": "Text",
    "section": "This isn’t cool",
    "text": "This isn’t cool\n\nWe already discussed Harvard vs. von Neumann architecture.\nHaving two memory spaces is not at all cool.\nSo we don’t do it.\nThere’s also port-mapped I/O (similarly not cool."
  },
  {
    "objectID": "50_text.rjs.html#memory-mapped-io-1",
    "href": "50_text.rjs.html#memory-mapped-io-1",
    "title": "Text",
    "section": "Memory-Mapped I/O",
    "text": "Memory-Mapped I/O\n\nImagine the following.\n\nThe bootloader lives at 0x0\nThe OS lives at 0x1\nThe keyboard lives at 0x2\nThe internet (via a network card) at 0x3\nThe monitor at 0x4\n\nThis obviously cool."
  },
  {
    "objectID": "50_text.rjs.html#altogether",
    "href": "50_text.rjs.html#altogether",
    "title": "Text",
    "section": "Altogether",
    "text": "Altogether\n\nOne Big Happy Memory Space"
  },
  {
    "objectID": "50_text.rjs.html#downsides",
    "href": "50_text.rjs.html#downsides",
    "title": "Text",
    "section": "Downsides",
    "text": "Downsides\n\nMMIO is a helpful abstraction - we already know how to think about memory, so we don’t need to learn much to do I/O.\n\nThere’s downsides.\nWe shouldn’t be able to write to keyboard, probably.\nOr read from a monitor.\n\nBut its fast and easy, like BIOS vs. UEFI."
  },
  {
    "objectID": "50_text.html#in-x86_64",
    "href": "50_text.html#in-x86_64",
    "title": "Text",
    "section": "In x86_64",
    "text": "In x86_64\n\nOn our emulated device, VGA text buffer lives at address 0xb8000.\n\nAbsolute geniuses will crack open C and get into trouble.\n\nSo any read to this location:\n\nDoesn’t go to MMU/RAM/SSD\nDoes go to VGA hardware",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#in-x86_64",
    "href": "50_text.rjs.html#in-x86_64",
    "title": "Text",
    "section": "In x86_64",
    "text": "In x86_64\n\nOn our emulated device, VGA text buffer lives at address 0xb8000.\n\nAbsolute geniuses will crack open C and get into trouble.\n\nSo any read to this location:\n\nDoesn’t go to MMU/RAM/SSD\nDoes go to VGA hardware"
  },
  {
    "objectID": "50_text.html#alert",
    "href": "50_text.html#alert",
    "title": "Text",
    "section": "Alert!",
    "text": "Alert!\n\nMMIO, especially older devices, might not support all normal operations.\nFor example, a device could only support byte-wise reads and return junk when a u64 is read.\n\nBlock-write “Hello world!” is a homework extension.\n\nRead more",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#alert",
    "href": "50_text.rjs.html#alert",
    "title": "Text",
    "section": "Alert!",
    "text": "Alert!\n\nMMIO, especially older devices, might not support all normal operations.\nFor example, a device could only support byte-wise reads and return junk when a u64 is read.\n\nBlock-write “Hello world!” is a homework extension.\n\nRead more"
  },
  {
    "objectID": "50_text.html#colors-1",
    "href": "50_text.html#colors-1",
    "title": "Text",
    "section": "Colors",
    "text": "Colors\n\nRepresent colors using an enum:\n\n\n\nsrc/vga.rs\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum Color {\n    Blck = 0o00,\n    Blue = 0o01,\n    Gren = 0o02,\n    Cyan = 0o03,\n    Redd = 0o04,\n    Mgnt = 0o05,\n    Brwn = 0o06,\n    LGry = 0o07,\n    DGry = 0o10,\n    LBlu = 0o11,\n    LGrn = 0o12,\n    LCyn = 0o13,\n    LRed = 0o14,\n    Pink = 0o15,\n    Yelo = 0o16,\n    Whte = 0o17,\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#notes",
    "href": "50_text.html#notes",
    "title": "Text",
    "section": "Notes",
    "text": "Notes\n\nWe use a [C-like enum] here to explicitly specify the number for each color.\nBecause of the repr(u8) attribute, each enum variant is stored as a u8.\n\nI would use u4 type (a nib) if I was allowed to.\n\nRust on the C-like enum\n\nAt some point we have to figure out why we aren’t writing C.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#suppress-warnings",
    "href": "50_text.html#suppress-warnings",
    "title": "Text",
    "section": "Suppress Warnings",
    "text": "Suppress Warnings\n\nNormally the compiler would issue a warning for each unused variant.\n\nThis seems obviously annoying to me.\n\nBy using the #[allow(dead_code)] attribute, we disable these warnings for the Color enum.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#comparisons",
    "href": "50_text.html#comparisons",
    "title": "Text",
    "section": "Comparisons",
    "text": "Comparisons\n\nBy [deriving] the [Copy], [Clone], [Debug], [PartialEq], and [Eq] traits, we:\n\nGet stack-like (vs. heap-like) behavior.\nMake it printable.\nMake it comparable (e.g. via double-equals-equality ==)\n\nI would obviously just use an u8 here but don’t be like me, I am wrong in some way that may be important latter.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#links",
    "href": "50_text.html#links",
    "title": "Text",
    "section": "Links",
    "text": "Links\n\nderiving\nCopy\nClone\nDebug\nPartialEq\nEq\ncopy semantics",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#colors-1",
    "href": "50_text.rjs.html#colors-1",
    "title": "Text",
    "section": "Colors",
    "text": "Colors\n\nRepresent colors using an enum:\n\n\n\nsrc/vga.rs\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum Color {\n    Blck = 0o00,\n    Blue = 0o01,\n    Gren = 0o02,\n    Cyan = 0o03,\n    Redd = 0o04,\n    Mgnt = 0o05,\n    Brwn = 0o06,\n    LGry = 0o07,\n    DGry = 0o10,\n    LBlu = 0o11,\n    LGrn = 0o12,\n    LCyn = 0o13,\n    LRed = 0o14,\n    Pink = 0o15,\n    Yelo = 0o16,\n    Whte = 0o17,\n}"
  },
  {
    "objectID": "50_text.rjs.html#notes",
    "href": "50_text.rjs.html#notes",
    "title": "Text",
    "section": "Notes",
    "text": "Notes\n\nWe use a [C-like enum] here to explicitly specify the number for each color.\nBecause of the repr(u8) attribute, each enum variant is stored as a u8.\n\nI would use u4 type (a nib) if I was allowed to.\n\nRust on the C-like enum\n\nAt some point we have to figure out why we aren’t writing C."
  },
  {
    "objectID": "50_text.rjs.html#suppress-warnings",
    "href": "50_text.rjs.html#suppress-warnings",
    "title": "Text",
    "section": "Suppress Warnings",
    "text": "Suppress Warnings\n\nNormally the compiler would issue a warning for each unused variant.\n\nThis seems obviously annoying to me.\n\nBy using the #[allow(dead_code)] attribute, we disable these warnings for the Color enum."
  },
  {
    "objectID": "50_text.rjs.html#comparisons",
    "href": "50_text.rjs.html#comparisons",
    "title": "Text",
    "section": "Comparisons",
    "text": "Comparisons\n\nBy [deriving] the [Copy], [Clone], [Debug], [PartialEq], and [Eq] traits, we:\n\nGet stack-like (vs. heap-like) behavior.\nMake it printable.\nMake it comparable (e.g. via double-equals-equality ==)\n\nI would obviously just use an u8 here but don’t be like me, I am wrong in some way that may be important latter."
  },
  {
    "objectID": "50_text.rjs.html#links",
    "href": "50_text.rjs.html#links",
    "title": "Text",
    "section": "Links",
    "text": "Links\n\nderiving\nCopy\nClone\nDebug\nPartialEq\nEq\ncopy semantics"
  },
  {
    "objectID": "50_text.html#new-type",
    "href": "50_text.html#new-type",
    "title": "Text",
    "section": "New Type",
    "text": "New Type\n\nA full color code specifies foreground and background color\nWe create a newtype on top of u8\n\n\n\nsrc/vga.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(transparent)]\nstruct ColorCode(u8);\n\nimpl ColorCode {\n    fn new(fg: Color, b: Color) -&gt; ColorCode {\n        ColorCode((bg as u8) &lt;&lt; 4 | (fg as u8))\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#new-type",
    "href": "50_text.rjs.html#new-type",
    "title": "Text",
    "section": "New Type",
    "text": "New Type\n\nA full color code specifies foreground and background color\nWe create a newtype on top of u8\n\n\n\nsrc/vga.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(transparent)]\nstruct ColorCode(u8);\n\nimpl ColorCode {\n    fn new(fg: Color, b: Color) -&gt; ColorCode {\n        ColorCode((bg as u8) &lt;&lt; 4 | (fg as u8))\n    }\n}"
  },
  {
    "objectID": "50_text.html#transparency",
    "href": "50_text.html#transparency",
    "title": "Text",
    "section": "Transparency",
    "text": "Transparency\n\nAgain, we derive the Copy and Debug traits for it.\nWhen working with low level devices, we need to ensure bits are where we expect them to be.\nTo ensure that the ColorCode has the exact same data layout as a u8, we use the [repr(transparent)] attribute.\n\nRead more &lt;!– ## Text Buffer\n\nNow we can add structures to represent a screen character and the text buffer:\n\n\n\nsrc/vga.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(C)]\nstruct ScreenChar {\n    ascii_character: u8,\n    color_code: ColorCode,\n}\n\nconst BUFFER_HEIGHT: usize = 25;\nconst BUFFER_WIDTH: usize = 80;\n\n#[repr(transparent)]\nstruct Buffer {\n    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#text-buffer",
    "href": "50_text.html#text-buffer",
    "title": "Text",
    "section": "Text Buffer",
    "text": "Text Buffer\n\nNow we can add structures to represent a screen character and the text buffer:\n\n\n\nsrc/vga_buffer.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(C)]\nstruct ScreenChar {\n    ascii_character: u8,\n    color_code: ColorCode,\n}\n\nconst BUFFER_HEIGHT: usize = 25;\nconst BUFFER_WIDTH: usize = 80;\n\n#[repr(transparent)]\nstruct Buffer {\n    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#transparency",
    "href": "50_text.rjs.html#transparency",
    "title": "Text",
    "section": "Transparency",
    "text": "Transparency\n\nAgain, we derive the Copy and Debug traits for it.\nWhen working with low level devices, we need to ensure bits are where we expect them to be.\nTo ensure that the ColorCode has the exact same data layout as a u8, we use the [repr(transparent)] attribute.\n\nRead more &lt;!– ## Text Buffer\n\nNow we can add structures to represent a screen character and the text buffer:\n\n\n\nsrc/vga.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(C)]\nstruct ScreenChar {\n    ascii_character: u8,\n    color_code: ColorCode,\n}\n\nconst BUFFER_HEIGHT: usize = 25;\nconst BUFFER_WIDTH: usize = 80;\n\n#[repr(transparent)]\nstruct Buffer {\n    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}"
  },
  {
    "objectID": "50_text.rjs.html#text-buffer",
    "href": "50_text.rjs.html#text-buffer",
    "title": "Text",
    "section": "Text Buffer",
    "text": "Text Buffer\n\nNow we can add structures to represent a screen character and the text buffer:\n\n\n\nsrc/vga_buffer.rs\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(C)]\nstruct ScreenChar {\n    ascii_character: u8,\n    color_code: ColorCode,\n}\n\nconst BUFFER_HEIGHT: usize = 25;\nconst BUFFER_WIDTH: usize = 80;\n\n#[repr(transparent)]\nstruct Buffer {\n    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}"
  },
  {
    "objectID": "50_text.html#c-representation",
    "href": "50_text.html#c-representation",
    "title": "Text",
    "section": "C Representation",
    "text": "C Representation\n\nField ordering in default structs is undefined in Rust!\nNot so in the good language, C.\nWe use the [repr(C)] attribute.\n\nIt guarantees that the struct’s fields are laid out in order. `\nrepr(C)\n\nFor the Buffer struct, we use [repr(transparent)] again to ensure that it has the same memory layout as its single field. –&gt;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#c-representation",
    "href": "50_text.rjs.html#c-representation",
    "title": "Text",
    "section": "C Representation",
    "text": "C Representation\n\nField ordering in default structs is undefined in Rust!\nNot so in the good language, C.\nWe use the [repr(C)] attribute.\n\nIt guarantees that the struct’s fields are laid out in order. `\nrepr(C)\n\nFor the Buffer struct, we use [repr(transparent)] again to ensure that it has the same memory layout as its single field. –&gt;"
  },
  {
    "objectID": "50_text.html#chars-to-screenchars",
    "href": "50_text.html#chars-to-screenchars",
    "title": "Text",
    "section": "Chars to ScreenChars",
    "text": "Chars to ScreenChars",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#standard-out",
    "href": "50_text.html#standard-out",
    "title": "Text",
    "section": "Standard Out",
    "text": "Standard Out\n\nTo provide “standard out” like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#chars-to-screenchars",
    "href": "50_text.rjs.html#chars-to-screenchars",
    "title": "Text",
    "section": "Chars to ScreenChars",
    "text": "Chars to ScreenChars"
  },
  {
    "objectID": "50_text.rjs.html#standard-out",
    "href": "50_text.rjs.html#standard-out",
    "title": "Text",
    "section": "Standard Out",
    "text": "Standard Out\n\nTo provide “standard out” like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest: usize = 0;"
  },
  {
    "objectID": "50_text.html#location",
    "href": "50_text.html#location",
    "title": "Text",
    "section": "Location",
    "text": "Location\n\nTo provide “standard out” like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\nHave a constant referring to to the VGA buffer address.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest:usize = 0;\nconst MMIO = 0xb8000 as *mut u8;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#color",
    "href": "50_text.html#color",
    "title": "Text",
    "section": "Color",
    "text": "Color\n\nTo provide “standard out” like functionality, I will:\n\nProvide a way to write a character.\n\nI will use a const for color and not worry about.\n\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest:usize = 0;\nconst MMIO = 0xb8000 as *mut u8;\nconst COLOR: u = 0xF;",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#character-wise",
    "href": "50_text.html#character-wise",
    "title": "Text",
    "section": "Character-wise",
    "text": "Character-wise\n\nTo provide “standard out” like functionality, I will:\n\nProvide a way to write a character.\n\nI will write a function to push one character.\n\n\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    todo!();\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#easy",
    "href": "50_text.html#easy",
    "title": "Text",
    "section": "Easy",
    "text": "Easy\n\nCompute absolute location from relative location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#location",
    "href": "50_text.rjs.html#location",
    "title": "Text",
    "section": "Location",
    "text": "Location\n\nTo provide “standard out” like functionality, I will:\n\nMaintain the most recent position to which a character has been written.\nHave a constant referring to to the VGA buffer address.\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest:usize = 0;\nconst MMIO = 0xb8000 as *mut u8;"
  },
  {
    "objectID": "50_text.rjs.html#color",
    "href": "50_text.rjs.html#color",
    "title": "Text",
    "section": "Color",
    "text": "Color\n\nTo provide “standard out” like functionality, I will:\n\nProvide a way to write a character.\n\nI will use a const for color and not worry about.\n\n\n\n\n\nsrc/vga.rs\n\nstatic mut latest:usize = 0;\nconst MMIO = 0xb8000 as *mut u8;\nconst COLOR: u = 0xF;"
  },
  {
    "objectID": "50_text.rjs.html#character-wise",
    "href": "50_text.rjs.html#character-wise",
    "title": "Text",
    "section": "Character-wise",
    "text": "Character-wise\n\nTo provide “standard out” like functionality, I will:\n\nProvide a way to write a character.\n\nI will write a function to push one character.\n\n\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    todo!();\n}"
  },
  {
    "objectID": "50_text.rjs.html#easy",
    "href": "50_text.rjs.html#easy",
    "title": "Text",
    "section": "Easy",
    "text": "Easy\n\nCompute absolute location from relative location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n}"
  },
  {
    "objectID": "50_text.html#easy-1",
    "href": "50_text.html#easy-1",
    "title": "Text",
    "section": "Easy",
    "text": "Easy\n\nCompute absolute location from relative location.\nStore a value at that location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#easy-2",
    "href": "50_text.html#easy-2",
    "title": "Text",
    "section": "Easy",
    "text": "Easy\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n\n}\n\n// in src/vga.rs\n\npub struct Writer {\n    column_position: usize,\n    color_code: ColorCode,\n    buffer: &'static mut Buffer,\n}\nThe writer will always write to the last line and shift lines up when a line is full (or on \\n). The column_position field keeps track of the current position in the last row. The current foreground and background colors are specified by color_code and a reference to the VGA buffer is stored in buffer. Note that we need an explicit lifetime here to tell the compiler how long the reference is valid. The 'static lifetime specifies that the reference is valid for the whole program run time (which is true for the VGA text buffer).\n\nPrinting\nNow we can use the Writer to modify the buffer’s characters. First we create a method to write a single ASCII byte:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_byte(&mut self, byte: u8) {\n        match byte {\n            b'\\n' =&gt; self.new_line(),\n            byte =&gt; {\n                if self.column_position &gt;= BUFFER_WIDTH {\n                    self.new_line();\n                }\n\n                let row = BUFFER_HEIGHT - 1;\n                let col = self.column_position;\n\n                let color_code = self.color_code;\n                self.buffer.chars[row][col] = ScreenChar {\n                    ascii_character: byte,\n                    color_code,\n                };\n                self.column_position += 1;\n            }\n        }\n    }\n\n    fn new_line(&mut self) {/* TODO */}\n}\nIf the byte is the newline byte \\n, the writer does not print anything. Instead, it calls a new_line method, which we’ll implement later. Other bytes get printed to the screen in the second match case.\nWhen printing a byte, the writer checks if the current line is full. In that case, a new_line call is used to wrap the line. Then it writes a new ScreenChar to the buffer at the current position. Finally, the current column position is advanced.\nTo print whole strings, we can convert them to bytes and print them one-by-one:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_string(&mut self, s: &str) {\n        for byte in s.bytes() {\n            match byte {\n                // printable ASCII byte or newline\n                0x20..=0x7e | b'\\n' =&gt; self.write_byte(byte),\n                // not part of printable ASCII range\n                _ =&gt; self.write_byte(0xfe),\n            }\n\n        }\n    }\n}\nThe VGA text buffer only supports ASCII and the additional bytes of code page 437. Rust strings are UTF-8 by default, so they might contain bytes that are not supported by the VGA text buffer. We use a match to differentiate printable ASCII bytes (a newline or anything in between a space character and a ~ character) and unprintable bytes. For unprintable bytes, we print a ■ character, which has the hex code 0xfe on the VGA hardware.\n\nTry it out!\nTo write some characters to the screen, you can create a temporary function:\n// in src/vga.rs\n\npub fn print_something() {\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello \");\n    writer.write_string(\"Wörld!\");\n}\nIt first creates a new Writer that points to the VGA buffer at 0xb8000. The syntax for this might seem a bit strange: First, we cast the integer 0xb8000 as a mutable raw pointer. Then we convert it to a mutable reference by dereferencing it (through *) and immediately borrowing it again (through &mut). This conversion requires an unsafe block, since the compiler can’t guarantee that the raw pointer is valid.\nThen it writes the byte b'H' to it. The b prefix creates a byte literal, which represents an ASCII character. By writing the strings \"ello \" and \"Wörld!\", we test our write_string method and the handling of unprintable characters. To see the output, we need to call the print_something function from our _start function:\n// in src/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::print_something();\n\n    loop {}\n}\nWhen we run our project now, a Hello W■■rld! should be printed in the lower left corner of the screen in yellow:\n\n\n\nQEMU output with a yellow Hello W■■rld! in the lower left corner\n\n\nNotice that the ö is printed as two ■ characters. That’s because ö is represented by two bytes in UTF-8, which both don’t fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.\n\n\n\nVolatile\nWe just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.\nThe problem is that we only write to the Buffer and never read from it again. The compiler doesn’t know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as volatile. This tells the compiler that the write has side effects and should not be optimized away.\nIn order to use volatile writes for the VGA buffer, we use the volatile library. This crate (this is how packages are called in the Rust world) provides a Volatile wrapper type with read and write methods. These methods internally use the read_volatile and write_volatile functions of the core library and thus guarantee that the reads/writes are not optimized away.\nWe can add a dependency on the volatile crate by adding it to the dependencies section of our Cargo.toml:\n# in Cargo.toml\n\n[dependencies]\nvolatile = \"0.2.6\"\nMake sure to specify volatile version 0.2.6. Newer versions of the crate are not compatible with this post. 0.2.6 is the semantic version number. For more information, see the Specifying Dependencies guide of the cargo documentation.\nLet’s use it to make writes to the VGA buffer volatile. We update our Buffer type as follows:\n// in src/vga.rs\n\nuse volatile::Volatile;\n\nstruct Buffer {\n    chars: [[Volatile&lt;ScreenChar&gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}\nInstead of a ScreenChar, we’re now using a Volatile&lt;ScreenChar&gt;. (The Volatile type is generic and can wrap (almost) any type). This ensures that we can’t accidentally write to it “normally”. Instead, we have to use the write method now.\nThis means that we have to update our Writer::write_byte method:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_byte(&mut self, byte: u8) {\n        match byte {\n            b'\\n' =&gt; self.new_line(),\n            byte =&gt; {\n                ...\n\n                self.buffer.chars[row][col].write(ScreenChar {\n                    ascii_character: byte,\n                    color_code,\n                });\n                ...\n            }\n        }\n    }\n    ...\n}\nInstead of a typical assignment using =, we’re now using the write method. Now we can guarantee that the compiler will never optimize away this write.\n\n\nFormatting Macros\nIt would be nice to support Rust’s formatting macros, too. That way, we can easily print different types, like integers or floats. To support them, we need to implement the core::fmt::Write trait. The only required method of this trait is write_str, which looks quite similar to our write_string method, just with a fmt::Result return type:\n// in src/vga.rs\n\nuse core::fmt;\n\nimpl fmt::Write for Writer {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        self.write_string(s);\n        Ok(())\n    }\n}\nThe Ok(()) is just a Ok Result containing the () type.\nNow we can use Rust’s built-in write!/writeln! formatting macros:\n// in src/vga.rs\n\npub fn print_something() {\n    use core::fmt::Write;\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello! \");\n    write!(writer, \"The numbers are {} and {}\", 42, 1.0/3.0).unwrap();\n}\nNow you should see a Hello! The numbers are 42 and 0.3333333333333333 at the bottom of the screen. The write! call returns a Result which causes a warning if not used, so we call the unwrap function on it, which panics if an error occurs. This isn’t a problem in our case, since writes to the VGA buffer never fail.\n\n\nNewlines\nRight now, we just ignore newlines and characters that don’t fit into the line anymore. Instead, we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the new_line method of Writer:\n// in src/vga.rs\n\nimpl Writer {\n    fn new_line(&mut self) {\n        for row in 1..BUFFER_HEIGHT {\n            for col in 0..BUFFER_WIDTH {\n                let character = self.buffer.chars[row][col].read();\n                self.buffer.chars[row - 1][col].write(character);\n            }\n        }\n        self.clear_row(BUFFER_HEIGHT - 1);\n        self.column_position = 0;\n    }\n\n    fn clear_row(&mut self, row: usize) {/* TODO */}\n}\nWe iterate over all the screen characters and move each character one row up. Note that the upper bound of the range notation (..) is exclusive. We also omit the 0th row (the first range starts at 1) because it’s the row that is shifted off screen.\nTo finish the newline code, we add the clear_row method:\n// in src/vga.rs\n\nimpl Writer {\n    fn clear_row(&mut self, row: usize) {\n        let blank = ScreenChar {\n            ascii_character: b' ',\n            color_code: self.color_code,\n        };\n        for col in 0..BUFFER_WIDTH {\n            self.buffer.chars[row][col].write(blank);\n        }\n    }\n}\nThis method clears a row by overwriting all of its characters with a space character.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#easy-1",
    "href": "50_text.rjs.html#easy-1",
    "title": "Text",
    "section": "Easy",
    "text": "Easy\n\nCompute absolute location from relative location.\nStore a value at that location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n}"
  },
  {
    "objectID": "50_text.rjs.html#easy-2",
    "href": "50_text.rjs.html#easy-2",
    "title": "Text",
    "section": "Easy",
    "text": "Easy\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n\n}\n\n// in src/vga.rs\n\npub struct Writer {\n    column_position: usize,\n    color_code: ColorCode,\n    buffer: &'static mut Buffer,\n}\nThe writer will always write to the last line and shift lines up when a line is full (or on \\n). The column_position field keeps track of the current position in the last row. The current foreground and background colors are specified by color_code and a reference to the VGA buffer is stored in buffer. Note that we need an explicit lifetime here to tell the compiler how long the reference is valid. The 'static lifetime specifies that the reference is valid for the whole program run time (which is true for the VGA text buffer).\nPrinting\nNow we can use the Writer to modify the buffer’s characters. First we create a method to write a single ASCII byte:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_byte(&mut self, byte: u8) {\n        match byte {\n            b'\\n' =&gt; self.new_line(),\n            byte =&gt; {\n                if self.column_position &gt;= BUFFER_WIDTH {\n                    self.new_line();\n                }\n\n                let row = BUFFER_HEIGHT - 1;\n                let col = self.column_position;\n\n                let color_code = self.color_code;\n                self.buffer.chars[row][col] = ScreenChar {\n                    ascii_character: byte,\n                    color_code,\n                };\n                self.column_position += 1;\n            }\n        }\n    }\n\n    fn new_line(&mut self) {/* TODO */}\n}\nIf the byte is the newline byte \\n, the writer does not print anything. Instead, it calls a new_line method, which we’ll implement later. Other bytes get printed to the screen in the second match case.\nWhen printing a byte, the writer checks if the current line is full. In that case, a new_line call is used to wrap the line. Then it writes a new ScreenChar to the buffer at the current position. Finally, the current column position is advanced.\nTo print whole strings, we can convert them to bytes and print them one-by-one:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_string(&mut self, s: &str) {\n        for byte in s.bytes() {\n            match byte {\n                // printable ASCII byte or newline\n                0x20..=0x7e | b'\\n' =&gt; self.write_byte(byte),\n                // not part of printable ASCII range\n                _ =&gt; self.write_byte(0xfe),\n            }\n\n        }\n    }\n}\nThe VGA text buffer only supports ASCII and the additional bytes of code page 437. Rust strings are UTF-8 by default, so they might contain bytes that are not supported by the VGA text buffer. We use a match to differentiate printable ASCII bytes (a newline or anything in between a space character and a ~ character) and unprintable bytes. For unprintable bytes, we print a ■ character, which has the hex code 0xfe on the VGA hardware.\nTry it out!\nTo write some characters to the screen, you can create a temporary function:\n// in src/vga.rs\n\npub fn print_something() {\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello \");\n    writer.write_string(\"Wörld!\");\n}\nIt first creates a new Writer that points to the VGA buffer at 0xb8000. The syntax for this might seem a bit strange: First, we cast the integer 0xb8000 as a mutable raw pointer. Then we convert it to a mutable reference by dereferencing it (through *) and immediately borrowing it again (through &mut). This conversion requires an unsafe block, since the compiler can’t guarantee that the raw pointer is valid.\nThen it writes the byte b'H' to it. The b prefix creates a byte literal, which represents an ASCII character. By writing the strings \"ello \" and \"Wörld!\", we test our write_string method and the handling of unprintable characters. To see the output, we need to call the print_something function from our _start function:\n// in src/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::print_something();\n\n    loop {}\n}\nWhen we run our project now, a Hello W■■rld! should be printed in the lower left corner of the screen in yellow:\n\nQEMU output with a yellow Hello W■■rld! in the lower left cornerNotice that the ö is printed as two ■ characters. That’s because ö is represented by two bytes in UTF-8, which both don’t fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.\nVolatile\nWe just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.\nThe problem is that we only write to the Buffer and never read from it again. The compiler doesn’t know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as volatile. This tells the compiler that the write has side effects and should not be optimized away.\nIn order to use volatile writes for the VGA buffer, we use the volatile library. This crate (this is how packages are called in the Rust world) provides a Volatile wrapper type with read and write methods. These methods internally use the read_volatile and write_volatile functions of the core library and thus guarantee that the reads/writes are not optimized away.\nWe can add a dependency on the volatile crate by adding it to the dependencies section of our Cargo.toml:\n# in Cargo.toml\n\n[dependencies]\nvolatile = \"0.2.6\"\nMake sure to specify volatile version 0.2.6. Newer versions of the crate are not compatible with this post. 0.2.6 is the semantic version number. For more information, see the Specifying Dependencies guide of the cargo documentation.\nLet’s use it to make writes to the VGA buffer volatile. We update our Buffer type as follows:\n// in src/vga.rs\n\nuse volatile::Volatile;\n\nstruct Buffer {\n    chars: [[Volatile&lt;ScreenChar&gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}\nInstead of a ScreenChar, we’re now using a Volatile&lt;ScreenChar&gt;. (The Volatile type is generic and can wrap (almost) any type). This ensures that we can’t accidentally write to it “normally”. Instead, we have to use the write method now.\nThis means that we have to update our Writer::write_byte method:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_byte(&mut self, byte: u8) {\n        match byte {\n            b'\\n' =&gt; self.new_line(),\n            byte =&gt; {\n                ...\n\n                self.buffer.chars[row][col].write(ScreenChar {\n                    ascii_character: byte,\n                    color_code,\n                });\n                ...\n            }\n        }\n    }\n    ...\n}\nInstead of a typical assignment using =, we’re now using the write method. Now we can guarantee that the compiler will never optimize away this write.\nFormatting Macros\nIt would be nice to support Rust’s formatting macros, too. That way, we can easily print different types, like integers or floats. To support them, we need to implement the core::fmt::Write trait. The only required method of this trait is write_str, which looks quite similar to our write_string method, just with a fmt::Result return type:\n// in src/vga.rs\n\nuse core::fmt;\n\nimpl fmt::Write for Writer {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        self.write_string(s);\n        Ok(())\n    }\n}\nThe Ok(()) is just a Ok Result containing the () type.\nNow we can use Rust’s built-in write!/writeln! formatting macros:\n// in src/vga.rs\n\npub fn print_something() {\n    use core::fmt::Write;\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello! \");\n    write!(writer, \"The numbers are {} and {}\", 42, 1.0/3.0).unwrap();\n}\nNow you should see a Hello! The numbers are 42 and 0.3333333333333333 at the bottom of the screen. The write! call returns a Result which causes a warning if not used, so we call the unwrap function on it, which panics if an error occurs. This isn’t a problem in our case, since writes to the VGA buffer never fail.\nNewlines\nRight now, we just ignore newlines and characters that don’t fit into the line anymore. Instead, we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the new_line method of Writer:\n// in src/vga.rs\n\nimpl Writer {\n    fn new_line(&mut self) {\n        for row in 1..BUFFER_HEIGHT {\n            for col in 0..BUFFER_WIDTH {\n                let character = self.buffer.chars[row][col].read();\n                self.buffer.chars[row - 1][col].write(character);\n            }\n        }\n        self.clear_row(BUFFER_HEIGHT - 1);\n        self.column_position = 0;\n    }\n\n    fn clear_row(&mut self, row: usize) {/* TODO */}\n}\nWe iterate over all the screen characters and move each character one row up. Note that the upper bound of the range notation (..) is exclusive. We also omit the 0th row (the first range starts at 1) because it’s the row that is shifted off screen.\nTo finish the newline code, we add the clear_row method:\n// in src/vga.rs\n\nimpl Writer {\n    fn clear_row(&mut self, row: usize) {\n        let blank = ScreenChar {\n            ascii_character: b' ',\n            color_code: self.color_code,\n        };\n        for col in 0..BUFFER_WIDTH {\n            self.buffer.chars[row][col].write(blank);\n        }\n    }\n}\nThis method clears a row by overwriting all of its characters with a space character."
  },
  {
    "objectID": "50_text.html#stepwise",
    "href": "50_text.html#stepwise",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise-1",
    "href": "50_text.html#stepwise-1",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise-2",
    "href": "50_text.html#stepwise-2",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#stepwise-3",
    "href": "50_text.html#stepwise-3",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\nIncrement the latest.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n        LATEST = LATEST + 1;\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#stepwise",
    "href": "50_text.rjs.html#stepwise",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise-1",
    "href": "50_text.rjs.html#stepwise-1",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise-2",
    "href": "50_text.rjs.html#stepwise-2",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n}"
  },
  {
    "objectID": "50_text.rjs.html#stepwise-3",
    "href": "50_text.rjs.html#stepwise-3",
    "title": "Text",
    "section": "Stepwise",
    "text": "Stepwise\n\nCompute absolute location from relative location.\nStore a value at that location.\nStore a color at the next location.\nIncrement the latest.\n\n\n\nsrc/vga.rs\n\n// Public for now\npub fn char_to_vga(a: u8) {\n    let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;\n    *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n        LATEST = LATEST + 1;\n}"
  },
  {
    "objectID": "50_text.html#test-it",
    "href": "50_text.html#test-it",
    "title": "Text",
    "section": "Test it",
    "text": "Test it\n\nIt is trivial to test.\n\n\n\nsrc/main.rs\n\n    let hi: &[u8] = b\"Hello World!\";\n    for i in 0..12 {\n        vga::char_to_vga(hi[i]);\n    }\n\n\n“Works on my machine!” - me\n\nUnless?\nWe’ll come back to this.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#todo",
    "href": "50_text.html#todo",
    "title": "Text",
    "section": "TODO",
    "text": "TODO\nIf the byte is the newline byte \\n, the writer does not print anything. Instead, it calls a new_line method, which we’ll implement later.uuther bytes get printed to the screen in the second match case.\nWhen printing a byte, the writer checks if the current line is full. In that case, a new_line call is used to wrap the line. Then it writes a new ScreenChar to the buffer at the current position. Finally, the current column position is advanced.\nTo print whole strings, we can convert them to bytes and print them one-by-one:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_string(&mut self, s: &str) {\n        for byte in s.bytes() {\n            match byte {\n                // printable ASCII byte or newline\n                0x20..=0x7e | b'\\n' =&gt; self.write_byte(byte),\n                // not part of printable ASCII range\n                _ =&gt; self.write_byte(0xfe),\n            }\n\n        }\n    }\n}\nThe VGA text buffer only supports ASCII and the additional bytes of code page 437. Rust strings are UTF-8 by default, so they might contain bytes that are not supported by the VGA text buffer. We use a match to differentiate printable ASCII bytes (a newline or anything in between a space character and a ~ character) and unprintable bytes. For unprintable bytes, we print a ■ character, which has the hex code 0xfe on the VGA hardware.\n\nTry it out!\nTo write some characters to the screen, you can create a temporary function:\n// in src/vga.rs\n\npub fn print_something() {\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello \");\n    writer.write_string(\"Wörld!\");\n}\nIt first creates a new Writer that points to the VGA buffer at 0xb8000. The syntax for this might seem a bit strange: First, we cast the integer 0xb8000 as a mutable raw pointer. Then we convert it to a mutable reference by dereferencing it (through *) and immediately borrowing it again (through &mut). This conversion requires an unsafe block, since the compiler can’t guarantee that the raw pointer is valid.\nThen it writes the byte b'H' to it. The b prefix creates a byte literal, which represents an ASCII character. By writing the strings \"ello \" and \"Wörld!\", we test our write_string method and the handling of unprintable characters. To see the output, we need to call the print_something function from our _start function:\n// in src/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::print_something();\n\n    loop {}\n}\nWhen we run our project now, a Hello W■■rld! should be printed in the lower left corner of the screen in yellow:\n\n\n\nQEMU output with a yellow Hello W■■rld! in the lower left corner\n\n\nNotice that the ö is printed as two ■ characters. That’s because ö is represented by two bytes in UTF-8, which both don’t fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.\n\n\nVolatile\nWe just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.\nThe problem is that we only write to the Buffer and never read from it again. The compiler doesn’t know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as volatile. This tells the compiler that the write has side effects and should not be optimized away.\nIn order to use volatile writes for the VGA buffer, we use the volatile library. This crate (this is how packages are called in the Rust world) provides a Volatile wrapper type with read and write methods. These methods internally use the read_volatile and write_volatile functions of the core library and thus guarantee that the reads/writes are not optimized away.\nWe can add a dependency on the volatile crate by adding it to the dependencies section of our Cargo.toml:\n# in Cargo.toml\n\n[dependencies]\nvolatile = \"0.2.6\"\nMake sure to specify volatile version 0.2.6. Newer versions of the crate are not compatible with this post. 0.2.6 is the semantic version number. For more information, see the Specifying Dependencies guide of the cargo documentation.\nLet’s use it to make writes to the VGA buffer volatile. We update our Buffer type as follows:\n// in src/vga.rs\n\nuse volatile::Volatile;\n\nstruct Buffer {\n    chars: [[Volatile&lt;ScreenChar&gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}\nInstead of a ScreenChar, we’re now using a Volatile&lt;ScreenChar&gt;. (The Volatile type is generic and can wrap (almost) any type). This ensures that we can’t accidentally write to it “normally”. Instead, we have to use the write method now.\nThis means that we have to update our Writer::write_byte method:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_byte(&mut self, byte: u8) {\n        match byte {\n            b'\\n' =&gt; self.new_line(),\n            byte =&gt; {\n                ...\n\n                self.buffer.chars[row][col].write(ScreenChar {\n                    ascii_character: byte,\n                    color_code,\n                });\n                ...\n            }\n        }\n    }\n    ...\n}\nInstead of a typical assignment using =, we’re now using the write method. Now we can guarantee that the compiler will never optimize away this write.\n\n\nFormatting Macros\nIt would be nice to support Rust’s formatting macros, too. That way, we can easily print different types, like integers or floats. To support them, we need to implement the core::fmt::Write trait. The only required method of this trait is write_str, which looks quite similar to our write_string method, just with a fmt::Result return type:\n// in src/vga.rs\n\nuse core::fmt;\n\nimpl fmt::Write for Writer {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        self.write_string(s);\n        Ok(())\n    }\n}\nThe Ok(()) is just a Ok Result containing the () type.\nNow we can use Rust’s built-in write!/writeln! formatting macros:\n// in src/vga.rs\n\npub fn print_something() {\n    use core::fmt::Write;\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello! \");\n    write!(writer, \"The numbers are {} and {}\", 42, 1.0/3.0).unwrap();\n}\nNow you should see a Hello! The numbers are 42 and 0.3333333333333333 at the bottom of the screen. The write! call returns a Result which causes a warning if not used, so we call the unwrap function on it, which panics if an error occurs. This isn’t a problem in our case, since writes to the VGA buffer never fail.\n\n\nNewlines\nRight now, we just ignore newlines and characters that don’t fit into the line anymore. Instead, we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the new_line method of Writer:\n// in src/vga.rs\n\nimpl Writer {\n    fn new_line(&mut self) {\n        for row in 1..BUFFER_HEIGHT {\n            for col in 0..BUFFER_WIDTH {\n                let character = self.buffer.chars[row][col].read();\n                self.buffer.chars[row - 1][col].write(character);\n            }\n        }\n        self.clear_row(BUFFER_HEIGHT - 1);\n        self.column_position = 0;\n    }\n\n    fn clear_row(&mut self, row: usize) {/* TODO */}\n}\nWe iterate over all the screen characters and move each character one row up. Note that the upper bound of the range notation (..) is exclusive. We also omit the 0th row (the first range starts at 1) because it’s the row that is shifted off screen.\nTo finish the newline code, we add the clear_row method:\n// in src/vga.rs\n\nimpl Writer {\n    fn clear_row(&mut self, row: usize) {\n        let blank = ScreenChar {\n            ascii_character: b' ',\n            color_code: self.color_code,\n        };\n        for col in 0..BUFFER_WIDTH {\n            self.buffer.chars[row][col].write(blank);\n        }\n    }\n}\nThis method clears a row by overwriting all of its characters with a space character.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#test-it",
    "href": "50_text.rjs.html#test-it",
    "title": "Text",
    "section": "Test it",
    "text": "Test it\n\nIt is trivial to test.\n\n\n\nsrc/main.rs\n\n    let hi: &[u8] = b\"Hello World!\";\n    for i in 0..12 {\n        vga::char_to_vga(hi[i]);\n    }\n\n\n“Works on my machine!” - me\n\nUnless?\nWe’ll come back to this."
  },
  {
    "objectID": "50_text.rjs.html#todo",
    "href": "50_text.rjs.html#todo",
    "title": "Text",
    "section": "TODO",
    "text": "TODO\nIf the byte is the newline byte \\n, the writer does not print anything. Instead, it calls a new_line method, which we’ll implement later.uuther bytes get printed to the screen in the second match case.\nWhen printing a byte, the writer checks if the current line is full. In that case, a new_line call is used to wrap the line. Then it writes a new ScreenChar to the buffer at the current position. Finally, the current column position is advanced.\nTo print whole strings, we can convert them to bytes and print them one-by-one:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_string(&mut self, s: &str) {\n        for byte in s.bytes() {\n            match byte {\n                // printable ASCII byte or newline\n                0x20..=0x7e | b'\\n' =&gt; self.write_byte(byte),\n                // not part of printable ASCII range\n                _ =&gt; self.write_byte(0xfe),\n            }\n\n        }\n    }\n}\nThe VGA text buffer only supports ASCII and the additional bytes of code page 437. Rust strings are UTF-8 by default, so they might contain bytes that are not supported by the VGA text buffer. We use a match to differentiate printable ASCII bytes (a newline or anything in between a space character and a ~ character) and unprintable bytes. For unprintable bytes, we print a ■ character, which has the hex code 0xfe on the VGA hardware.\nTry it out!\nTo write some characters to the screen, you can create a temporary function:\n// in src/vga.rs\n\npub fn print_something() {\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello \");\n    writer.write_string(\"Wörld!\");\n}\nIt first creates a new Writer that points to the VGA buffer at 0xb8000. The syntax for this might seem a bit strange: First, we cast the integer 0xb8000 as a mutable raw pointer. Then we convert it to a mutable reference by dereferencing it (through *) and immediately borrowing it again (through &mut). This conversion requires an unsafe block, since the compiler can’t guarantee that the raw pointer is valid.\nThen it writes the byte b'H' to it. The b prefix creates a byte literal, which represents an ASCII character. By writing the strings \"ello \" and \"Wörld!\", we test our write_string method and the handling of unprintable characters. To see the output, we need to call the print_something function from our _start function:\n// in src/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::print_something();\n\n    loop {}\n}\nWhen we run our project now, a Hello W■■rld! should be printed in the lower left corner of the screen in yellow:\n\nQEMU output with a yellow Hello W■■rld! in the lower left cornerNotice that the ö is printed as two ■ characters. That’s because ö is represented by two bytes in UTF-8, which both don’t fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.\nVolatile\nWe just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.\nThe problem is that we only write to the Buffer and never read from it again. The compiler doesn’t know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as volatile. This tells the compiler that the write has side effects and should not be optimized away.\nIn order to use volatile writes for the VGA buffer, we use the volatile library. This crate (this is how packages are called in the Rust world) provides a Volatile wrapper type with read and write methods. These methods internally use the read_volatile and write_volatile functions of the core library and thus guarantee that the reads/writes are not optimized away.\nWe can add a dependency on the volatile crate by adding it to the dependencies section of our Cargo.toml:\n# in Cargo.toml\n\n[dependencies]\nvolatile = \"0.2.6\"\nMake sure to specify volatile version 0.2.6. Newer versions of the crate are not compatible with this post. 0.2.6 is the semantic version number. For more information, see the Specifying Dependencies guide of the cargo documentation.\nLet’s use it to make writes to the VGA buffer volatile. We update our Buffer type as follows:\n// in src/vga.rs\n\nuse volatile::Volatile;\n\nstruct Buffer {\n    chars: [[Volatile&lt;ScreenChar&gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],\n}\nInstead of a ScreenChar, we’re now using a Volatile&lt;ScreenChar&gt;. (The Volatile type is generic and can wrap (almost) any type). This ensures that we can’t accidentally write to it “normally”. Instead, we have to use the write method now.\nThis means that we have to update our Writer::write_byte method:\n// in src/vga.rs\n\nimpl Writer {\n    pub fn write_byte(&mut self, byte: u8) {\n        match byte {\n            b'\\n' =&gt; self.new_line(),\n            byte =&gt; {\n                ...\n\n                self.buffer.chars[row][col].write(ScreenChar {\n                    ascii_character: byte,\n                    color_code,\n                });\n                ...\n            }\n        }\n    }\n    ...\n}\nInstead of a typical assignment using =, we’re now using the write method. Now we can guarantee that the compiler will never optimize away this write.\nFormatting Macros\nIt would be nice to support Rust’s formatting macros, too. That way, we can easily print different types, like integers or floats. To support them, we need to implement the core::fmt::Write trait. The only required method of this trait is write_str, which looks quite similar to our write_string method, just with a fmt::Result return type:\n// in src/vga.rs\n\nuse core::fmt;\n\nimpl fmt::Write for Writer {\n    fn write_str(&mut self, s: &str) -&gt; fmt::Result {\n        self.write_string(s);\n        Ok(())\n    }\n}\nThe Ok(()) is just a Ok Result containing the () type.\nNow we can use Rust’s built-in write!/writeln! formatting macros:\n// in src/vga.rs\n\npub fn print_something() {\n    use core::fmt::Write;\n    let mut writer = Writer {\n        column_position: 0,\n        color_code: ColorCode::new(Color::Yellow, Color::Black),\n        buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },\n    };\n\n    writer.write_byte(b'H');\n    writer.write_string(\"ello! \");\n    write!(writer, \"The numbers are {} and {}\", 42, 1.0/3.0).unwrap();\n}\nNow you should see a Hello! The numbers are 42 and 0.3333333333333333 at the bottom of the screen. The write! call returns a Result which causes a warning if not used, so we call the unwrap function on it, which panics if an error occurs. This isn’t a problem in our case, since writes to the VGA buffer never fail.\nNewlines\nRight now, we just ignore newlines and characters that don’t fit into the line anymore. Instead, we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the new_line method of Writer:\n// in src/vga.rs\n\nimpl Writer {\n    fn new_line(&mut self) {\n        for row in 1..BUFFER_HEIGHT {\n            for col in 0..BUFFER_WIDTH {\n                let character = self.buffer.chars[row][col].read();\n                self.buffer.chars[row - 1][col].write(character);\n            }\n        }\n        self.clear_row(BUFFER_HEIGHT - 1);\n        self.column_position = 0;\n    }\n\n    fn clear_row(&mut self, row: usize) {/* TODO */}\n}\nWe iterate over all the screen characters and move each character one row up. Note that the upper bound of the range notation (..) is exclusive. We also omit the 0th row (the first range starts at 1) because it’s the row that is shifted off screen.\nTo finish the newline code, we add the clear_row method:\n// in src/vga.rs\n\nimpl Writer {\n    fn clear_row(&mut self, row: usize) {\n        let blank = ScreenChar {\n            ascii_character: b' ',\n            color_code: self.color_code,\n        };\n        for col in 0..BUFFER_WIDTH {\n            self.buffer.chars[row][col].write(blank);\n        }\n    }\n}\nThis method clears a row by overwriting all of its characters with a space character."
  },
  {
    "objectID": "50_text.html#annoying",
    "href": "50_text.html#annoying",
    "title": "Text",
    "section": "Annoying",
    "text": "Annoying\n\nSome of you may lack a strong work ethic and want to show entire a whole string rather than just a character at a time.\n\nEspecially since using characters of a string in Rust is ludicrously opaque.\n\nNot to worry.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#target-str",
    "href": "50_text.html#target-str",
    "title": "Text",
    "section": "Target &str",
    "text": "Target &str\n\nWe can abstract to loop into src/vga.rs\n\n\n\nsrc/vga.rs\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#annoying",
    "href": "50_text.rjs.html#annoying",
    "title": "Text",
    "section": "Annoying",
    "text": "Annoying\n\nSome of you may lack a strong work ethic and want to show entire a whole string rather than just a character at a time.\n\nEspecially since using characters of a string in Rust is ludicrously opaque.\n\nNot to worry."
  },
  {
    "objectID": "50_text.rjs.html#target-str",
    "href": "50_text.rjs.html#target-str",
    "title": "Text",
    "section": "Target &str",
    "text": "Target &str\n\nWe can abstract to loop into src/vga.rs\n\n\n\nsrc/vga.rs\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}"
  },
  {
    "objectID": "50_text.html#update-main",
    "href": "50_text.html#update-main",
    "title": "Text",
    "section": "Update main",
    "text": "Update main\n\nLook how nice that is!\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Hello, world!\");\n    loop {}\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#update-main",
    "href": "50_text.rjs.html#update-main",
    "title": "Text",
    "section": "Update main",
    "text": "Update main\n\nLook how nice that is!\n\n\n\nsrc/main.rs\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Hello, world!\");\n    loop {}\n}"
  },
  {
    "objectID": "50_text.html#i-bet",
    "href": "50_text.html#i-bet",
    "title": "Text",
    "section": "I bet…",
    "text": "I bet…\n\nI bet we can print any string.",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#main",
    "href": "50_text.html#main",
    "title": "Text",
    "section": "main",
    "text": "main\n#![no_std]\n#![no_main]\n\nmod vga;\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\");\n    loop {}\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.html#vga",
    "href": "50_text.html#vga",
    "title": "Text",
    "section": "vga",
    "text": "vga\nstatic mut LATEST: usize = 0;\nconst MMIO: *mut u8 = 0xb8000 as *mut u8;\nconst COLOR: u8 = 0xF;\n\nfn char_to_vga(a: u8) {\n    unsafe {\n        let rel: *mut u8 = ((MMIO as usize) + (LATEST * 2)) as *mut u8;\n        *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n        LATEST = LATEST + 1;\n    }\n}\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}",
    "crumbs": [
      "Text"
    ]
  },
  {
    "objectID": "50_text.rjs.html#i-bet",
    "href": "50_text.rjs.html#i-bet",
    "title": "Text",
    "section": "I bet…",
    "text": "I bet…\n\nI bet we can print any string."
  },
  {
    "objectID": "50_text.rjs.html#main",
    "href": "50_text.rjs.html#main",
    "title": "Text",
    "section": "main",
    "text": "main\n#![no_std]\n#![no_main]\n\nmod vga;\n\n#[panic_handler]\n#[allow(unconditional_recursion)]\nfn panic(info: &core::panic::PanicInfo) -&gt; ! {\n    panic(info)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn _start() -&gt; ! {\n    vga::str_to_vga(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\");\n    loop {}\n}"
  },
  {
    "objectID": "50_text.rjs.html#vga",
    "href": "50_text.rjs.html#vga",
    "title": "Text",
    "section": "vga",
    "text": "vga\nstatic mut LATEST: usize = 0;\nconst MMIO: *mut u8 = 0xb8000 as *mut u8;\nconst COLOR: u8 = 0xF;\n\nfn char_to_vga(a: u8) {\n    unsafe {\n        let rel: *mut u8 = ((MMIO as usize) + (LATEST * 2)) as *mut u8;\n        *rel = a;\n        *((rel as usize + 1) as *mut u8) = COLOR;\n        LATEST = LATEST + 1;\n    }\n}\n\npub fn str_to_vga(s: &str) {\n    let v = s.as_bytes();\n    for i in 0..v.len() {\n        char_to_vga(v[i]);\n    }\n}"
  }
]