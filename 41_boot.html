<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Boot – OS in Rust</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./40_kernel.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-a4a11d514c7d463668e07712114998e6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-fc9c1a4fc1048689359919db0170c3de.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./41_boot.html">Boot</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">OS in Rust</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_derust.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Derust</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_wc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">wc</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_cli.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CLI</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_unsafe.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Unsafe</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_split_at.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Splits</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_os.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">OS</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21_xmute.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Transmute</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22_malloc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">malloc</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./30_metal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bare Metal</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./31_linker.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linker</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./32_r5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RISC-V</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./40_kernel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Kernel</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./41_boot.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Boot</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#printing-to-screen" id="toc-printing-to-screen" class="nav-link active" data-scroll-target="#printing-to-screen">Printing to Screen</a></li>
  <li><a href="#running-our-kernel" id="toc-running-our-kernel" class="nav-link" data-scroll-target="#running-our-kernel">Running our Kernel</a></li>
  <li><a href="#creating-a-bootimage" id="toc-creating-a-bootimage" class="nav-link" data-scroll-target="#creating-a-bootimage">Creating a Bootimage</a></li>
  <li><a href="#how-does-it-work" id="toc-how-does-it-work" class="nav-link" data-scroll-target="#how-does-it-work">How does it work?</a></li>
  <li><a href="#booting-it-in-qemu" id="toc-booting-it-in-qemu" class="nav-link" data-scroll-target="#booting-it-in-qemu">Booting it in QEMU</a></li>
  <li><a href="#real-machine" id="toc-real-machine" class="nav-link" data-scroll-target="#real-machine">Real Machine</a></li>
  <li><a href="#using-cargo-run" id="toc-using-cargo-run" class="nav-link" data-scroll-target="#using-cargo-run">Using <code>cargo run</code></a></li>
  <li><a href="#whats-next" id="toc-whats-next" class="nav-link" data-scroll-target="#whats-next">What’s next?</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Boot</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i></button></div></div>
<p class="subtitle lead">OS in Rust</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="printing-to-screen" class="level2">
<h2 class="anchored" data-anchor-id="printing-to-screen">Printing to Screen</h2>
<p>The easiest way to print text to the screen at this stage is the <a href="https://en.wikipedia.org/wiki/VGA-compatible_text_mode">VGA text buffer</a>. It is a special memory area mapped to the VGA hardware that contains the contents displayed on screen. It normally consists of 25 lines that each contain 80 character cells. Each character cell displays an ASCII character with some foreground and background colors. The screen output looks like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Codepage-437.png" class="img-fluid figure-img"></p>
<figcaption>screen output for common ASCII characters</figcaption>
</figure>
</div>
<p>We will discuss the exact layout of the VGA buffer in the next post, where we write a first small driver for it. For printing “Hello World!”, we just need to know that the buffer is located at address <code>0xb8000</code> and that each character cell consists of an ASCII byte and a color byte.</p>
<p>The implementation looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">static</span> HELLO<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>] <span class="op">=</span> <span class="st">b"Hello World!"</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="at">#[</span><span class="kw">unsafe</span><span class="at">(</span>no_mangle<span class="at">)]</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"C"</span> <span class="kw">fn</span> _start() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="kw">let</span> vga_buffer <span class="op">=</span> <span class="dv">0xb8000</span> <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u8</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="cf">for</span> (i<span class="op">,</span> <span class="op">&amp;</span>byte) <span class="kw">in</span> HELLO<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>            <span class="op">*</span>vga_buffer<span class="op">.</span>offset(i <span class="kw">as</span> <span class="dt">isize</span> <span class="op">*</span> <span class="dv">2</span>) <span class="op">=</span> byte<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>            <span class="op">*</span>vga_buffer<span class="op">.</span>offset(i <span class="kw">as</span> <span class="dt">isize</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">=</span> <span class="dv">0xb</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="cf">loop</span> <span class="op">{}</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>First, we cast the integer <code>0xb8000</code> into a <a href="https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html#dereferencing-a-raw-pointer">raw pointer</a>. Then we <a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">iterate</a> over the bytes of the <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime">static</a> <code>HELLO</code> <a href="https://doc.rust-lang.org/reference/tokens.html#byte-string-literals">byte string</a>. We use the <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a> method to additionally get a running variable <code>i</code>. In the body of the for loop, we use the <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>offset</code></a> method to write the string byte and the corresponding color byte (<code>0xb</code> is a light cyan).</p>
<p>Note that there’s an <a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html"><code>unsafe</code></a> block around all memory writes. The reason is that the Rust compiler can’t prove that the raw pointers we create are valid. They could point anywhere and lead to data corruption. By putting them into an <code>unsafe</code> block, we’re basically telling the compiler that we are absolutely sure that the operations are valid. Note that an <code>unsafe</code> block does not turn off Rust’s safety checks. It only allows you to do <a href="https://doc.rust-lang.org/stable/book/ch20-01-unsafe-rust.html#unsafe-superpowers">five additional things</a>.</p>
<p>I want to emphasize that <strong>this is not the way we want to do things in Rust!</strong> It’s very easy to mess up when working with raw pointers inside unsafe blocks. For example, we could easily write beyond the buffer’s end if we’re not careful.</p>
<p>So we want to minimize the use of <code>unsafe</code> as much as possible. Rust gives us the ability to do this by creating safe abstractions. For example, we could create a VGA buffer type that encapsulates all unsafety and ensures that it is <em>impossible</em> to do anything wrong from the outside. This way, we would only need minimal amounts of <code>unsafe</code> code and can be sure that we don’t violate <a href="https://en.wikipedia.org/wiki/Memory_safety">memory safety</a>. We will create such a safe VGA buffer abstraction in the next post.</p>
</section>
<section id="running-our-kernel" class="level2">
<h2 class="anchored" data-anchor-id="running-our-kernel">Running our Kernel</h2>
<p>Now that we have an executable that does something perceptible, it is time to run it. First, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader. Then we can run the disk image in the <a href="https://www.qemu.org/">QEMU</a> virtual machine or boot it on real hardware using a USB stick.</p>
</section>
<section id="creating-a-bootimage" class="level2">
<h2 class="anchored" data-anchor-id="creating-a-bootimage">Creating a Bootimage</h2>
<p>To turn our compiled kernel into a bootable disk image, we need to link it with a bootloader. As we learned in the <a href="#the-boot-process">section about booting</a>, the bootloader is responsible for initializing the CPU and loading our kernel.</p>
<p>Instead of writing our own bootloader, which is a project on its own, we use the <a href="https://crates.io/crates/bootloader"><code>bootloader</code></a> crate. This crate implements a basic BIOS bootloader without any C dependencies, just Rust and inline assembly. To use it for booting our kernel, we need to add a dependency on it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource toml number-lines code-with-copy"><code class="sourceCode toml"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># in Cargo.toml</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">[dependencies]</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="dt">bootloader</span> <span class="op">=</span> <span class="st">"0.9"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Note:</strong> This post is only compatible with <code>bootloader v0.9</code>. Newer versions use a different build system and will result in build errors when following this post.</p>
<p>Adding the bootloader as a dependency is not enough to actually create a bootable disk image. The problem is that we need to link our kernel with the bootloader after compilation, but cargo has no support for <a href="https://github.com/rust-lang/cargo/issues/545">post-build scripts</a>.</p>
<p>To solve this problem, we created a tool named <code>bootimage</code> that first compiles the kernel and bootloader, and then links them together to create a bootable disk image. To install the tool, go into your home directory (or any directory outside of your cargo project) and execute the following command in your terminal:</p>
<pre><code>cargo install bootimage</code></pre>
<p>For running <code>bootimage</code> and building the bootloader, you need to have the <code>llvm-tools-preview</code> rustup component installed. You can do so by executing <code>rustup component add llvm-tools-preview</code>.</p>
<p>After installing <code>bootimage</code> and adding the <code>llvm-tools-preview</code> component, you can create a bootable disk image by going back into your cargo project directory and executing:</p>
<pre><code>&gt; cargo bootimage</code></pre>
<p>We see that the tool recompiles our kernel using <code>cargo build</code>, so it will automatically pick up any changes you make. Afterwards, it compiles the bootloader, which might take a while. Like all crate dependencies, it is only built once and then cached, so subsequent builds will be much faster. Finally, <code>bootimage</code> combines the bootloader and your kernel into a bootable disk image.</p>
<p>After executing the command, you should see a bootable disk image named <code>bootimage-blog_os.bin</code> in your <code>target/x86_64-blog_os/debug</code> directory. You can boot it in a virtual machine or copy it to a USB drive to boot it on real hardware. (Note that this is not a CD image, which has a different format, so burning it to a CD doesn’t work).</p>
</section>
<section id="how-does-it-work" class="level2">
<h2 class="anchored" data-anchor-id="how-does-it-work">How does it work?</h2>
<p>The <code>bootimage</code> tool performs the following steps behind the scenes:</p>
<ul>
<li>It compiles our kernel to an <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> file.</li>
<li>It compiles the bootloader dependency as a standalone executable.</li>
<li>It links the bytes of the kernel ELF file to the bootloader.</li>
</ul>
<p>When booted, the bootloader reads and parses the appended ELF file. It then maps the program segments to virtual addresses in the page tables, zeroes the <code>.bss</code> section, and sets up a stack. Finally, it reads the entry point address (our <code>_start</code> function) and jumps to it.</p>
</section>
<section id="booting-it-in-qemu" class="level2">
<h2 class="anchored" data-anchor-id="booting-it-in-qemu">Booting it in QEMU</h2>
<p>We can now boot the disk image in a virtual machine. To boot it in <a href="https://www.qemu.org/">QEMU</a>, execute the following command:</p>
<pre><code>&gt; qemu-system-x86_64 -drive format=raw,file=target/x86_64-blog_os/debug/bootimage-blog_os.bin</code></pre>
<p>This opens a separate window which should look similar to this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qemu.png" class="img-fluid figure-img"></p>
<figcaption>QEMU showing “Hello World!”</figcaption>
</figure>
</div>
<p>We see that our “Hello World!” is visible on the screen.</p>
</section>
<section id="real-machine" class="level2">
<h2 class="anchored" data-anchor-id="real-machine">Real Machine</h2>
<p>It is also possible to write it to a USB stick and boot it on a real machine, <strong>but be careful</strong> to choose the correct device name, because <strong>everything on that device is overwritten</strong>:</p>
<pre><code>&gt; dd if=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX &amp;&amp; sync</code></pre>
<p>Where <code>sdX</code> is the device name of your USB stick.</p>
<p>After writing the image to the USB stick, you can run it on real hardware by booting from it. You probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick. Note that it currently doesn’t work for UEFI machines, since the <code>bootloader</code> crate has no UEFI support yet.</p>
</section>
<section id="using-cargo-run" class="level2">
<h2 class="anchored" data-anchor-id="using-cargo-run">Using <code>cargo run</code></h2>
<p>To make it easier to run our kernel in QEMU, we can set the <code>runner</code> configuration key for cargo:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource toml number-lines code-with-copy"><code class="sourceCode toml"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># in .cargo/config.toml</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">[target.'</span><span class="dt">cfg(target_os = "none")'</span><span class="kw">]</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="dt">runner</span> <span class="op">=</span> <span class="st">"bootimage runner"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>target.'cfg(target_os = "none")'</code> table applies to all targets whose target configuration file’s <code>"os"</code> field is set to <code>"none"</code>. This includes our <code>x86_64-blog_os.json</code> target. The <code>runner</code> key specifies the command that should be invoked for <code>cargo run</code>. The command is run after a successful build with the executable path passed as the first argument. See the [cargo documentation][cargo configuration] for more details.</p>
<p>The <code>bootimage runner</code> command is specifically designed to be usable as a <code>runner</code> executable. It links the given executable with the project’s bootloader dependency and then launches QEMU. See the <a href="https://github.com/rust-osdev/bootimage">Readme of <code>bootimage</code></a> for more details and possible configuration options.</p>
<p>Now we can use <code>cargo run</code> to compile our kernel and boot it in QEMU.</p>
</section>
<section id="whats-next" class="level2">
<h2 class="anchored" data-anchor-id="whats-next">What’s next?</h2>
<p>In the next post, we will explore the VGA text buffer in more detail and write a safe interface for it. We will also add support for the <code>println</code> macro.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./40_kernel.html" class="pagination-link" aria-label="Kernel">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Kernel</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb8" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">---</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="an">title:</span><span class="co"> Boot</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="an">format:</span><span class="co"> html</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">---</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="fu">## Printing to Screen</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>The easiest way to print text to the screen at this stage is the <span class="co">[</span><span class="ot">VGA text buffer</span><span class="co">]</span>. It is a special memory area mapped to the VGA hardware that contains the contents displayed on screen. It normally consists of 25 lines that each contain 80 character cells. Each character cell displays an ASCII character with some foreground and background colors. The screen output looks like this:</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="ot">[VGA text buffer]: https://en.wikipedia.org/wiki/VGA-compatible_text_mode</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="al">![screen output for common ASCII characters](https://upload.wikimedia.org/wikipedia/commons/f/f8/Codepage-437.png)</span></span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a>We will discuss the exact layout of the VGA buffer in the next post, where we write a first small driver for it. For printing “Hello World!”, we just need to know that the buffer is located at address <span class="in">`0xb8000`</span> and that each character cell consists of an ASCII byte and a color byte.</span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a>The implementation looks like this:</span>
<span id="cb8-16"><a href="#cb8-16"></a></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="in">```rust</span></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="kw">static</span> HELLO<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>] <span class="op">=</span> <span class="st">b"Hello World!"</span><span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19"></a></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="at">#[</span><span class="kw">unsafe</span><span class="at">(</span>no_mangle<span class="at">)]</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"C"</span> <span class="kw">fn</span> _start() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="kw">let</span> vga_buffer <span class="op">=</span> <span class="dv">0xb8000</span> <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u8</span><span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23"></a></span>
<span id="cb8-24"><a href="#cb8-24"></a>    <span class="cf">for</span> (i<span class="op">,</span> <span class="op">&amp;</span>byte) <span class="kw">in</span> HELLO<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>            <span class="op">*</span>vga_buffer<span class="op">.</span>offset(i <span class="kw">as</span> <span class="dt">isize</span> <span class="op">*</span> <span class="dv">2</span>) <span class="op">=</span> byte<span class="op">;</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>            <span class="op">*</span>vga_buffer<span class="op">.</span>offset(i <span class="kw">as</span> <span class="dt">isize</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">=</span> <span class="dv">0xb</span><span class="op">;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>        <span class="op">}</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>    <span class="op">}</span></span>
<span id="cb8-30"><a href="#cb8-30"></a></span>
<span id="cb8-31"><a href="#cb8-31"></a>    <span class="cf">loop</span> <span class="op">{}</span></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="op">}</span></span>
<span id="cb8-33"><a href="#cb8-33"></a><span class="in">```</span></span>
<span id="cb8-34"><a href="#cb8-34"></a></span>
<span id="cb8-35"><a href="#cb8-35"></a>First, we cast the integer <span class="in">`0xb8000`</span> into a <span class="co">[</span><span class="ot">raw pointer</span><span class="co">]</span>. Then we <span class="co">[</span><span class="ot">iterate</span><span class="co">]</span> over the bytes of the <span class="co">[</span><span class="ot">static</span><span class="co">]</span> <span class="in">`HELLO`</span> <span class="co">[</span><span class="ot">byte string</span><span class="co">]</span>. We use the <span class="co">[</span><span class="ot">`enumerate`</span><span class="co">]</span> method to additionally get a running variable <span class="in">`i`</span>. In the body of the for loop, we use the <span class="co">[</span><span class="ot">`offset`</span><span class="co">]</span> method to write the string byte and the corresponding color byte (<span class="in">`0xb`</span> is a light cyan).</span>
<span id="cb8-36"><a href="#cb8-36"></a></span>
<span id="cb8-37"><a href="#cb8-37"></a><span class="ot">[iterate]: https://doc.rust-lang.org/stable/book/ch13-02-iterators.html</span></span>
<span id="cb8-38"><a href="#cb8-38"></a><span class="ot">[static]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime</span></span>
<span id="cb8-39"><a href="#cb8-39"></a><span class="ot">[`enumerate`]: https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate</span></span>
<span id="cb8-40"><a href="#cb8-40"></a><span class="ot">[byte string]: https://doc.rust-lang.org/reference/tokens.html#byte-string-literals</span></span>
<span id="cb8-41"><a href="#cb8-41"></a><span class="ot">[raw pointer]: https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html#dereferencing-a-raw-pointer</span></span>
<span id="cb8-42"><a href="#cb8-42"></a><span class="ot">[`offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.offset</span></span>
<span id="cb8-43"><a href="#cb8-43"></a></span>
<span id="cb8-44"><a href="#cb8-44"></a>Note that there's an <span class="co">[</span><span class="ot">`unsafe`</span><span class="co">]</span> block around all memory writes. The reason is that the Rust compiler can't prove that the raw pointers we create are valid. They could point anywhere and lead to data corruption. By putting them into an <span class="in">`unsafe`</span> block, we're basically telling the compiler that we are absolutely sure that the operations are valid. Note that an <span class="in">`unsafe`</span> block does not turn off Rust's safety checks. It only allows you to do <span class="co">[</span><span class="ot">five additional things</span><span class="co">]</span>.</span>
<span id="cb8-45"><a href="#cb8-45"></a></span>
<span id="cb8-46"><a href="#cb8-46"></a><span class="ot">[`unsafe`]: https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html</span></span>
<span id="cb8-47"><a href="#cb8-47"></a><span class="ot">[five additional things]: https://doc.rust-lang.org/stable/book/ch20-01-unsafe-rust.html#unsafe-superpowers</span></span>
<span id="cb8-48"><a href="#cb8-48"></a></span>
<span id="cb8-49"><a href="#cb8-49"></a>I want to emphasize that **this is not the way we want to do things in Rust!** It's very easy to mess up when working with raw pointers inside unsafe blocks. For example, we could easily write beyond the buffer's end if we're not careful.</span>
<span id="cb8-50"><a href="#cb8-50"></a></span>
<span id="cb8-51"><a href="#cb8-51"></a>So we want to minimize the use of <span class="in">`unsafe`</span> as much as possible. Rust gives us the ability to do this by creating safe abstractions. For example, we could create a VGA buffer type that encapsulates all unsafety and ensures that it is _impossible_ to do anything wrong from the outside. This way, we would only need minimal amounts of <span class="in">`unsafe`</span> code and can be sure that we don't violate <span class="co">[</span><span class="ot">memory safety</span><span class="co">]</span>. We will create such a safe VGA buffer abstraction in the next post.</span>
<span id="cb8-52"><a href="#cb8-52"></a></span>
<span id="cb8-53"><a href="#cb8-53"></a><span class="ot">[memory safety]: https://en.wikipedia.org/wiki/Memory_safety</span></span>
<span id="cb8-54"><a href="#cb8-54"></a></span>
<span id="cb8-55"><a href="#cb8-55"></a><span class="fu">## Running our Kernel</span></span>
<span id="cb8-56"><a href="#cb8-56"></a></span>
<span id="cb8-57"><a href="#cb8-57"></a>Now that we have an executable that does something perceptible, it is time to run it. First, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader. Then we can run the disk image in the <span class="co">[</span><span class="ot">QEMU</span><span class="co">]</span> virtual machine or boot it on real hardware using a USB stick.</span>
<span id="cb8-58"><a href="#cb8-58"></a></span>
<span id="cb8-59"><a href="#cb8-59"></a><span class="fu">## Creating a Bootimage</span></span>
<span id="cb8-60"><a href="#cb8-60"></a></span>
<span id="cb8-61"><a href="#cb8-61"></a>To turn our compiled kernel into a bootable disk image, we need to link it with a bootloader. As we learned in the <span class="co">[</span><span class="ot">section about booting</span><span class="co">]</span>, the bootloader is responsible for initializing the CPU and loading our kernel.</span>
<span id="cb8-62"><a href="#cb8-62"></a></span>
<span id="cb8-63"><a href="#cb8-63"></a><span class="ot">[section about booting]: #the-boot-process</span></span>
<span id="cb8-64"><a href="#cb8-64"></a></span>
<span id="cb8-65"><a href="#cb8-65"></a>Instead of writing our own bootloader, which is a project on its own, we use the <span class="co">[</span><span class="ot">`bootloader`</span><span class="co">]</span> crate. This crate implements a basic BIOS bootloader without any C dependencies, just Rust and inline assembly. To use it for booting our kernel, we need to add a dependency on it:</span>
<span id="cb8-66"><a href="#cb8-66"></a></span>
<span id="cb8-67"><a href="#cb8-67"></a><span class="ot">[`bootloader`]: https://crates.io/crates/bootloader</span></span>
<span id="cb8-68"><a href="#cb8-68"></a></span>
<span id="cb8-69"><a href="#cb8-69"></a><span class="in">```toml</span></span>
<span id="cb8-70"><a href="#cb8-70"></a><span class="in"># in Cargo.toml</span></span>
<span id="cb8-71"><a href="#cb8-71"></a></span>
<span id="cb8-72"><a href="#cb8-72"></a><span class="in">[dependencies]</span></span>
<span id="cb8-73"><a href="#cb8-73"></a><span class="in">bootloader = "0.9"</span></span>
<span id="cb8-74"><a href="#cb8-74"></a><span class="in">```</span></span>
<span id="cb8-75"><a href="#cb8-75"></a></span>
<span id="cb8-76"><a href="#cb8-76"></a>**Note:** This post is only compatible with <span class="in">`bootloader v0.9`</span>. Newer versions use a different build system and will result in build errors when following this post.</span>
<span id="cb8-77"><a href="#cb8-77"></a></span>
<span id="cb8-78"><a href="#cb8-78"></a>Adding the bootloader as a dependency is not enough to actually create a bootable disk image. The problem is that we need to link our kernel with the bootloader after compilation, but cargo has no support for <span class="co">[</span><span class="ot">post-build scripts</span><span class="co">]</span>.</span>
<span id="cb8-79"><a href="#cb8-79"></a></span>
<span id="cb8-80"><a href="#cb8-80"></a><span class="ot">[post-build scripts]: https://github.com/rust-lang/cargo/issues/545</span></span>
<span id="cb8-81"><a href="#cb8-81"></a></span>
<span id="cb8-82"><a href="#cb8-82"></a>To solve this problem, we created a tool named <span class="in">`bootimage`</span> that first compiles the kernel and bootloader, and then links them together to create a bootable disk image. To install the tool, go into your home directory (or any directory outside of your cargo project) and execute the following command in your terminal:</span>
<span id="cb8-83"><a href="#cb8-83"></a></span>
<span id="cb8-84"><a href="#cb8-84"></a><span class="in">```</span></span>
<span id="cb8-85"><a href="#cb8-85"></a><span class="in">cargo install bootimage</span></span>
<span id="cb8-86"><a href="#cb8-86"></a><span class="in">```</span></span>
<span id="cb8-87"><a href="#cb8-87"></a></span>
<span id="cb8-88"><a href="#cb8-88"></a>For running <span class="in">`bootimage`</span> and building the bootloader, you need to have the <span class="in">`llvm-tools-preview`</span> rustup component installed. You can do so by executing <span class="in">`rustup component add llvm-tools-preview`</span>.</span>
<span id="cb8-89"><a href="#cb8-89"></a></span>
<span id="cb8-90"><a href="#cb8-90"></a>After installing <span class="in">`bootimage`</span> and adding the <span class="in">`llvm-tools-preview`</span> component, you can create a bootable disk image by going back into your cargo project directory and executing:</span>
<span id="cb8-91"><a href="#cb8-91"></a></span>
<span id="cb8-92"><a href="#cb8-92"></a><span class="in">```</span></span>
<span id="cb8-93"><a href="#cb8-93"></a><span class="in">&gt; cargo bootimage</span></span>
<span id="cb8-94"><a href="#cb8-94"></a><span class="in">```</span></span>
<span id="cb8-95"><a href="#cb8-95"></a></span>
<span id="cb8-96"><a href="#cb8-96"></a>We see that the tool recompiles our kernel using <span class="in">`cargo build`</span>, so it will automatically pick up any changes you make. Afterwards, it compiles the bootloader, which might take a while. Like all crate dependencies, it is only built once and then cached, so subsequent builds will be much faster. Finally, <span class="in">`bootimage`</span> combines the bootloader and your kernel into a bootable disk image.</span>
<span id="cb8-97"><a href="#cb8-97"></a></span>
<span id="cb8-98"><a href="#cb8-98"></a>After executing the command, you should see a bootable disk image named <span class="in">`bootimage-blog_os.bin`</span> in your <span class="in">`target/x86_64-blog_os/debug`</span> directory. You can boot it in a virtual machine or copy it to a USB drive to boot it on real hardware. (Note that this is not a CD image, which has a different format, so burning it to a CD doesn't work).</span>
<span id="cb8-99"><a href="#cb8-99"></a></span>
<span id="cb8-100"><a href="#cb8-100"></a><span class="fu">## How does it work?</span></span>
<span id="cb8-101"><a href="#cb8-101"></a>The <span class="in">`bootimage`</span> tool performs the following steps behind the scenes:</span>
<span id="cb8-102"><a href="#cb8-102"></a></span>
<span id="cb8-103"><a href="#cb8-103"></a><span class="ss">- </span>It compiles our kernel to an <span class="co">[</span><span class="ot">ELF</span><span class="co">]</span> file.</span>
<span id="cb8-104"><a href="#cb8-104"></a><span class="ss">- </span>It compiles the bootloader dependency as a standalone executable.</span>
<span id="cb8-105"><a href="#cb8-105"></a><span class="ss">- </span>It links the bytes of the kernel ELF file to the bootloader.</span>
<span id="cb8-106"><a href="#cb8-106"></a></span>
<span id="cb8-107"><a href="#cb8-107"></a><span class="ot">[ELF]: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</span></span>
<span id="cb8-108"><a href="#cb8-108"></a><span class="ot">[rust-osdev/bootloader]: https://github.com/rust-osdev/bootloader</span></span>
<span id="cb8-109"><a href="#cb8-109"></a></span>
<span id="cb8-110"><a href="#cb8-110"></a>When booted, the bootloader reads and parses the appended ELF file. It then maps the program segments to virtual addresses in the page tables, zeroes the <span class="in">`.bss`</span> section, and sets up a stack. Finally, it reads the entry point address (our <span class="in">`_start`</span> function) and jumps to it.</span>
<span id="cb8-111"><a href="#cb8-111"></a></span>
<span id="cb8-112"><a href="#cb8-112"></a><span class="fu">## Booting it in QEMU</span></span>
<span id="cb8-113"><a href="#cb8-113"></a></span>
<span id="cb8-114"><a href="#cb8-114"></a>We can now boot the disk image in a virtual machine. To boot it in <span class="co">[</span><span class="ot">QEMU</span><span class="co">]</span>, execute the following command:</span>
<span id="cb8-115"><a href="#cb8-115"></a></span>
<span id="cb8-116"><a href="#cb8-116"></a><span class="ot">[QEMU]: https://www.qemu.org/</span></span>
<span id="cb8-117"><a href="#cb8-117"></a></span>
<span id="cb8-118"><a href="#cb8-118"></a><span class="in">```</span></span>
<span id="cb8-119"><a href="#cb8-119"></a><span class="in">&gt; qemu-system-x86_64 -drive format=raw,file=target/x86_64-blog_os/debug/bootimage-blog_os.bin</span></span>
<span id="cb8-120"><a href="#cb8-120"></a><span class="in">```</span></span>
<span id="cb8-121"><a href="#cb8-121"></a></span>
<span id="cb8-122"><a href="#cb8-122"></a>This opens a separate window which should look similar to this:</span>
<span id="cb8-123"><a href="#cb8-123"></a></span>
<span id="cb8-124"><a href="#cb8-124"></a><span class="al">![QEMU showing "Hello World!"](qemu.png)</span></span>
<span id="cb8-125"><a href="#cb8-125"></a></span>
<span id="cb8-126"><a href="#cb8-126"></a>We see that our "Hello World!" is visible on the screen.</span>
<span id="cb8-127"><a href="#cb8-127"></a></span>
<span id="cb8-128"><a href="#cb8-128"></a><span class="fu">## Real Machine</span></span>
<span id="cb8-129"><a href="#cb8-129"></a></span>
<span id="cb8-130"><a href="#cb8-130"></a>It is also possible to write it to a USB stick and boot it on a real machine, **but be careful** to choose the correct device name, because **everything on that device is overwritten**:</span>
<span id="cb8-131"><a href="#cb8-131"></a></span>
<span id="cb8-132"><a href="#cb8-132"></a><span class="in">```</span></span>
<span id="cb8-133"><a href="#cb8-133"></a><span class="in">&gt; dd if=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX &amp;&amp; sync</span></span>
<span id="cb8-134"><a href="#cb8-134"></a><span class="in">```</span></span>
<span id="cb8-135"><a href="#cb8-135"></a></span>
<span id="cb8-136"><a href="#cb8-136"></a>Where <span class="in">`sdX`</span> is the device name of your USB stick. </span>
<span id="cb8-137"><a href="#cb8-137"></a></span>
<span id="cb8-138"><a href="#cb8-138"></a>After writing the image to the USB stick, you can run it on real hardware by booting from it. You probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick. Note that it currently doesn't work for UEFI machines, since the <span class="in">`bootloader`</span> crate has no UEFI support yet.</span>
<span id="cb8-139"><a href="#cb8-139"></a></span>
<span id="cb8-140"><a href="#cb8-140"></a><span class="fu">## Using `cargo run`</span></span>
<span id="cb8-141"><a href="#cb8-141"></a></span>
<span id="cb8-142"><a href="#cb8-142"></a>To make it easier to run our kernel in QEMU, we can set the <span class="in">`runner`</span> configuration key for cargo:</span>
<span id="cb8-143"><a href="#cb8-143"></a></span>
<span id="cb8-144"><a href="#cb8-144"></a><span class="in">```toml</span></span>
<span id="cb8-145"><a href="#cb8-145"></a><span class="in"># in .cargo/config.toml</span></span>
<span id="cb8-146"><a href="#cb8-146"></a></span>
<span id="cb8-147"><a href="#cb8-147"></a><span class="in">[target.'cfg(target_os = "none")']</span></span>
<span id="cb8-148"><a href="#cb8-148"></a><span class="in">runner = "bootimage runner"</span></span>
<span id="cb8-149"><a href="#cb8-149"></a><span class="in">```</span></span>
<span id="cb8-150"><a href="#cb8-150"></a></span>
<span id="cb8-151"><a href="#cb8-151"></a>The <span class="in">`target.'cfg(target_os = "none")'`</span> table applies to all targets whose target configuration file's <span class="in">`"os"`</span> field is set to <span class="in">`"none"`</span>. This includes our <span class="in">`x86_64-blog_os.json`</span> target. The <span class="in">`runner`</span> key specifies the command that should be invoked for <span class="in">`cargo run`</span>. The command is run after a successful build with the executable path passed as the first argument. See the <span class="co">[</span><span class="ot">cargo documentation</span><span class="co">][cargo configuration]</span> for more details.</span>
<span id="cb8-152"><a href="#cb8-152"></a></span>
<span id="cb8-153"><a href="#cb8-153"></a>The <span class="in">`bootimage runner`</span> command is specifically designed to be usable as a <span class="in">`runner`</span> executable. It links the given executable with the project's bootloader dependency and then launches QEMU. See the <span class="co">[</span><span class="ot">Readme of `bootimage`</span><span class="co">]</span> for more details and possible configuration options.</span>
<span id="cb8-154"><a href="#cb8-154"></a></span>
<span id="cb8-155"><a href="#cb8-155"></a><span class="ot">[Readme of `bootimage`]: https://github.com/rust-osdev/bootimage</span></span>
<span id="cb8-156"><a href="#cb8-156"></a></span>
<span id="cb8-157"><a href="#cb8-157"></a>Now we can use <span class="in">`cargo run`</span> to compile our kernel and boot it in QEMU.</span>
<span id="cb8-158"><a href="#cb8-158"></a></span>
<span id="cb8-159"><a href="#cb8-159"></a><span class="fu">## What's next?</span></span>
<span id="cb8-160"><a href="#cb8-160"></a></span>
<span id="cb8-161"><a href="#cb8-161"></a>In the next post, we will explore the VGA text buffer in more detail and write a safe interface for it. We will also add support for the <span class="in">`println`</span> macro.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>