---
title: Text
---

## Announcements

- **Action Items**:
  - Do you text output yet?
    - The coolest assignment ever for a third week in a row.
    - How do I keep getting away with it.

## Citations

- I tried to steal this but I thought it was too bad and changed everything. 
    - [VGA Text Mode](https://os.phil-opp.com/vga-text-mode/)

# Background

## VGA Text Mode

- We recall [VGA text mode](https://en.wikipedia.org/wiki/VGA-compatible_text_mode) from the homework. 
    - A simple way to print text to the screen. 
- We recall that Rust prints via a "macro"
- Now we:
    - Create an interface to encapsulating all unsafety in a separate module. 
    - We also implement support for Rust's [formatting macros](https://en.wikipedia.org/wiki/VGA-compatible_text_mode)
    
## The Buffer

- To print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware. 
    - A byte passing over a bus to fixed location will render as ASCII on a screen.

## 1d or 2d

- The VGA text buffer renders as two-dimensional array.
    - Addressed as a one dimensional array.
    - Safe to assume 25 rows and 80 columns.
    - Each position is an ASCII (*not* unicode) character.
    
## Format

- Describes a single screen character through the following format:

| Bit(s) | Value            |
| ------ | ---------------- |
| 0-7    | ASCII code point |
| 8-11   | Foreground color |
| 12-14  | Background color |
| 15     | Blink            |

- I did not see blinking. 

## First Byte

- The first byte represents the character that should be printed in the [ASCII encoding]. 
    - We recall we say many mentions of Python in firmware jobs.
```{.sh}
python3 -c "[print(chr(a), ':', a) for a in range(ord('A'), ord('z')+1)]"
```

## Except

- Okay it isn't actually ASCII.
- It's [_code page 437_](https://en.wikipedia.org/wiki/Code_page_437)
- We think of it as an IBM specific ASCII extension and just use the ASCII subset.

## Second Byte

- The second **byte** defines how the character is displayed. 
    - The first **four** bits define the foreground color.
    - The next three bits the background color
    - *Nominally* the last bit whether the character should blink.
        - I did not see blinking.
        - May be a `qemu` thing I'm not sure.

## Colors {.smaller} 
        
- Using octal.

| Number | Color      | Bright   | Bright Color |
| ------ | ---------- | ------------------- | ------------ |
| 0o00    | Black      | 0o10                 | Dark Gray    |
| 0o01    | Blue       | 0o11                 | Light Blue   |
| 0o02    | Green      | 0o12                 | Light Green  |
| 0o03    | Cyan       | 0o13                 | Light Cyan   |
| 0o04    | Red        | 0o14                 | Light Red    |
| 0o05    | Magenta    | 0o15                 | Pink         |
| 0o06    | Brown      | 0o16                 | Yellow       |
| 0o07    | Light Gray | 0o17                 | White        |

## Bright/Blink

- Bit 4 is the _bright bit_.
    - For example, blue into light blue. 
- For the background color, this bit is nominally repurposed as the blink bit.

## Memory-mapped I/O

- Okay so this is cool.
- Recall the bus!
- We are going to steal some diagrams.
    - Thanks [Geeks for Geeks](https://www.geeksforgeeks.org/computer-organization-architecture/memory-mapped-i-o-and-isolated-i-o/)
    
## Isolated I/O

- Imagine a form of I/O that isn't cool.
- It may have separate address spaces.
  	- So there may be a `0x64` memory location and also `0x64` device.

![](https://media.geeksforgeeks.org/wp-content/uploads/20250506151408311194/isolate-io.webp)

## This isn't cool

- We already discussed Harvard vs. von Neumann architecture.
- Having two memory spaces is not at all cool.
- So we don't do it.
- There's also port-mapped I/O (similarly not cool.

## Memory-Mapped I/O

- Imagine the following.
  - The bootloader lives at `0x0`
  - The OS lives at `0x1`
  - The keyboard lives at `0x2`
  - The internet (via a network card) at `0x3`
  - The monitor at `0x4`
- This obviously cool.

## Altogether 

- One Big Happy Memory Space 

![](https://media.geeksforgeeks.org/wp-content/uploads/20250506151651561116/memory-io.webp)

## Downsides

- MMIO is a helpful *abstraction* - we already know how to think about memory, so we don't need to learn much to do I/O.
  	- There's downsides.
	- We shouldn't be able to write to keyboard, probably.
	- Or read from a monitor.
- But its fast and easy, like BIOS vs. UEFI.

# x86_64

## In x86_64

- On our emulated device, VGA text buffer lives at address `0xb8000`. 
	- Absolute geniuses will crack open C and get into trouble.
- So any read to this location:
  	- Doesn't go to MMU/RAM/SSD
	- Does go to VGA hardware


## Alert!

- MMIO, especially older devices, might not support all normal operations. 
- For example, a device could only support byte-wise reads and return junk when a `u64` is read. 
	- Block-write "Hello world!" is a homework extension. 
- [Read more](https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip)

## A Rust Module

- Now we "know" how the VGA buffer works.
- We can create a Rust module to handle print and standard out:

```{.rs filename="src/main.rs"}
mod vga;
```

- We also must create a new `src/vga.rs` file.

<!--

## Colors

- Represent colors using an `enum`:

```{.rs filename="src/vga.rs"}
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Color {
    Blck = 0o00,
    Blue = 0o01,
    Gren = 0o02,
    Cyan = 0o03,
    Redd = 0o04,
    Mgnt = 0o05,
    Brwn = 0o06,
    LGry = 0o07,
    DGry = 0o10,
    LBlu = 0o11,
    LGrn = 0o12,
    LCyn = 0o13,
    LRed = 0o14,
    Pink = 0o15,
    Yelo = 0o16,
    Whte = 0o17,
}
```

## Notes

- We use a [C-like enum] here to explicitly specify the number for each color. 
- Because of the `repr(u8)` attribute, each enum variant is stored as a `u8`. 
  	- I would use `u4` type (a nib) if I was allowed to.
-  Rust on the [C-like enum](https://doc.rust-lang.org/rust-by-example/custom_types/enum/c_like.html)
	- At some point we have to figure out why we aren't writing C.

## Suppress Warnings

- Normally the compiler would issue a warning for each unused variant. 
  	- This seems obviously annoying to me.
- By using the `#[allow(dead_code)]` attribute, we disable these warnings for the `Color` enum.

## Comparisons

- By [deriving] the [`Copy`], [`Clone`], [`Debug`], [`PartialEq`], and [`Eq`] traits, we:
  	- Get stack-like (vs. heap-like) behavior.
	- Make it printable.
	- Make it comparable (e.g. via double-equals-equality `==`)
- I would obviously just use an u8 here but don't be like me, I am wrong in some way that may be important latter.

## Links

- [deriving](https://doc.rust-lang.org/rust-by-example/trait/derive.html)
- [`Copy`](https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html)
- [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html)
- [`Debug`](https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html)
- [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html)
- [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html)
- [copy semantics](https://doc.rust-lang.org/1.30.0/book/first-edition/ownership.html#copy-types)


## New Type

- A full color code specifies foreground *and* background color
- We create a [newtype](https://doc.rust-lang.org/rust-by-example/generics/new_types.html) on top of `u8`


```{.rs filename="src/vga.rs"}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
struct ColorCode(u8);

impl ColorCode {
    fn new(fg: Color, b: Color) -> ColorCode {
        ColorCode((bg as u8) << 4 | (fg as u8))
    }
}
```

## Transparency

- Again, we derive the `Copy` and `Debug` traits for it. 
- When working with low level devices, we need to ensure bits are where we expect them to be.
- To ensure that the `ColorCode` has the exact same data layout as a `u8`, we use the [`repr(transparent)`] attribute.
	- [Read more](https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent)
<!--
## Text Buffer

- Now we can add structures to represent a screen character and the text buffer:

```{.rs filename="src/vga.rs"}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
struct ScreenChar {
    ascii_character: u8,
    color_code: ColorCode,
}

const BUFFER_HEIGHT: usize = 25;
const BUFFER_WIDTH: usize = 80;

#[repr(transparent)]
struct Buffer {
    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
}
```

## C Representation

- Field ordering in default structs is undefined in Rust!
- Not so in the good language, C.
- We use the [`repr(C)`] attribute. 
  - It guarantees that the struct's fields are laid out in order. `
  - [`repr(C)`](https://doc.rust-lang.org/nightly/nomicon/other-reprs.html#reprc)
- For the `Buffer` struct, we use [`repr(transparent)`] again to ensure that it has the same memory layout as its single field.
-->


## Standard Out

- To provide "standard out" like functionality, I will:
	- Maintain the most recent position to which a character has been written.


```{.rs filename="src/vga.rs"}
static mut latest: usize = 0;
```

## Location

- To provide "standard out" like functionality, I will:
	- Maintain the most recent position to which a character has been written.
	- Have a constant referring to to the VGA buffer address.

```{.rs filename="src/vga.rs"}
static mut latest:usize = 0;
const MMIO = 0xb8000 as *mut u8;
```

## Color

- To provide "standard out" like functionality, I will:
	- Provide a way to write a character.
	  	- I will use a `const` for color and not worry about.

```{.rs filename="src/vga.rs"}
static mut latest:usize = 0;
const MMIO = 0xb8000 as *mut u8;
const COLOR: u = 0xF;
```

## Character-wise

- To provide "standard out" like functionality, I will:
	- Provide a way to write a character.
	  	- I will write a function to push one character.

```{.rs filename="src/vga.rs"}
// Public for now
pub fn char_to_vga(a: u8) {
	todo!();
}
```

## Stepwise

1. Compute absolute location from relative location.

```{.rs filename="src/vga.rs"}
// Public for now
pub fn char_to_vga(a: u8) {
	let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;
}
```

## Stepwise

1. Compute absolute location from relative location.
2. Store a value at that location.

```{.rs filename="src/vga.rs"}
// Public for now
pub fn char_to_vga(a: u8) {
	let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;
	*rel = a;
}
```

## Stepwise

1. Compute absolute location from relative location.
2. Store a value at that location.
3. Store a color at the next location.

```{.rs filename="src/vga.rs"}
// Public for now
pub fn char_to_vga(a: u8) {
	let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;
	*rel = a;
        *((rel as usize + 1) as *mut u8) = COLOR;
}
```

## Stepwise

1. Compute absolute location from relative location.
2. Store a value at that location.
3. Store a color at the next location.
4. Increment the latest.

```{.rs filename="src/vga.rs"}
// Public for now
pub fn char_to_vga(a: u8) {
	let rel: *mut u8 = ((MMIO as usize) + (latest * 2)) as *mut u8;
	*rel = a;
        *((rel as usize + 1) as *mut u8) = COLOR;
        LATEST = LATEST + 1;
}
```

## Test it

- It is trivial to test.

```{.rs filename="src/main.rs"}
    let hi: &[u8] = b"Hello World!";
    for i in 0..12 {
        vga::char_to_vga(hi[i]);
    }
```

- "Works on my machine!" - me
	- Unless?
	- We'll come back to this.

## Annoying

- Some of you may lack a strong work ethic and want to show entire a whole *string* rather than just a character at a time.
  	- Especially since using characters of a string in Rust is ludicrously opaque.
- Not to worry.

## Target `&str`

- We can abstract to loop into `src/vga.rs`

```{.rs filename="src/vga.rs"}
pub fn str_to_vga(s: &str) {
    let v = s.as_bytes();
    for i in 0..v.len() {
        char_to_vga(v[i]);
    }
}
```

## Aside

- I am opinionated on `as_bytes`.
- Let's check some links.
	- [`to_bytes`](https://doc.rust-lang.org/std/?search=to_bytes)
        - [`as_bytes`](https://doc.rust-lang.org/std/?search=as_bytes)
	- [`bytes`](https://doc.rust-lang.org/std/?search=bytes)
- Can you guess what always works?

## Aside

- Big Rust doesn't want you to know you can use pointers.

```{.rs filename="src/vga.rs"}
    let ptr = s.as_ptr() as usize;
    unsafe {
        for i in 0..s.len() {
            char_to_vga(*((ptr + i) as *const u8));
        }
    }
```

- I could make this even worse but I didn't.
- Anyways don't do this.

## Update main

- Look how nice that is!

```{.rs filename="src/main.rs"}
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    vga::str_to_vga("Hello, world!");
    loop {}
}
```

## I bet...

- I bet we can print *any* string.
- Let's do like a comically easy string that will definitely print.
- There's no way it will fail.

```{.rs filename="src/main.rs"}
    vga::str_to_vga("Hello\nworld!");
```

- It worked right?

## Escape Codes

- Okay so there's some things we need to treat differently.
	- Minimally `\n`.
	- And therefore also `\\` to show a single backslash.
	- I don't even know if we need anything else, but I'll show the design pattern.

## Revisit Implementation

- Recall our naive implementation.

```{.rs filename="src/vga.rs"}
pub fn str_to_vga(s: &str) {
    let v = s.as_bytes();
    for i in 0..v.len() {
        char_to_vga(v[i]);
    }
}
```

## Case analysis

- As far as I know (I didn't check) we only have to look for is:
  	- `\n`
	- `10` (I think?)
	- `0xa`
- It will be a `u8` within the loop (since we `as_bytes` first)


## Trust but verify

- I just checked in a different crate.
```{.rs filename="../???/src/main.rs"}
fn main() {
    let s = "Hello\nworld!";
    dbg!(s.as_bytes());
}
```
- Looked like 10 to me.

## Now it works!

- We can write vertically!
  - I guess this could be a helper function or something.

```{.rs filename="src/main.rs"}
    vga::str_to_vga("H\ne\nl\nl\no\n\nw\no\nr\nl\nd\n!");
```

## Good thing...

- I can print that more than once!

```{.rs filename="src/main.rs"}
    for _i in 0..3 {
        vga::str_to_vga("H\ne\nl\nl\no\n\nw\no\nr\nl\nd\n!");
    }
```
- Wait a minute!

## We're doomed

- We didn't save what was written to the previous lines.
- Real ones know.

![](https://upload.wikimedia.org/wikipedia/en/1/16/BladeRunnerRoyBattySpeech.jpeg)

## Unless?

- No way can we *read* from the VGA text buffer right.
- That would be... extraordinary.
- You can do whatever you want, I just want to show you one possible design choice.
  	- Mostly as a proof of concept.

## Scroll

- I'll add some `const`s and write a helper.

```{.rs filename="src/vga.rs"}
const ROWS: usize = 80;
const COLS: usize = 25;
const MAX: usize = ROWS * COLS;

fn scroll() {
    
}
```

## Execution

- Start at the first character that will remain visible.
- Copy it to the earliest visible slot (start of buffer).
- Iterate until the full buffer is moved.
- We note this could be executed in a single `memmove`
  	- [Read more](https://man7.org/linux/man-pages/man3/memmove.3.html)


## My Code

- Public just to test.

```{.rs filename="src/vga.rs"}
pub fn scroll() {
    for i in 80..MAX {
        unsafe {
            let src: *mut u8 = ((MMIO as usize) + (i * 2)) as *mut u8;
            let dst: *mut u8 = ((MMIO as usize) + ((i - 80) * 2)) as *mut u8;
            *dst = *src;
        }
    }
}
```

## My Test

- I just sent line numbers then manually scrolled.

```{.rs filename="src/main.rs"}
    vga::str_to_vga("0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nA\nB");
    vga::scroll();
```

## A better test

- Here is a copy of the Project Gutenburg ebook of *Pride and Prejudice*.
- It contains some quotes which might be a problem.
- [Link](https://raw.githubusercontent.com/cd-public/books/main/pg1342.txt)
```{.sh}
https://raw.githubusercontent.com/cd-public/books/main/pg1342.txt
```

## Does it work?

- What do we have to do?

<details>
1. Add `scroll` to `str_to_vga`
2. Update `LATEST` in `scroll`
3. Blank out the last line, I used space (`0x20` or `32`)
4. Make sure all color bytes are set.
</details>

## Why do we blank out?

- Recall we are writing to MMIO.
- As soon as we exceed the MMIO range, we can *make no claims* about what memory we are vviewing.
- So if we copy in data past the buffer, we could get *anything*.
- So if we don't overwrite the buffer, we could get *anything*.

## We set color bytes?

- Like lines off the MMIO range, the color bytes have no known value.
- So if we e.g. have a newline anywhere and end up not initially setting colors...
- Then copy text up to that line...
- We will be showing text in an *unset* color.
  	- Just whatever bits happened to be there!

## This is unsafe!

- Astute learners will notice this is all very unsafe.

## I'm loopy

- I should not I do everything with `for` loops and "single-equals-assignment"
	- I mostly am teaching you *how to code*
	- This is NOT teaching you *how to Rust* (or C)
- Who needs `memmove` (a C function) when we have the humble `for` loop.
- Read more: [core::ptr::copy](https://doc.rust-lang.org/core/ptr/fn.copy.html)

## Caution!

- I am building my crate without access to `memmove`.
- You may need to go back and add some configuration.
- This was covered in the "Kernel" lecture.
  	- [Here](40_kernel.qmd#aside-notfutureproofing-1)


## My solution

<details>

```{.rs filename="src/vga.rs"}
const ROWS: usize = 80;
const COLS: usize = 25;
const MAX: usize = ROWS * COLS;

fn scroll() {
    unsafe {
        for i in 80..MAX {
            let src: *mut u8 = ((MMIO as usize) + (i * 2)) as *mut u8;
            let dst: *mut u8 = ((MMIO as usize) + ((i - 80) * 2)) as *mut u8;
            *dst = *src;
            *((dst as usize + 1) as *mut u8) = COLOR;
        }
        for i in (MAX-80)..MAX {
            let dst: *mut u8 = ((MMIO as usize) + ((i) * 2)) as *mut u8;
            *dst = 32;
            *((dst as usize + 1) as *mut u8) = COLOR;
        }
        LATEST = LATEST - 80;
    }
}

pub fn str_to_vga(s: &str) {
    let v = s.as_bytes();
    unsafe {
        for i in 0..v.len() {
            if LATEST > MAX {
                scroll();
            }
            match v[i] {
                10 => LATEST = ((LATEST / 80) + 1) * 80,
                _ => char_to_vga(v[i]),
            }
        }
    }
}
```

</details>

# Volatile

## Best Practice

- This works on my machine.
- It may not always work.
- Why? `rustc` is a bit too smart.
  	- There is no obvious externally observable reason to write to fixed memory location.
	- The compiler may optimize out such writes.
	- I say "sure it will."

## Quote Blog

> The problem is that we only write to the buffer and never read from it again. 

- Okay so but here me out.
- Our implementation does read from the buffer again.
	- Sometimes the best way to do things is also the simplest.
	- For some reason blog kept a local copy and only used that?

## Volatile

- If we lacked the skill and bravery of the instructor of this course, we may have a problem.
- To avoid an erroneous optimization omitting all writes, we need to specify writes as _[volatile]_. 
- This tells the compiler that the write has side effects and should not be optimized away.
- [Read more](https://en.wikipedia.org/wiki/Volatile_(computer_programming))

## Interested Students

- There's a `read_volatile` and `write_volatile` in `std::ptr` and another in `core::ptr`, we might be able to use those.

# Fin

## Timeout

- This is 700 lines of markdown source which usually is enough.
- Otherwise we proceed to "Format".


# Format

## Formatting Macros

- It would be nice to support Rust's formatting macros, too. 
- We will also discover that Rust is, in point of fact, an object-oriented language.
  	- Read: bad.
- I was extremely annoyed by how to get this working, but I did it.

## Functionality

- We need to implement the [`core::fmt::Write`] trait. 
	- I had foolishly assumed we could just use `format!`
	- That would tragically be too reasonable.
	- (It also would raise some unanswered questions about memory but whatever).
- The only required method of this trait is `write_str`:
  - [`core::fmt::Write`](https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html)

## Sketch

- Basically we need to write this:

```{.rs filename="src/vga.rs"}
impl core::fmt::Write for ??? {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        // Do the thing. 
        return Ok(());
    }
}
```

- The `Ok(())` is just a `Ok` Result containing the `()` "unit type".

## Workaround

- I already can write text!

```{.rs filename="src/vga.rs"}
impl core::fmt::Write for ??? {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        str_to_vga(s); 
        return Ok(());
    }
}
```

## Dummy struct

- I just make an arbitrary structure.

```{.rs filename="src/vga.rs"}
struct Dummy { } 

impl core::fmt::Write for Dummy {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        str_to_vga(s); 
        return Ok(());
    }
}
```

- Presumably it is clear why someone would find this an annoying way to do things.

## This works

- I'm not kidding it actually does.
- I was surprised too.
	- I did forget to capitalized the W in write but...

```{.rs filename="src/main.rs"}
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    use core::fmt::Write;
    let mut d = vga::Dummy { };
    write!(d, "Hello {}!", "world");
    loop {}
}
```

- It throws an uninteresting warning.

### A println Macro

Now that we have a global writer, we can add a `println` macro that can be used from anywhere in the codebase. Rust's [macro syntax] is a bit strange, so we won't try to write a macro from scratch. Instead, we look at the source of the [`println!` macro] in the standard library:

[macro syntax]: https://doc.rust-lang.org/nightly/book/ch20-05-macros.html#declarative-macros-for-general-metaprogramming
[`println!` macro]: https://doc.rust-lang.org/nightly/std/macro.println!.html

```rust
#[macro_export]
macro_rules! println {
    () => (print!("\n"));
    ($($arg:tt)*) => (print!("{}\n", format_args!($($arg)*)));
}
```

Macros are defined through one or more rules, similar to `match` arms. The `println` macro has two rules: The first rule is for invocations without arguments, e.g., `println!()`, which is expanded to `print!("\n")` and thus just prints a newline. The second rule is for invocations with parameters such as `println!("Hello")` or `println!("Number: {}", 4)`. It is also expanded to an invocation of the `print!` macro, passing all arguments and an additional newline `\n` at the end.

The `#[macro_export]` attribute makes the macro available to the whole crate (not just the module it is defined in) and external crates. It also places the macro at the crate root, which means we have to import the macro through `use std::println` instead of `std::macros::println`.

The [`print!` macro] is defined as:

[`print!` macro]: https://doc.rust-lang.org/nightly/std/macro.print!.html

```rust
#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));
}
```

The macro expands to a call of the [`_print` function] in the `io` module. The [`$crate` variable] ensures that the macro also works from outside the `std` crate by expanding to `std` when it's used in other crates.

The [`format_args` macro] builds a [fmt::Arguments] type from the passed arguments, which is passed to `_print`. The [`_print` function] of libstd calls `print_to`, which is rather complicated because it supports different `Stdout` devices. We don't need that complexity since we just want to print to the VGA buffer.

[`_print` function]: https://github.com/rust-lang/rust/blob/29f5c699b11a6a148f097f82eaa05202f8799bbc/src/libstd/io/stdio.rs#L698
[`$crate` variable]: https://doc.rust-lang.org/1.30.0/book/first-edition/macros.html#the-variable-crate
[`format_args` macro]: https://doc.rust-lang.org/nightly/std/macro.format_args.html
[fmt::Arguments]: https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html

To print to the VGA buffer, we just copy the `println!` and `print!` macros, but modify them to use our own `_print` function:

```rust
// in src/vga.rs

#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::vga::_print(format_args!($($arg)*)));
}

#[macro_export]
macro_rules! println {
    () => ($crate::print!("\n"));
    ($($arg:tt)*) => ($crate::print!("{}\n", format_args!($($arg)*)));
}

#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    WRITER.lock().write_fmt(args).unwrap();
}
```

One thing that we changed from the original `println` definition is that we prefixed the invocations of the `print!` macro with `$crate` too. This ensures that we don't need to import the `print!` macro too if we only want to use `println`.

Like in the standard library, we add the `#[macro_export]` attribute to both macros to make them available everywhere in our crate. Note that this places the macros in the root namespace of the crate, so importing them via `use crate::vga::println` does not work. Instead, we have to do `use crate::println`.

The `_print` function locks our static `WRITER` and calls the `write_fmt` method on it. This method is from the `Write` trait, which we need to import. The additional `unwrap()` at the end panics if printing isn't successful. But since we always return `Ok` in `write_str`, that should not happen.

Since the macros need to be able to call `_print` from outside of the module, the function needs to be public. However, since we consider this a private implementation detail, we add the [`doc(hidden)` attribute] to hide it from the generated documentation.

[`doc(hidden)` attribute]: https://doc.rust-lang.org/nightly/rustdoc/write-documentation/the-doc-attribute.html#hidden

### Hello World using `println`
Now we can use `println` in our `_start` function:

```rust
// in src/main.rs

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    println!("Hello World{}", "!");

    loop {}
}
```

Note that we don't have to import the macro in the main function, because it already lives in the root namespace.

As expected, we now see a _“Hello World!”_ on the screen:

![QEMU printing “Hello World!”](vga-hello-world.png)

### Printing Panic Messages

Now that we have a `println` macro, we can use it in our panic function to print the panic message and the location of the panic:

```rust
// in main.rs

/// This function is called on panic.
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    loop {}
}
```

When we now insert `panic!("Some panic message");` in our `_start` function, we get the following output:

![QEMU printing “panicked at 'Some panic message', src/main.rs:28:5](vga-panic.png)

So we know not only that a panic has occurred, but also the panic message and where in the code it happened.

## Summary
In this post, we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address `0xb8000`. We created a Rust module that encapsulates the unsafety of writing to this memory-mapped buffer and presents a safe and convenient interface to the outside.

Thanks to cargo, we also saw how easy it is to add dependencies on third-party libraries. The two dependencies that we added, `lazy_static` and `spin`, are very useful in OS development and we will use them in more places in future posts.

## What's next?
The next post explains how to set up Rust's built-in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post.
