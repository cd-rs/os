---
title: Bare Metal
---

## Announcements

- **Action Items**:
  - `malloc` stands eternal
    - Possibly the coolest assignment ever
    - I'm glad you all love it
  - Homework this week is more complicated but also more supported.
    - Prioritize `malloc` I think.


## Today

- Bare metal
    - Bare metal
    - Ranting about how cool this is
    - Simulation
    - Emulation
- A bare metal binary
    - Runtimes
    - `std`
    
## Citations

- Outright theft:
    - [Welcome to Bare Metal Rust](https://google.github.io/comprehensive-rust/bare-metal.html)
    - [A Freestanding Rust Binary](https://os.phil-opp.com/freestanding-rust-binary/)

# Motivation

## Throwback ThMonday

- I did this in grad school.
    - [RTL Simulation of C-Program on Bare-metal OR1200](https://medium.com/@rz2285/simulating-c-program-on-bare-metal-or1200-af67e2886fb8)
- My researcher (Juni) did this in '22
    - [Bare-Metal Programs on RISC-V](https://cd-public.github.io/research/students/aphrodite.pdf)
- I did this... last week.
    - [Slides including bare-metal execution in Verilog](https://vcd2df.github.io/pnsqc/#/demonstration)
    
## Bare Metal

> [A computer which has no operating system. The software executed by a bare machine, commonly called a "bare metal program" or "bare metal application", is designed to interact directly with hardware. Bare machines are widely used in embedded systems, particularly in cases where resources are limited or high performance is required.](https://en.wikipedia.org/wiki/Bare_machine)

## Some Terms

- Should introduce a few terms.
    - Not required for OS but useful to know.
- Terms
    - Simulation
    - Emulation
    - Cross-compilation
    - QEMU
    
## Simulation

- Models a system's behavior
- Focuses on high-level results, not internal logic
- "Close enough" for performance or logic testing
- Simulating hardware components in software
- Faster but less precise

## Emulation

- Replicating exact internal behavior of hardware
- Software acting as hardware (CPU, registers, memory)
- **Accuracy vs. Speed**:
  - Much slower than simulation... unless?
  - Goal: Guest software doesn't know it's not on actual silicon
  
## Example

- `x86-64` - the Intel/AMD architecture common for Linux and Windows - supports a "long double" float with 80 bits of precision.
- `ARM64` - a competing formulation most popularized as "Apple silicon" with the M1 - lacks long doubles.

## Context

- It is trivial to implement a float in software...
    - [`f16`](https://cd-c89.github.io/rs/51_f16.html)
- It is relatively not-trivial to implement *an architecture* in software, though possible.
    - Here's the smallest example I know: 
    - [PicoRV32](https://github.com/YosysHQ/picorv32)

## Cross-Compiling

- Example:" compiling code *on* an x86 laptop *for* an ARM chip
    - Common in embedded applications (e.g. program a thermostat)
- Compiler runs on Host A, produces binary for Target B
  - Essential for "bare metal" development
  - Transmit the binary over wires (the bus!) to another device's memory.
  
## Considerations
  
- We must:
  - **Target** a specific architecture
  - **Link** against specific hardware memory maps
- Somehow you also need the actual hardware, unless...

## QEMU

- I used this a lot in grad school; less now.
  - Supports both emulation and virtualization
    - Virtualization emulates a device rather than a binary.
    - Used in cloud; can be fast; huge research area.
- Let's us run bare metal binaries without physical chips (which would cost $)
- Write locally $\rightarrow$ Cross-compile $\rightarrow$ Run in QEMU

# Binary

## First Steps

- The first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. 
- This makes it possible to run Rust code on the "bare metal" without an underlying operating system.

## Introduction

- To write an operating system kernel, we need code that does not depend on any operating system features. 
- This means that we can't use files, the heap, networks, random numbers, standard output, etc. 
- We're trying to write our own OS!

## On `std`

- We can't use most of the Rust standard library, but... 
- ...there are a lot of Rust features that we _can_ use. 
- For example, we can use iterators, closures, pattern matching, `option` and `result`
    - Recall the official Calvin Deutschbein position on `option` and `result`:
    - "It's why Rust is good." - me
   
## On `std`
    
- While not initially helpful, we can use string formatting, and...
- ... the ownership system.
    - Beats `malloc`!
    
## Quoth The Blog
    
> These features make it possible to write a kernel in a very expressive, high level way without worrying about undefined behavior or memory safety.

- Well, we'll see.

## We keep {.smaller}

- [option](https://doc.rust-lang.org/core/option/)
- [result](https://doc.rust-lang.org/core/result/)
- [Rust standard library](https://doc.rust-lang.org/std/)
- [iterators](https://doc.rust-lang.org/book/ch13-02-iterators.html)
- [closures](https://doc.rust-lang.org/book/ch13-01-closures.html)
- [pattern matching](https://doc.rust-lang.org/book/ch06-00-enums.html)
- [string formatting](https://doc.rust-lang.org/core/macro.write.html)
- [ownership system](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
- [undefined behavior](https://www.nayuki.io/page/undefined-behavior-in-c-and-cplusplus-programs)
- [memory safety](https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention)


## Onward!

- We now enumerate the necessary steps to create a freestanding Rust binary...
- ...and explains why the steps are needed.

## `no_std`

- By default, all Rust crates link the standard library.
    - It depends on the operating system for features such as threads, files, or networking. 
    - It also depends on the C standard library `libc`, which closely interacts with OS services. 
        - That is, part of GNU but not part of Linux.

## `no_std`

- Since our plan is to write an operating system, we can't use any OS-dependent libraries. 
    - That would be recursive, which is only good sometimes!
- So we have to disable the automatic inclusion of the standard library through the `no_std` attribute.
    - [standard library](https://doc.rust-lang.org/std/)
    - [`no_std` attribute](https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html)

## To begin

- We can start creation the same way we make anything else in Rust...
- *Cargo* (sighs heavily)
- We will introduce only two wrinkles.
    - `--bin`: we want to create an executable binary (in contrast to a library) 
    - `--edition 2024`: to maintain consistency across years and with the working example.
    
## Invoke as

```{.sh}
cargo new ???? --bin --edition 2024
```

## Example

- Personally, I would expect you to maintain different OS versions with same crate name but within distinctly named directories (`32`,`42` etc.)

```{.sh}
cargo new 32 --name osirs --vcs none --bin --edition 2024
```

## Branches

- A competing formulation would be to use `git branch` to create different developmental branches.
- This is the industry standard and I wanted to introduce it but felt a time crunch.
- If you are looking for something to do, figure it out.
    - Don't worry about me finding things; its worth it to me for you to learn.
    
## Name


:::: {.columns}

::: {.column width="50%"}

- You don't have to name your OS anything in particular, I just thought `osirs` (OS in Rust) sounded heckin' rad.
- [ ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú](https://en.wikipedia.org/wiki/Osiris)
- Also a cringe AI real estate firm!

:::

::: {.column width="50%"}


![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8b/Standing_Osiris.svg/330px-Standing_Osiris.svg.png)

:::

::::

## Refresh

- When we run the command, cargo creates the following directory structure for us:


```{.sh}
$ tree
.
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs

1 directory, 2 files
```

## Recall

- `Cargo.toml` contains the crate configuration
    - Crate name
    - Crate author
    - Crate version
- `src/main.rs` file contains our `main` function. 
- After `cargo build`, find the compiled `osirs` binary in the `target/debug` subfolder.

## Blah blah blah

```{.sh}
$ cargo build ; tree
   Compiling osirs v0.1.0 (/home/user/tmp/32)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
.
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
    ‚îú‚îÄ‚îÄ CACHEDIR.TAG
    ‚îî‚îÄ‚îÄ debug
        ‚îú‚îÄ‚îÄ build
        ‚îú‚îÄ‚îÄ deps
        ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ osirs-43412975b38d059d
        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ osirs-43412975b38d059d.d
        ‚îú‚îÄ‚îÄ examples
        ‚îú‚îÄ‚îÄ incremental
        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ osirs-3gae52yq1943v
        ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ s-hfeunnoewq-0c8luu5-5dmhke08rl6h5l09ku3va3gkx
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 1tq3ts5gahvv7j1hzrmfdrzi6.o
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 6zk3flo890c0qhh6fykb6746g.o
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 8z45o15v3gxm5hydv3o63x07l.o
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 9itjtn00r7d8c6mknmav20oex.o
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bh9pj42wzikjd1ilqutnjbrx7.o
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dep-graph.bin
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ eymyqxruzdb24suchgzd8ygxb.o
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ query-cache.bin
        ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ work-products.bin
        ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ s-hfeunnoewq-0c8luu5.lock
        ‚îú‚îÄ‚îÄ osirs
        ‚îî‚îÄ‚îÄ osirs.d

9 directories, 18 files
```

## Running

- Technically no one can stop you from using `cargo run` or even `cargo run --release`
- But you can also just `build` and then *directly* run the executable.

```{.sh}
$ ./target/debug/osirs
Hello, world!
```

## The `no_std` Attribute

- Initially, the crate implicitly links the standard library. 
- We can prepend the `no_std` attribute to `src/main.rs` to get the version of Rust that builds character!

```{.rs filename="src/main.rs"}
// main.rs

#![no_std]

fn main() {
    println!(" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú");
}
```

## We Can Rebuild

- Actually we can't.

```{.sh}
$ cargo build
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error: cannot find macro `println` in this scope
 --> src/main.rs:6:5
  |
6 |     println!(" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú");
  |     ^^^^^^^

error: `#[panic_handler]` function required, but not found

error: unwinding panics are not supported without std
  |
  = help: using nightly cargo, use -Zbuild-std with panic="abort" to avoid unwinding
  = note: since the core library is usually precompiled with panic="unwind", rebuilding your crate with panic="abort" may not be enough to fix the problem

error: could not compile `osirs` (bin "osirs") due to 3 previous errors    ^^^^^^^
```

## Enhance!

```{.sh}
error: cannot find macro `println` in this scope
 --> src/main.rs:6:5
  |
6 |     println!(" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú");
  |     ^^^^^^^
```

- Oh right, we can't print without an OS.

## Background

- The `println` macro is part of the standard library `std`.
- We said `no_std`.
- So we can no longer print things.
- I hope it is clear how this is character-building!
- Read more:
    - [`println` macro](https://doc.rust-lang.org/std/macro.println.html)
    - [standard output](https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29)

## Rip it

- Remove the printing and try again:

```{.rs filename="src/main.rs"}
// main.rs

#![no_std]

fn main() {
    // println!(" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú");
}
```

## Problems remain

```{.sh}
$ cargo build
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error: `#[panic_handler]` function required, but not found

error: unwinding panics are not supported without std
  |
  = help: using nightly cargo, use -Zbuild-std with panic="abort" to avoid unwinding
  = note: since the core library is usually precompiled with panic="unwind", rebuilding your crate with panic="abort" may not be enough to fix the problem

error: could not compile `osirs` (bin "osirs") due to 2 previous errors
```

## Enhance!

```{.sh}
error: cannot find macro `println` in this scope
 --> src/main.rs:6:5
  |
6 |     println!(" ô·¥è·¥° ·¥Ö·¥è·¥°…¥  ô·¥á“ì·¥è Ä·¥á ·¥õ ú·¥á …¢·¥è·¥Ö ·¥è“ì ·¥Ö·¥á·¥Ä·¥õ ú");
  |     ^^^^^^^
```

- Sometimes, Rust explodes and calls the OS (written in C!) for help.
- It can't do that without `std` and is sad üò≠


## Panic

- The `panic_handler` attribute defines the function that the compiler should invoke when a panic occurs. 
- `std` provides its own panic handler function, but in a `no_std` environment we need to define it ourselves:
- [panic](https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html)

## Our Approach

```{.rs filename="src/main.rs"}
// main.rs

/// This function is called on panic.
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}
```

## Panics

- The `PanicInfo` parameter contains:
    - *file* and *line* where the panic happened
    - panic message (e.g. `panic!("YOLO")`
- The function should never return.
    - So it is marked as a "diverging function" 
    - It returns the ‚Äúnever‚Äù type `!`. 
- Not much we can do in this function for now, so just `loop()` to prevent a return.

## Read more...

- I had never heard of or used these but to me it was clear why they would have to exist in a type safe language.
    - [PanicInfo](https://doc.rust-lang.org/nightly/core/panic/struct.PanicInfo.html)
    - [diverging function](https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions)
    - [‚Äúnever‚Äù type](https://doc.rust-lang.org/nightly/std/primitive.never.html)

<!--

## The `eh_personality` Language Item

Language items are special functions and types that are required internally by the compiler. For example, the [`Copy`] trait is a language item that tells the compiler which types have [_copy semantics_][`Copy`]. When we look at the [implementation][copy code], we see it has the special `#[lang = "copy"]` attribute that defines it as a language item.

[`Copy`]: https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html
[copy code]: https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src/libcore/marker.rs#L296-L299

While providing custom implementations of language items is possible, it should only be done as a last resort. The reason is that language items are highly unstable implementation details and not even type checked (so the compiler doesn't even check if a function has the right argument types). Fortunately, there is a more stable way to fix the above language item error.

The [`eh_personality` language item] marks a function that is used for implementing [stack unwinding]. By default, Rust uses unwinding to run the destructors of all live stack variables in case of a [panic]. This ensures that all used memory is freed and allows the parent thread to catch the panic and continue execution. Unwinding, however, is a complicated process and requires some OS-specific libraries (e.g. [libunwind] on Linux or [structured exception handling] on Windows), so we don't want to use it for our operating system.

[`eh_personality` language item]: https://github.com/rust-lang/rust/blob/edb368491551a77d77a48446d4ee88b35490c565/src/libpanic_unwind/gcc.rs#L11-L45
[stack unwinding]: https://www.bogotobogo.com/cplusplus/stackunwinding.php
[libunwind]: https://www.nongnu.org/libunwind/
[structured exception handling]: https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling

-->

## Retry

- I bet it works now!

```{.sh}
$ cargo build
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error: unwinding panics are not supported without std
  |
  = help: using nightly cargo, use -Zbuild-std with panic="abort" to avoid unwinding
  = note: since the core library is usually precompiled with panic="unwind", rebuilding your crate with panic="abort" may not be enough to fix the problem

error: could not compile `osirs` (bin "osirs") due to 1 previous error
```

- They should make a version of the OS class that is easy.
    - (They did - this class)

## Panic abort

:::: {.columns}

::: {.column width="50%"}

- Fun fact - back when I was an OS engineer slash rocket scientist my first launch was ["PA-1" for "Pad Abort 1"](https://en.wikipedia.org/wiki/Pad_Abort-1)
    - Blew up a rocket on the launch pad to make sure it was safe for humans.

:::

::: {.column width="50%"}


![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/450775main_wstf0510e04493_hires.jpg/330px-450775main_wstf0510e04493_hires.jpg)

:::

::::
    
## Panic abort

- The use of the term "abort" which in some nation-states is a hot-button political issue has come up from time-to-time in the discourse.
- [Read more from 2018](https://www.theregister.com/2018/05/09/gnu_glic_abort_stallman/)

```email

25.7.4 Aborting a Program

...

Future Change Warning: Proposed Federal censorship regulations may prohibit us from giving you information about the possibility of calling this function. We would be required to say that this is not an acceptable way of terminating a program.

```

## Quoth Stallman

> "The point of this joke is even more important now than it was when I first wrote it," [Free Software Foundation president] Stallman wrote in a note posted to project mailing list, in reference to today's political climate. "Please do not remove it. GNU is not a purely technical project, so the fact that this is not strictly and grimly technical is not a reason to remove this."

## Now in Rust

- We can oppose fascism *and* 
    - (looks into the history of NASA and Lockheed Martin)
    - (clears throat)
    - Moving on!    
- We can abort programs... *in Rust*

## How?

- Read carefully:

```{.sh}
= help: using nightly cargo, use -Zbuild-std with panic="abort" to avoid unwinding
= note: since the core library is usually precompiled with panic="unwind", rebuilding your crate with panic="abort" may not be enough to fix the problem
```

- Geniuses will recognize `panic="abort"` syntax

## TOML

- It's `.toml`

```{.toml filename="Cargo.toml"}
[package]
name = "osirs"
version = "0.1.0"
edition = "2024"

[dependencies]
```

## Crate options

- Nominally there are use cases for which unwinding is undesirable
    - My take: All cases.
- So Rust provides an option to "abort on panic" instead. 
- This disables the generation of unwinding symbol information and thus considerably reduces binary size. 
    - This seems obviously good to me.

## Update `Cargo.toml`

- Add the following:

```{.toml code-line-numbers="8-12" filename="Cargo.toml"}
[package]
name = "osirs"
version = "0.1.0"
edition = "2024"

[dependencies]

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```

## Now...

- This sets the panic strategy to `abort` for both the `dev` profile (used for `cargo build`) and the `release` profile (used for `cargo build --release`).

- [abort on panic](https://github.com/rust-lang/rust/pull/32900)
- I bet it will work now.

## Whoops!

```{.sh}
$ cargo build
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error: using `fn main` requires the standard library
  |
  = help: use `#![no_main]` to bypass the Rust generated entrypoint and declare a platform specific entrypoint yourself, usually with `#[no_mangle]`

error: could not compile `osirs` (bin "osirs") due to 1 previous error
```

- Our program is missing the `start` language item, which defines the entry point.

## The `start` attribute

- One might think that the `main` function is the first function called when you run a program. 
- However, most languages have a "[runtime system](https://en.wikipedia.org/wiki/Runtime_system)"
    - For e.g. Java garbage collection (e.g. in Java)
    - For e.g. Go software threads (goroutines)
- This runtime needs to be called before `main`, since it needs to initialize itself.

## C, again

- In a typical Rust binary that links the standard library, execution starts in a C runtime library 
    - `crt0` for ‚ÄúC runtime zero‚Äù 
- This creates a stack and places the arguments in the right hardware registers. 
- The C runtime then invokes the entry point of the Rust runtime, which is marked by the `start` language item. 

## Back to Rust

- Rust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic. 
- The runtime then finally calls the `main` function.

## `crt0` is cheating

- Our freestanding executable does not have access to the Rust runtime and `crt0`
- We need to define our own entry point. 
= Implementing the `start` language item wouldn't help, since it would still require `crt0`. 
- Instead, we need to overwrite the `crt0` entry point directly.

### Overwriting

- To tell the Rust compiler that we don't want to use the normal entry point chain, we add the `#![no_main]` attribute.

```{.rs filename="src/main.rs"}
// main.rs

#![no_std]
#![no_main]

/// This function is called on panic.
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}
```

## No main in main

- At this point we can also remove the `main` function. 
- Absent a compatible runtime, `main` is meaningless!
- If you `cargo build` at this point, by the way, you will get some fun errors.

## Start in main

- Instead, overwrite the entry point with our own `_start` function:

```{.rs filename="src/main.rs"}
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    loop {}
}
```

## Manglin'

- By using the `#[unsafe(no_mangle)]` attribute, we disable "name mangling"
    - The function **must** be named `_start`. 
- Otherwise, compiler generates unique symbols like `_start_imarandomstr_1234` to avoid namespace collisons.
    - Folks... it's key-value storage.
- The attribute is required for the *linker* in the next step.

## C you again

- Mark the function as `extern "C"` to tell the compiler that it should use the "C calling convention"
- The reason for naming the function `_start` is that this is the default entry point name for most systems.

## Read more

- [name mangling](https://en.wikipedia.org/wiki/Name_mangling)
- [C calling convention](https://en.wikipedia.org/wiki/Calling_convention)

## Divergence

- The `!` return type returns!
- This is required because the entry point is not called by any function, but invoked directly by the operating system or bootloader. 
    - It can't return anywhere!
    
## Exit

- Before I go out to the clubs I always "X it up" (put X's on my hands) because I'm straight edge.
- Operating systems are similar.
- So instead of returning, the entry point should e.g. invoke the `exit` system call of the operating system.
- For now, we fulfill the requirement by looping endlessly.
- [`exit` system call](https://en.wikipedia.org/wiki/Exit_(system_call))

## Now it works!

- It doesn't.
```{.sh}
$ cargo build
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error: linking with `cc` failed: exit status: 1
  |
  = note:  "cc" "-m64" "/tmp/rustcheyGtM/symbols.o" "<1 object files omitted>" "-Wl,--as-needed" "-Wl,-Bstatic" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{librustc_std_workspace_core-*,libcore-*,libcompiler_builtins-*}.rlib" "-L" "/tmp/rustcheyGtM/raw-dylibs" "-Wl,-Bdynamic" "-Wl,--eh-frame-hdr" "-Wl,-z,noexecstack" "-L" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib" "-o" "/home/user/tmp/32/target/debug/deps/osirs-80f8eb3240ba748e" "-Wl,--gc-sections" "-pie" "-Wl,-z,relro,-z,now" "-nodefaultlibs"
  = note: some arguments are omitted. use `--verbose` to show all linker arguments
  = note: /usr/bin/ld: /home/user/tmp/32/target/debug/deps/osirs-80f8eb3240ba748e.9chdw59nqscmfe0ef1hrxy2nb.rcgu.o: in function `_start':
          /home/user/tmp/32/src/main.rs:14: multiple definition of `_start'; /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o:(.text+0x0): first defined here
          /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
          (.text+0x1b): undefined reference to `main'
          /usr/bin/ld: (.text+0x21): undefined reference to `__libc_start_main'
          collect2: error: ld returned 1 exit status

  = note: some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified
  = note: use the `-l` flag to specify native libraries to link
  = note: use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib)

error: could not compile `osirs` (bin "osirs") due to 1 previous error
```

## To be continued

- I am 99% sure we run out of time here...
- And will continue with the lab on linker errors!
