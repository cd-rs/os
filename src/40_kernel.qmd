---
title: Kernel
---

## Announcements

- **Action Items**:
  - Is `qemu` working at all.
    - The coolest assignment ever for a second week in a row.
    - I'm glad you all love it

## Today

- Background
- Kernel
    
## Citations

- Outright theft:
    - [A Minimal Rust Kernel](https://os.phil-opp.com/minimal-rust-kernel/)

# Background

## The Boot Process

- POV: You are an inanimate piece of silicon.
    - You contain wires connected to logic gates.
    - Somewhere, a switch is flipped.
    - Electrons flow into some of your wires, through some gates.

## First Steps

- What determines the initial arrangement of gates?
- Where do electrons flow?
- This is determined by the *boot process*
    - Occurs on *ever* power-up
    - Determined by *hardware* design
    - More fundamental than the OS
    
## Firmware

- What is between hardware and software?
    - Firmware.
- On power-up, devices execute code embedded in physical read only memory (ROM). 
    - Read more: [ROM](https://en.wikipedia.org/wiki/Read-only_memory)
- Is it software? Is it hardware? Who can say.

## Enter the CPU

- Usually, power-up occurs on a "motherboard" hosting, among other things, the bus.
    - Named "mother" after the "MU/TH/UR" on ship computer in *Alien* (1979)
    - This is a lie.
    
## Not "code" but "ware"
    
- So firmware isn't really like CPU code (like Rust or C), but it does:
    - Tell circuitry where to direct electrons within the CPU.
    - Also wake up e.g. the MMU.

## Enter the OS

- With the CPU primed but not yet ticking through clock cycles, all that remains is to either
    - Execute a bare metal executable, or
    - Boot an operating system to enable the next higher-level task.
    
## What it sounds like
    
- We regard, then, the operating system as a *system* which *operates* the *hardware* on behalf of higher level *software*.
    - Hence, "systems computing".
    - Hopefully the contrast to software is a bit more clear here.
    
## Aside

- I am supposed to teach you about the "power-on self-test".
- A bit electrical engineering for me.

> [A **power-on self-test** (POST) is a process performed by firmware or software routines immediately after a computer or other digital electronic device is powered on.](https://en.wikipedia.org/wiki/Power-on_self-test)

- Neat! Moving on.

## Competing Standards

- Lucky us, there is no widely agreed upon way to do firmware.
- There's the cool, old way that doesn't work well but is easy.
    - “Basic Input/Output System“ [**BIOS**](https://en.wikipedia.org/wiki/BIOS)
    - 1981
    
## Competing Standards
    
- There's the new way that is too hard to use for normal people like us.
    - As in people who do anything else ever.
    - It's good though we promise.
    - “Unified Extensible Firmware Interface” [**UEFI**](https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface).
    - May make you use it for a lab. [More.](https://github.com/le-jzr/sisyphos-kernel-uefi-x86_64)
    - 2006

## BIOS Boot

- I actually started fooling around with the BIOS before UEFI even existed.
    - I was a normal kid though 100%.
- Fortunately it's still basically around. Quoth Blog:

> This is great, because you can use the same boot logic across all machines from the last century. 

## Upsides

- Blog says it's a downside that this means you have to do 16-bit mode.
    - I say: that's cool.
    - I can't count higher than about 0xFFFF anyways.
- The blog impolitely calls 1980s bootloaders "archaic" instead of "vintage", "retro", or "foundational".

## Bootable Disks

- I should also tell you about *bootable disks*
- Nowadays we all boot from SSD or rarely HDD.
- But you have probably at some point booted from USB.
    - Usually when removing a virus like Microsoft Windows from your system.
- Olden days computers could boot from floppy disks, etc.

## Bootlaoder

- I mentioned 1980s bootloaders.
    - No relation to bootleggers or boatloaders.
- 512-byte portion of executable code stored at the bootable disk's "beginning". 
    - On a HDD this is physically the outermost ring of addressable magnetic regions.
    - I don't know how SSDs work as Samsung, SK Hynix, or Micron (shout out Boise).

## Data Structures

- Most bootloaders are larger than 512 bytes.
- So bootloaders are commonly split into a 512 byte first stage that loads a latter stage.
    - This is why we should still be teaching linked lists, basically.
    
## Location, Location

- The bootloader lives in a reserved physical (HDD) or logical (SSD) location.
- Does the OS?
    - With respect to itself, yes, the OS probably says it lives at memory location zero.
    - With respect to underlying hardware? Probably not.
        - Gotta find it.
        
## Booting the OS

- The bootloader has to determine the location of the *kernel image* on disk and load it into memory.
    - Basically this is the definition of the kernel, the minimal OS internal that runs first.
    - Image here means we have physical bits capturing some information, so copies of the bits may live in different places.
        - SSD and RAM, for example.
        
## Switcheroo

- The OS probably is not a 16-bit OS.
    - Unless? Lab idea? Hold me back!
- Big OS wants me to tell you that:
    - 16-bit mode is called "real mode"
    - 32-bit mode is called "protected mode"
    - 64-bit mode is called "long mode".
- Recall we were writing 64-bit bare metal.

## Hand-wave

> Writing a bootloader is a bit cumbersome as it requires assembly language and “write this magic value to this processor register”. 

> Instead use a [bootimage](https://github.com/rust-osdev/bootimage) that automatically prepends a bootloader to your kernel.

- This is called "cheating" and is a good way to get ahead in life.

<!--

## The Multiboot Standard

To avoid that every operating system implements its own bootloader, which is only compatible with a single OS, the [Free Software Foundation] created an open bootloader standard called [Multiboot] in 1995. The standard defines an interface between the bootloader and the operating system, so that any Multiboot-compliant bootloader can load any Multiboot-compliant operating system. The reference implementation is [GNU GRUB], which is the most popular bootloader for Linux systems.

[Free Software Foundation]: https://en.wikipedia.org/wiki/Free_Software_Foundation
[Multiboot]: https://wiki.osdev.org/Multiboot
[GNU GRUB]: https://en.wikipedia.org/wiki/GNU_GRUB

To make a kernel Multiboot compliant, one just needs to insert a so-called [Multiboot header] at the beginning of the kernel file. This makes it very easy to boot an OS from GRUB. However, GRUB and the Multiboot standard have some problems too:

[Multiboot header]: https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#OS-image-format

- They support only the 32-bit protected mode. This means that you still have to do the CPU configuration to switch to the 64-bit long mode.
- They are designed to make the bootloader simple instead of the kernel. For example, the kernel needs to be linked with an [adjusted default page size], because GRUB can't find the Multiboot header otherwise. Another example is that the [boot information], which is passed to the kernel, contains lots of architecture-dependent structures instead of providing clean abstractions.
- Both GRUB and the Multiboot standard are only sparsely documented.
- GRUB needs to be installed on the host system to create a bootable disk image from the kernel file. This makes development on Windows or Mac more difficult.

[adjusted default page size]: https://wiki.osdev.org/Multiboot#Multiboot_2
[boot information]: https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format

Because of these drawbacks, we decided to not use GRUB or the Multiboot standard. However, we plan to add Multiboot support to our [bootimage] tool, so that it's possible to load your kernel on a GRUB system too. If you're interested in writing a Multiboot compliant kernel, check out the [first edition] of this blog series.

[first edition]: @/edition-1/_index.md

-->

# Kernel

## A Minimal Kernel

- Let's make a kernel.
- Specifically, a disk image that prints a “Hello World!” to the screen when booted.
- We extending our bare metal executable.

<!--

## Installing Rust Nightly

Rust has three release channels: _stable_, _beta_, and _nightly_. The Rust Book explains the difference between these channels really well, so take a minute and [check it out](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#choo-choo-release-channels-and-riding-the-trains). For building an operating system, we will need some experimental features that are only available on the nightly channel, so we need to install a nightly version of Rust.

To manage Rust installations, I highly recommend [rustup]. It allows you to install nightly, beta, and stable compilers side-by-side and makes it easy to update them. With rustup, you can use a nightly compiler for the current directory by running `rustup override set nightly`. Alternatively, you can add a file called `rust-toolchain` with the content `nightly` to the project's root directory. You can check that you have a nightly version installed by running `rustc --version`: The version number should contain `-nightly` at the end.

[rustup]: https://www.rustup.rs/

The nightly compiler allows us to opt-in to various experimental features by using so-called _feature flags_ at the top of our file. For example, we could enable the experimental [`asm!` macro] for inline assembly by adding `#![feature(asm)]` to the top of our `main.rs`. Note that such experimental features are completely unstable, which means that future Rust versions might change or remove them without prior warning. For this reason, we will only use them if absolutely necessary.

[`asm!` macro]: https://doc.rust-lang.org/stable/reference/inline-assembly.html

-->

## Target Triple

- We recall the "[target triple](31_linker.md#target-triple)"
- Imagine `host` triple is `x86_64-unknown-linux-gnu`
    - CPU architecture (`x86_64`), 
    - Vendor (`unknown`) - It's Intel #Portland
    - Operating system (`linux`)
    - The [ABI](https://en.wikipedia.org/wiki/Application_binary_interface) (`gnu`).


## Our Target

- I am aware of no existing target triple suitable for this course.
- So, make our own.
- It's not too bad, just JSON.
    - We'll specify some easy stuff, like archtiecture.
    - Some weird stuff, like manual memory layouts.
    - And get on with things.
    
## JSON

- JSON rules by the way.

```{.json}
{
    "llvm-target": "x86_64-unknown-linux-gnu",
    "data-layout": "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128",
    "arch": "x86_64",
    "target-endian": "little",
    "target-pointer-width": 64,
    "target-c-int-width": 32,
    "os": "linux",
    "executables": true,
    "linker-flavor": "gcc",
    "pre-link-args": ["-m64"],
    "morestack": false
}
```

## Some context

- Most fields are required by LLVM. 
- Data layout field defines the size of integer, float (ew), and pointer types. 
- Rust uses conditional compilation, such as via `target-pointer-width`. 
- The `pre-link-args` field specifies arguments passed to the linker.

## ARM64 Take Notes

- We also target `x86_64`.
- Start here:

```{.json filename="x86_64-osirs.json"}
{
    "llvm-target": "x86_64-unknown-none",
    "data-layout": "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128",
    "arch": "x86_64",
    "target-endian": "little",
    "target-pointer-width": 64,
    "target-c-int-width": 32,
    "os": "none",
    "executables": true
}
```

## Changes

- Note that we changed the OS in the `llvm-target` and the `os` field to `none`, because we will run on bare metal.

```{.json filename="x86_64-osirs.json" code-line-numbers="2, 8"}
{
    "llvm-target": "x86_64-unknown-none",
    ...
    "os": "none",
    ...
}
```

## Linking

- We'll add the following build-related entries:


```{.json filename="x86_64-osirs.json"}
{
    "linker-flavor": "ld.lld",
    "linker": "rust-lld",
}
```

- For OS-agnosticism, we use the cross-platform "LLD" linker that is shipped with Rust for linking our kernel.
    - [More.](https://lld.llvm.org/)

## Panic Abort

- You know how I feel about unwinding.
    - I have never relaxed in my life.
    - I've only panicked and given up.

```{.json filename="x86_64-osirs.json"}
{
    "panic-strategy": "abort",
}
```

## Target vs. TOML

- This has the same effect as the `panic = "abort"` option in our Cargo.toml 
- So we can remove it from there! 
- This is better though:
    - We will use `core`, an architecture specific library, and we need `core` to *also* panic abort.
    - ["It is the portable glue between the language and its libraries, defining the intrinsic and primitive building blocks of all Rust code."](https://doc.rust-lang.org/core/)


## Red Zone

- Okay red zone is not particularly relevant to this class.
- But it is *extremely* cool.

```{.json filename="x86_64-osirs.json"}
{
    "disable-redzone": true,
}
```

- So I'm going to tell you about it.

## The Red Zone

- The **Red Zone** is a 128-byte optimization area below the current stack pointer ($RSP$).
    - "R" for 64 bit.
    - "SP" for "stack pointer"
- It is a specific feature of the x86-64 System V ABI (Application Binary Interface).
- It allows functions to use a small amount of stack space without actually moving the pointer.

## Performance Gains

- Normally, any data written to the stack requires an $RSP$ adjustment to prevent data corruption.
    - `sub rsp, 8`
    - `mov [rsp], rax`
- With the Red Zone, compilers can skip the subtraction for some functions.
- This reduces the number of instructions and speeds up function execution.
    - At the cost of *no longer tracking the stack*.

## Negative Indexing

- Since $RSP$ remains at the "top" of the stack, we access this memory using negative offsets.
- In assembly, this looks like `mov [rsp - 16], rax`.
- This treats the stack as a fixed-base array rather than a stack ADT.
- It is essentially "free" scratch space for short-lived data.

## The Danger of Interrupts

- The Red Zone is dangerous in kernel development because of **hardware interrupts**.
    - The OS has to deal with, say, someone hitting the power off button.
    - Someone plugging in a USB drive.
    - Lightning strikes.
    - Cosmic rays flipping bits
    
## Red Zone to Dead Zone
    
- When an interrupt occurs, the CPU pushes state (like $RIP$ and $RFLAGS$) onto the stack.
    - "Instruction pointer" and "flags".
- This will overwrite those 128 bytes of data.
- This leads to silent, non-deterministic memory corruption.
    - Generally regarded as bad.
    
## Read more

- There are good visuals here.
- [Read more](https://os.phil-opp.com/red-zone/)
- Handwaving now - Better for the compilers class I think!

## Ancient Nemesis

- You all know I love floating point numbers.
    - And with good reason!

```{.json filename="x86_64-osirs.json"}
{
    "features": "-mmx,-sse,+soft-float",
}
```

## Turn off floats

- `features` enables/disables target features. 
- We disable the `mmx` and `sse` features by prefixing them with a minus
- We enable the `soft-float` feature by prefixing it with a plus. 
- Note that there must be no spaces between different flags!

## MMX/SSE

- The `mmx` and `sse` features are performance optimizing vector operations from when Intel though they'd be able to hold off NVIDIA in the 90s.
- These are braodly called [Single Instruction Multiple Data (SIMD)](https://en.wikipedia.org/wiki/SIMD) instructions and are historically important.
    - Foundation of `numpy`
- We aren't using data frames in our kernel.

## Soft Float

- Floating point operations on `x86_64` require SIMD registers by default. 
    - That's right - floats are worse than you thought!
- To solve this problem, we add the `soft-float` feature, which emulates all floating point operations through software functions based on normal integers.
    - Just like [`f16`](https://cd-c89.github.io/rs/51_f16.html)

## Aside


- We also need to tell the Rust compiler `rustc` that we want to use the corresponding ABI.

```{.json filename="x86_64-osirs.json"}
{
    "rustc-abi": "x86-softfloat"
}
```
- I am 100% sure I can write an OS without hard or soft floats but I haven't worked far enough ahead to be absolutely certain.

## Altogether

```{.json filename="x86_64-osirs.json"}
{
    "llvm-target": "x86_64-unknown-none",
    "data-layout": "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128",
    "arch": "x86_64",
    "target-endian": "little",
    "target-pointer-width": 64,
    "target-c-int-width": 32,
    "os": "none",
    "executables": true,
    "linker-flavor": "ld.lld",
    "linker": "rust-lld",
    "panic-strategy": "abort",
    "disable-redzone": true,
    "features": "-mmx,-sse,+soft-float",
    "rustc-abi": "x86-softfloat"
}
```

## I just `curl`

```{.sh}
curl https://raw.githubusercontent.com/phil-opp/blog_os/refs/heads/post-02/x86_64-blog_os.json -o x86_64-osirs.json
```

## Tree

- For me looks like this.

```{.sh}
$ tree
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── main.rs
│   └── old.rs
└── x86_64-osirs.json

1 directory, 5 files
```

## Back to loops

- By the way, I've switched from cool, good recursion back to unexciting, drab loops
- Infinite recursion blows up the call stack and instantly segmentation faults.
    - This is because someone other than me wrote `rustc`.
    - I am not about to write `rustc`!
    
## Current main

```{.rs filename="src/main.rs"}
#![no_std]
#![no_main]

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    loop {}
}

#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}
```

## A note

- Remember the earlier mention of `core`
    - How we need `core` to also panic abort?
    - We note when looking at `src/main.rs` we do have a `core` reference.

## Linux Everywhere

- Okay so we aren't going to use Linux on our device.
- But we are going to use Linux *conventions*
    - Not Linux software, but Linux as a social technology.
- The `ld.lld` "linker-flavor" instructs LLVM to compile with the `-flavor gnu` flag.
- This means that we need an entry point named `_start` - same as before!

## Build it

- I bet it will work now.
    - Use our new target by passing the name of the JSON file as `--target`:

```{.sh}
$ cargo b --target x86_64-osirs.json
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `/home/user/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)
  --- stderr
  error: Error loading target specification: Field target-pointer-width in target specification is required. Run `rustc --print target-list` for a list of built-in targets
```

## Okay so

- Huh?

```{.sh}
Field target-pointer-width in target specification is required.
```

- We very explicitly included that.
- In the most annoying thing in the universe, `rustc` expect pointer width as a JSON string and not a JSON integer.
    - [Read more](https://github.com/rust-lang/rust/pull/144218)
    - It's fixed in Nightly, but I sleep at night, so I'm busy.
        
## Fix it?

- I kid you not this is the solution.   
    - "Rust has a type system!"
    - Sure it does.
    
```{.sh}
$ diff bad.wrong x86_64-osirs.json
6,7c6,7
<     "target-pointer-width": 64,
<     "target-c-int-width": 32,
---
>     "target-pointer-width": "64",
>     "target-c-int-width": "32",
```

## Now it works

- This time it will work.

```{.sh}
$ cargo b --target x86_64-osirs.json
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error[E0463]: can't find crate for `core`
  |
  = note: the `x86_64-osirs` target may not be installed
  = help: consider downloading the target with `rustup target add x86_64-osirs`

For more information about this error, try `rustc --explain E0463`.
error: could not compile `osirs` (bin "osirs") due to 1 previous error
```

- Okay I was bamboozled.

## The Core

:::: {.columns}

::: {.column width="70%"}

> [The Core is a 2003 American science fiction disaster film directed by Jon Amiel with screenplay written by Cooper Layne and John Rogers.](https://en.wikipedia.org/wiki/The_Core)

- I haven't seen it but it apparently passes the [Bechdel Test](https://en.wikipedia.org/wiki/Bechdel_test)

:::

::: {.column width="30%"}

![](https://upload.wikimedia.org/wikipedia/en/f/f4/The_Core_poster.jpg)

:::

::::

## Wrong Core

- We actually meant the Rust compiler `core` library.
    - [Read more](https://doc.rust-lang.org/nightly/core/index.html)
- This library contains basic Rust types such as `Result`, `Option`, and iterators, and is implicitly linked to all `no_std` crates.

## The Problem

- `core` is usually *pre-compiled* (and then, of course, linked).
- But we made a new target which needs a new core.
- No problem, we'll just tell `rustc` to do some compilation.

# TODO

- Have to compile core, so we alter .cargo/config.toml.

```{.sh}
$ cargo b --target x86_64-osirs.json
   Compiling osirs v0.1.0 (/home/user/tmp/32)
error[E0463]: can't find crate for `core`
  |
  = note: the `x86_64-osirs` target may not be installed
  = help: consider downloading the target with `rustup target add x86_64-osirs`

For more information about this error, try `rustc --explain E0463`.
error: could not compile `osirs` (bin "osirs") due to 1 previous error
```

- Then have to use nightly.

```{.sh}
$ cargo +nightly b --target x86_64-osirs.json
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - --crate-name ___ --print=file-names --target /home/user/tmp/32/x86_64-osirs.json --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=split-debuginfo --print=crate-name --print=cfg -Wwarnings` (exit status: 1)
  --- stderr
  error: error loading target specification: target-pointer-width: invalid type: string "64", expected u16 at line 6 column 32
    |
    = help: run `rustc --print target-list` for a list of built-in targets
```

- This re-bricks the .json, so we revert it.

```{.sh}
$ cargo +nightly b --target x86_64-osirs.json
error: "/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/Cargo.lock" does not exist, unable to build with the standard library, try:
        rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
```

- This requires a `rustup`.

```{.sh}
rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
```

- Building is then quite slow.  10+ seconds.

```{.sh}
$ cargo +nightly b --target x86_64-osirs.json
    Updating crates.io index
  Downloaded rustc-literal-escaper v0.0.5
  Downloaded rustc-demangle v0.1.26
  Downloaded addr2line v0.25.0
  Downloaded getopts v0.2.23
  Downloaded object v0.37.3
  Downloaded gimli v0.32.0
  Downloaded 6 crates (721.4KiB) in 0.14s
   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)
   Compiling core v0.0.0 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core)
   Compiling compiler_builtins v0.1.160 (/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins)
   Compiling osirs v0.1.0 (/home/user/tmp/32)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 10.40s
```



## The `build-std` Option

- `build-std` is a feature of Cargo.
- We can recompile `core` and other standard library crates on demand.
    - Vs. using the precompiled versions shipped with the Rust installation. 
This feature is very new and still not finished, so it is marked as "unstable" and only available on [nightly Rust compilers].

[`build-std` feature]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std
[nightly Rust compilers]: #installing-rust-nightly

To use the feature, we need to add the following to our [cargo configuration] file at `.cargo/config.toml`:

```toml
# in .cargo/config.toml

[unstable]
json-target-spec = true
build-std = ["core", "compiler_builtins"]
```

This tells cargo that it should recompile the `core` and `compiler_builtins` libraries. The latter is required because it is a dependency of `core`. In order to recompile these libraries, cargo needs access to the rust source code, which we can install with `rustup component add rust-src`.

<div class="note">

**Note:** The `unstable.build-std` configuration key requires at least the Rust nightly from 2020-07-15.

</div>

After setting the `unstable.build-std` configuration key and installing the `rust-src` component, we can rerun our build command:

```
> cargo build --target x86_64-blog_os.json
   Compiling core v0.0.0 (/…/rust/src/libcore)
   Compiling rustc-std-workspace-core v1.99.0 (/…/rust/src/tools/rustc-std-workspace-core)
   Compiling compiler_builtins v0.1.32
   Compiling blog_os v0.1.0 (/…/blog_os)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
```

We see that `cargo build` now recompiles the `core`, `rustc-std-workspace-core` (a dependency of `compiler_builtins`), and `compiler_builtins` libraries for our custom target.

## Memory-Related Intrinsics

The Rust compiler assumes that a certain set of built-in functions is available for all systems. Most of these functions are provided by the `compiler_builtins` crate that we just recompiled. However, there are some memory-related functions in that crate that are not enabled by default because they are normally provided by the C library on the system. These functions include `memset`, which sets all bytes in a memory block to a given value, `memcpy`, which copies one memory block to another, and `memcmp`, which compares two memory blocks. While we didn't need any of these functions to compile our kernel right now, they will be required as soon as we add some more code to it (e.g. when copying structs around).

Since we can't link to the C library of the operating system, we need an alternative way to provide these functions to the compiler. One possible approach for this could be to implement our own `memset` etc. functions and apply the `#[unsafe(no_mangle)]` attribute to them (to avoid the automatic renaming during compilation). However, this is dangerous since the slightest mistake in the implementation of these functions could lead to undefined behavior. For example, implementing `memcpy` with a `for` loop may result in an infinite recursion because `for` loops implicitly call the [`IntoIterator::into_iter`] trait method, which may call `memcpy` again. So it's a good idea to reuse existing, well-tested implementations instead.

[`IntoIterator::into_iter`]: https://doc.rust-lang.org/stable/core/iter/trait.IntoIterator.html#tymethod.into_iter

Fortunately, the `compiler_builtins` crate already contains implementations for all the needed functions, they are just disabled by default to not collide with the implementations from the C library. We can enable them by setting cargo's [`build-std-features`] flag to `["compiler-builtins-mem"]`. Like the `build-std` flag, this flag can be either passed on the command line as a `-Z` flag or configured in the `unstable` table in the `.cargo/config.toml` file. Since we always want to build with this flag, the config file option makes more sense for us:

[`build-std-features`]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std-features

```toml
# in .cargo/config.toml

[unstable]
json-target-spec = true
build-std-features = ["compiler-builtins-mem"]
build-std = ["core", "compiler_builtins"]
```

(Support for the `compiler-builtins-mem` feature was only [added very recently](https://github.com/rust-lang/rust/pull/77284), so you need at least Rust nightly `2020-09-30` for it.)

Behind the scenes, this flag enables the [`mem` feature] of the `compiler_builtins` crate. The effect of this is that the `#[unsafe(no_mangle)]` attribute is applied to the [`memcpy` etc. implementations] of the crate, which makes them available to the linker.

[`mem` feature]: https://github.com/rust-lang/compiler-builtins/blob/eff506cd49b637f1ab5931625a33cef7e91fbbf6/Cargo.toml#L54-L55
[`memcpy` etc. implementations]: https://github.com/rust-lang/compiler-builtins/blob/eff506cd49b637f1ab5931625a33cef7e91fbbf6/src/mem.rs#L12-L69

With this change, our kernel has valid implementations for all compiler-required functions, so it will continue to compile even if our code gets more complex.

## Set a Default Target

To avoid passing the `--target` parameter on every invocation of `cargo build`, we can override the default target. To do this, we add the following to our [cargo configuration] file at `.cargo/config.toml`:

[cargo configuration]: https://doc.rust-lang.org/cargo/reference/config.html

```toml
# in .cargo/config.toml

[build]
target = "x86_64-blog_os.json"
```

This tells `cargo` to use our `x86_64-blog_os.json` target when no explicit `--target` argument is passed. This means that we can now build our kernel with a simple `cargo build`. For more information on cargo configuration options, check out the [official documentation][cargo configuration].

We are now able to build our kernel for a bare metal target with a simple `cargo build`. However, our `_start` entry point, which will be called by the boot loader, is still empty. It's time that we output something to screen from it.

## Printing to Screen
The easiest way to print text to the screen at this stage is the [VGA text buffer]. It is a special memory area mapped to the VGA hardware that contains the contents displayed on screen. It normally consists of 25 lines that each contain 80 character cells. Each character cell displays an ASCII character with some foreground and background colors. The screen output looks like this:

[VGA text buffer]: https://en.wikipedia.org/wiki/VGA-compatible_text_mode

![screen output for common ASCII characters](https://upload.wikimedia.org/wikipedia/commons/f/f8/Codepage-437.png)

We will discuss the exact layout of the VGA buffer in the next post, where we write a first small driver for it. For printing “Hello World!”, we just need to know that the buffer is located at address `0xb8000` and that each character cell consists of an ASCII byte and a color byte.

The implementation looks like this:

```rust
static HELLO: &[u8] = b"Hello World!";

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    let vga_buffer = 0xb8000 as *mut u8;

    for (i, &byte) in HELLO.iter().enumerate() {
        unsafe {
            *vga_buffer.offset(i as isize * 2) = byte;
            *vga_buffer.offset(i as isize * 2 + 1) = 0xb;
        }
    }

    loop {}
}
```

First, we cast the integer `0xb8000` into a [raw pointer]. Then we [iterate] over the bytes of the [static] `HELLO` [byte string]. We use the [`enumerate`] method to additionally get a running variable `i`. In the body of the for loop, we use the [`offset`] method to write the string byte and the corresponding color byte (`0xb` is a light cyan).

[iterate]: https://doc.rust-lang.org/stable/book/ch13-02-iterators.html
[static]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime
[`enumerate`]: https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate
[byte string]: https://doc.rust-lang.org/reference/tokens.html#byte-string-literals
[raw pointer]: https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html#dereferencing-a-raw-pointer
[`offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.offset

Note that there's an [`unsafe`] block around all memory writes. The reason is that the Rust compiler can't prove that the raw pointers we create are valid. They could point anywhere and lead to data corruption. By putting them into an `unsafe` block, we're basically telling the compiler that we are absolutely sure that the operations are valid. Note that an `unsafe` block does not turn off Rust's safety checks. It only allows you to do [five additional things].

[`unsafe`]: https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html
[five additional things]: https://doc.rust-lang.org/stable/book/ch20-01-unsafe-rust.html#unsafe-superpowers

I want to emphasize that **this is not the way we want to do things in Rust!** It's very easy to mess up when working with raw pointers inside unsafe blocks. For example, we could easily write beyond the buffer's end if we're not careful.

So we want to minimize the use of `unsafe` as much as possible. Rust gives us the ability to do this by creating safe abstractions. For example, we could create a VGA buffer type that encapsulates all unsafety and ensures that it is _impossible_ to do anything wrong from the outside. This way, we would only need minimal amounts of `unsafe` code and can be sure that we don't violate [memory safety]. We will create such a safe VGA buffer abstraction in the next post.

[memory safety]: https://en.wikipedia.org/wiki/Memory_safety

## Running our Kernel

Now that we have an executable that does something perceptible, it is time to run it. First, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader. Then we can run the disk image in the [QEMU] virtual machine or boot it on real hardware using a USB stick.

## Creating a Bootimage

To turn our compiled kernel into a bootable disk image, we need to link it with a bootloader. As we learned in the [section about booting], the bootloader is responsible for initializing the CPU and loading our kernel.

[section about booting]: #the-boot-process

Instead of writing our own bootloader, which is a project on its own, we use the [`bootloader`] crate. This crate implements a basic BIOS bootloader without any C dependencies, just Rust and inline assembly. To use it for booting our kernel, we need to add a dependency on it:

[`bootloader`]: https://crates.io/crates/bootloader

```toml
# in Cargo.toml

[dependencies]
bootloader = "0.9"
```

**Note:** This post is only compatible with `bootloader v0.9`. Newer versions use a different build system and will result in build errors when following this post.

Adding the bootloader as a dependency is not enough to actually create a bootable disk image. The problem is that we need to link our kernel with the bootloader after compilation, but cargo has no support for [post-build scripts].

[post-build scripts]: https://github.com/rust-lang/cargo/issues/545

To solve this problem, we created a tool named `bootimage` that first compiles the kernel and bootloader, and then links them together to create a bootable disk image. To install the tool, go into your home directory (or any directory outside of your cargo project) and execute the following command in your terminal:

```
cargo install bootimage
```

For running `bootimage` and building the bootloader, you need to have the `llvm-tools-preview` rustup component installed. You can do so by executing `rustup component add llvm-tools-preview`.

After installing `bootimage` and adding the `llvm-tools-preview` component, you can create a bootable disk image by going back into your cargo project directory and executing:

```
> cargo bootimage
```

We see that the tool recompiles our kernel using `cargo build`, so it will automatically pick up any changes you make. Afterwards, it compiles the bootloader, which might take a while. Like all crate dependencies, it is only built once and then cached, so subsequent builds will be much faster. Finally, `bootimage` combines the bootloader and your kernel into a bootable disk image.

After executing the command, you should see a bootable disk image named `bootimage-blog_os.bin` in your `target/x86_64-blog_os/debug` directory. You can boot it in a virtual machine or copy it to a USB drive to boot it on real hardware. (Note that this is not a CD image, which has a different format, so burning it to a CD doesn't work).

## How does it work?
The `bootimage` tool performs the following steps behind the scenes:

- It compiles our kernel to an [ELF] file.
- It compiles the bootloader dependency as a standalone executable.
- It links the bytes of the kernel ELF file to the bootloader.

[ELF]: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format
[rust-osdev/bootloader]: https://github.com/rust-osdev/bootloader

When booted, the bootloader reads and parses the appended ELF file. It then maps the program segments to virtual addresses in the page tables, zeroes the `.bss` section, and sets up a stack. Finally, it reads the entry point address (our `_start` function) and jumps to it.

## Booting it in QEMU

We can now boot the disk image in a virtual machine. To boot it in [QEMU], execute the following command:

[QEMU]: https://www.qemu.org/

```
> qemu-system-x86_64 -drive format=raw,file=target/x86_64-blog_os/debug/bootimage-blog_os.bin
```

This opens a separate window which should look similar to this:

![QEMU showing "Hello World!"](qemu.png)

We see that our "Hello World!" is visible on the screen.

## Real Machine

It is also possible to write it to a USB stick and boot it on a real machine, **but be careful** to choose the correct device name, because **everything on that device is overwritten**:

```
> dd if=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX && sync
```

Where `sdX` is the device name of your USB stick. 

After writing the image to the USB stick, you can run it on real hardware by booting from it. You probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick. Note that it currently doesn't work for UEFI machines, since the `bootloader` crate has no UEFI support yet.

## Using `cargo run`

To make it easier to run our kernel in QEMU, we can set the `runner` configuration key for cargo:

```toml
# in .cargo/config.toml

[target.'cfg(target_os = "none")']
runner = "bootimage runner"
```

The `target.'cfg(target_os = "none")'` table applies to all targets whose target configuration file's `"os"` field is set to `"none"`. This includes our `x86_64-blog_os.json` target. The `runner` key specifies the command that should be invoked for `cargo run`. The command is run after a successful build with the executable path passed as the first argument. See the [cargo documentation][cargo configuration] for more details.

The `bootimage runner` command is specifically designed to be usable as a `runner` executable. It links the given executable with the project's bootloader dependency and then launches QEMU. See the [Readme of `bootimage`] for more details and possible configuration options.

[Readme of `bootimage`]: https://github.com/rust-osdev/bootimage

Now we can use `cargo run` to compile our kernel and boot it in QEMU.

## What's next?

In the next post, we will explore the VGA text buffer in more detail and write a safe interface for it. We will also add support for the `println` macro.